import { Terminal } from '@rushstack/node-core-library';

/**
 * @public
 */
export declare interface IStringValuesTypingsGeneratorOptions extends ITypingsGeneratorOptions<IStringValueTypings | undefined> {
    /**
     * Setting this option wraps the typings export in a default property.
     */
    exportAsDefault?: boolean;
    /**
     * When `exportAsDefault` is true, this optional setting determines the interface name
     * for the default wrapped export. Ignored when `exportAsDefault` is false.
     */
    exportAsDefaultInterfaceName?: string;
}

/**
 * @public
 */
export declare interface IStringValueTyping {
    exportName: string;
    comment?: string;
}

/**
 * @public
 */
export declare interface IStringValueTypings {
    typings: IStringValueTyping[];
}

/**
 * @public
 */
export declare interface ITypingsGeneratorOptions<TTypingsResult = string | undefined> {
    srcFolder: string;
    generatedTsFolder: string;
    fileExtensions: string[];
    parseAndGenerateTypings: (fileContents: string, filePath: string) => TTypingsResult | Promise<TTypingsResult>;
    terminal?: Terminal;
    filesToIgnore?: string[];
}

/**
 * This is a simple tool that generates .d.ts files for non-TS files that can be represented as
 * a simple set of named string exports.
 *
 * @public
 */
export declare class StringValuesTypingsGenerator extends TypingsGenerator {
    constructor(options: IStringValuesTypingsGeneratorOptions);
}

/**
 * This is a simple tool that generates .d.ts files for non-TS files.
 *
 * @public
 */
export declare class TypingsGenerator {
    private _targetMap;
    private _dependencyMap;
    protected _options: ITypingsGeneratorOptions;
    constructor(options: ITypingsGeneratorOptions);
    generateTypingsAsync(): Promise<void>;
    runWatcherAsync(): Promise<void>;
    /**
     * Register file dependencies that may effect the typings of a target file.
     * Note: This feature is only useful in watch mode.
     * The registerDependency method must be called in the body of parseAndGenerateTypings every
     * time because the registry for a file is cleared at the beginning of processing.
     */
    registerDependency(target: string, dependency: string): void;
    private _parseFileAndGenerateTypingsAsync;
    private _clearDependencies;
    private _getDependencyTargets;
    private _getTypingsFilePath;
    private _normalizeFileExtensions;
}

export { }
