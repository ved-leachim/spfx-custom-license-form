{"version":3,"file":"TypingsGenerator.js","sourceRoot":"","sources":["../src/TypingsGenerator.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport {\r\n  FileSystem,\r\n  Terminal,\r\n  ConsoleTerminalProvider,\r\n  Path,\r\n  NewlineKind\r\n} from '@rushstack/node-core-library';\r\nimport * as glob from 'glob';\r\nimport * as path from 'path';\r\nimport { EOL } from 'os';\r\nimport * as chokidar from 'chokidar';\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface ITypingsGeneratorOptions<TTypingsResult = string | undefined> {\r\n  srcFolder: string;\r\n  generatedTsFolder: string;\r\n  fileExtensions: string[];\r\n  parseAndGenerateTypings: (\r\n    fileContents: string,\r\n    filePath: string\r\n  ) => TTypingsResult | Promise<TTypingsResult>;\r\n  terminal?: Terminal;\r\n  filesToIgnore?: string[];\r\n}\r\n\r\n/**\r\n * This is a simple tool that generates .d.ts files for non-TS files.\r\n *\r\n * @public\r\n */\r\nexport class TypingsGenerator {\r\n  // Map of target file path -> Set<dependency file path>\r\n  private _targetMap: Map<string, Set<string>>;\r\n\r\n  // Map of dependency file path -> Set<target file path>\r\n  private _dependencyMap: Map<string, Set<string>>;\r\n\r\n  protected _options: ITypingsGeneratorOptions;\r\n\r\n  public constructor(options: ITypingsGeneratorOptions) {\r\n    this._options = {\r\n      ...options\r\n    };\r\n\r\n    if (!this._options.generatedTsFolder) {\r\n      throw new Error('generatedTsFolder must be provided');\r\n    }\r\n\r\n    if (!this._options.srcFolder) {\r\n      throw new Error('srcFolder must be provided');\r\n    }\r\n\r\n    if (Path.isUnder(this._options.srcFolder, this._options.generatedTsFolder)) {\r\n      throw new Error('srcFolder must not be under generatedTsFolder');\r\n    }\r\n\r\n    if (Path.isUnder(this._options.generatedTsFolder, this._options.srcFolder)) {\r\n      throw new Error('generatedTsFolder must not be under srcFolder');\r\n    }\r\n\r\n    if (!this._options.fileExtensions || this._options.fileExtensions.length === 0) {\r\n      throw new Error('At least one file extension must be provided.');\r\n    }\r\n\r\n    if (!this._options.filesToIgnore) {\r\n      this._options.filesToIgnore = [];\r\n    }\r\n\r\n    if (!this._options.terminal) {\r\n      this._options.terminal = new Terminal(new ConsoleTerminalProvider({ verboseEnabled: true }));\r\n    }\r\n\r\n    this._options.fileExtensions = this._normalizeFileExtensions(this._options.fileExtensions);\r\n\r\n    this._targetMap = new Map();\r\n\r\n    this._dependencyMap = new Map();\r\n  }\r\n\r\n  public async generateTypingsAsync(): Promise<void> {\r\n    await FileSystem.ensureEmptyFolderAsync(this._options.generatedTsFolder);\r\n\r\n    const filesToIgnore: Set<string> = new Set<string>(\r\n      this._options.filesToIgnore!.map((fileToIgnore) => {\r\n        return path.resolve(this._options.srcFolder, fileToIgnore);\r\n      })\r\n    );\r\n\r\n    const filePaths: string[] = glob.sync(path.join('**', `*+(${this._options.fileExtensions.join('|')})`), {\r\n      cwd: this._options.srcFolder,\r\n      absolute: true,\r\n      nosort: true,\r\n      nodir: true\r\n    });\r\n\r\n    for (let filePath of filePaths) {\r\n      filePath = path.resolve(this._options.srcFolder, filePath);\r\n\r\n      if (filesToIgnore.has(filePath)) {\r\n        continue;\r\n      }\r\n\r\n      await this._parseFileAndGenerateTypingsAsync(filePath);\r\n    }\r\n  }\r\n\r\n  public async runWatcherAsync(): Promise<void> {\r\n    await FileSystem.ensureFolderAsync(this._options.generatedTsFolder);\r\n\r\n    const globBase: string = path.resolve(this._options.srcFolder, '**');\r\n\r\n    await new Promise((resolve, reject): void => {\r\n      const watcher: chokidar.FSWatcher = chokidar.watch(\r\n        this._options.fileExtensions.map((fileExtension) => path.join(globBase, `*${fileExtension}`))\r\n      );\r\n      const boundGenerateTypingsFunction: (\r\n        filePath: string\r\n      ) => Promise<void> = this._parseFileAndGenerateTypingsAsync.bind(this);\r\n      watcher.on('add', boundGenerateTypingsFunction);\r\n      watcher.on('change', boundGenerateTypingsFunction);\r\n      watcher.on('unlink', async (filePath) => {\r\n        const generatedTsFilePath: string = this._getTypingsFilePath(filePath);\r\n        await FileSystem.deleteFileAsync(generatedTsFilePath);\r\n      });\r\n      watcher.on('error', reject);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Register file dependencies that may effect the typings of a target file.\r\n   * Note: This feature is only useful in watch mode.\r\n   * The registerDependency method must be called in the body of parseAndGenerateTypings every\r\n   * time because the registry for a file is cleared at the beginning of processing.\r\n   */\r\n  public registerDependency(target: string, dependency: string): void {\r\n    let targetDependencySet: Set<string> | undefined = this._targetMap.get(target);\r\n    if (!targetDependencySet) {\r\n      targetDependencySet = new Set();\r\n      this._targetMap.set(target, targetDependencySet);\r\n    }\r\n    targetDependencySet.add(dependency);\r\n\r\n    let dependencyTargetSet: Set<string> | undefined = this._dependencyMap.get(dependency);\r\n    if (!dependencyTargetSet) {\r\n      dependencyTargetSet = new Set();\r\n      this._dependencyMap.set(dependency, dependencyTargetSet);\r\n    }\r\n    dependencyTargetSet.add(target);\r\n  }\r\n\r\n  private async _parseFileAndGenerateTypingsAsync(locFilePath: string): Promise<void> {\r\n    // Clear registered dependencies prior to reprocessing.\r\n    this._clearDependencies(locFilePath);\r\n\r\n    // Check for targets that register this file as a dependency, and reprocess them too.\r\n    for (const target of this._getDependencyTargets(locFilePath)) {\r\n      await this._parseFileAndGenerateTypingsAsync(target);\r\n    }\r\n\r\n    try {\r\n      const fileContents: string = await FileSystem.readFileAsync(locFilePath);\r\n      const typingsData: string | undefined = await this._options.parseAndGenerateTypings(\r\n        fileContents,\r\n        locFilePath\r\n      );\r\n      const generatedTsFilePath: string = this._getTypingsFilePath(locFilePath);\r\n\r\n      // Typings data will be undefined when no types should be generated for the parsed file.\r\n      if (typingsData === undefined) {\r\n        return;\r\n      }\r\n\r\n      const prefixedTypingsData: string = [\r\n        '// This file was generated by a tool. Modifying it will produce unexpected behavior',\r\n        '',\r\n        typingsData\r\n      ].join(EOL);\r\n\r\n      await FileSystem.writeFileAsync(generatedTsFilePath, prefixedTypingsData, {\r\n        ensureFolderExists: true,\r\n        convertLineEndings: NewlineKind.OsDefault\r\n      });\r\n    } catch (e) {\r\n      this._options.terminal!.writeError(\r\n        `Error occurred parsing and generating typings for file \"${locFilePath}\": ${e}`\r\n      );\r\n    }\r\n  }\r\n\r\n  private _clearDependencies(target: string): void {\r\n    const targetDependencySet: Set<string> | undefined = this._targetMap.get(target);\r\n    if (targetDependencySet) {\r\n      for (const dependency of targetDependencySet) {\r\n        this._dependencyMap.get(dependency)!.delete(target);\r\n      }\r\n      targetDependencySet.clear();\r\n    }\r\n  }\r\n\r\n  private _getDependencyTargets(dependency: string): string[] {\r\n    return [...(this._dependencyMap.get(dependency)?.keys() || [])];\r\n  }\r\n\r\n  private _getTypingsFilePath(locFilePath: string): string {\r\n    return path.resolve(\r\n      this._options.generatedTsFolder,\r\n      path.relative(this._options.srcFolder, `${locFilePath}.d.ts`)\r\n    );\r\n  }\r\n\r\n  private _normalizeFileExtensions(fileExtensions: string[]): string[] {\r\n    const result: string[] = [];\r\n    for (const fileExtension of fileExtensions) {\r\n      if (!fileExtension.startsWith('.')) {\r\n        result.push(`.${fileExtension}`);\r\n      } else {\r\n        result.push(fileExtension);\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n}\r\n"]}