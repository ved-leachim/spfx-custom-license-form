{"version":3,"file":"AssetProcessor.js","sourceRoot":"","sources":["../src/AssetProcessor.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as Webpack from 'webpack';\r\nimport * as lodash from 'lodash';\r\n\r\nimport { Constants } from './utilities/Constants';\r\nimport { ILocaleElementMap } from './interfaces';\r\nimport { LocalizationPlugin, IStringSerialNumberData as IStringData } from './LocalizationPlugin';\r\n\r\ninterface IReconstructionElement {\r\n  kind: 'static' | 'localized' | 'dynamic';\r\n}\r\n\r\ninterface IStaticReconstructionElement extends IReconstructionElement {\r\n  kind: 'static';\r\n  staticString: string;\r\n}\r\n\r\ninterface ILocalizedReconstructionElement extends IReconstructionElement {\r\n  kind: 'localized';\r\n  values: ILocaleElementMap;\r\n  size: number;\r\n  stringName: string;\r\n  escapedBackslash: string;\r\n  locFilePath: string;\r\n}\r\n\r\ninterface IDynamicReconstructionElement extends IReconstructionElement {\r\n  kind: 'dynamic';\r\n  valueFn: (locale: string, token: string | undefined) => string;\r\n  size: number;\r\n  escapedBackslash: string;\r\n  token?: string;\r\n}\r\n\r\ninterface IParseResult {\r\n  issues: string[];\r\n  reconstructionSeries: IReconstructionElement[];\r\n}\r\n\r\ninterface IReconstructedString {\r\n  source: string;\r\n  size: number;\r\n}\r\n\r\ninterface ILocalizedReconstructionResult {\r\n  result: Map<string, IReconstructedString>;\r\n  issues: string[];\r\n}\r\n\r\ninterface INonLocalizedReconstructionResult {\r\n  result: IReconstructedString;\r\n  issues: string[];\r\n}\r\n\r\nexport interface IProcessAssetOptionsBase {\r\n  plugin: LocalizationPlugin;\r\n  compilation: Webpack.compilation.Compilation;\r\n  assetName: string;\r\n  asset: IAsset;\r\n  chunk: Webpack.compilation.Chunk;\r\n  noStringsLocaleName: string;\r\n  chunkHasLocalizedModules: (chunk: Webpack.compilation.Chunk) => boolean;\r\n}\r\n\r\nexport interface IProcessNonLocalizedAssetOptions extends IProcessAssetOptionsBase {}\r\n\r\nexport interface IProcessLocalizedAssetOptions extends IProcessAssetOptionsBase {\r\n  locales: Set<string>;\r\n  fillMissingTranslationStrings: boolean;\r\n  defaultLocale: string;\r\n}\r\n\r\nexport interface IAsset {\r\n  size(): number;\r\n  source(): string;\r\n}\r\n\r\nexport interface IProcessAssetResult {\r\n  filename: string;\r\n  asset: IAsset;\r\n}\r\n\r\nexport const PLACEHOLDER_REGEX: RegExp = new RegExp(\r\n  `${Constants.STRING_PLACEHOLDER_PREFIX}_(\\\\\\\\*)_([A-C])(\\\\+[^+]+\\\\+)?_(\\\\d+)`,\r\n  'g'\r\n);\r\n\r\nexport class AssetProcessor {\r\n  public static processLocalizedAsset(\r\n    options: IProcessLocalizedAssetOptions\r\n  ): Map<string, IProcessAssetResult> {\r\n    const assetSource: string = options.asset.source();\r\n\r\n    const parsedAsset: IParseResult = AssetProcessor._parseStringToReconstructionSequence(\r\n      options.plugin,\r\n      assetSource,\r\n      this._getJsonpFunction(options.chunk, options.chunkHasLocalizedModules, options.noStringsLocaleName)\r\n    );\r\n    const reconstructedAsset: ILocalizedReconstructionResult = AssetProcessor._reconstructLocalized(\r\n      parsedAsset.reconstructionSeries,\r\n      options.locales,\r\n      options.fillMissingTranslationStrings,\r\n      options.defaultLocale,\r\n      options.asset.size()\r\n    );\r\n\r\n    const parsedAssetName: IParseResult = AssetProcessor._parseStringToReconstructionSequence(\r\n      options.plugin,\r\n      options.assetName,\r\n      () => {\r\n        throw new Error('unsupported');\r\n      }\r\n    );\r\n    const reconstructedAssetName: ILocalizedReconstructionResult = AssetProcessor._reconstructLocalized(\r\n      parsedAssetName.reconstructionSeries,\r\n      options.locales,\r\n      options.fillMissingTranslationStrings,\r\n      options.defaultLocale,\r\n      options.assetName.length\r\n    );\r\n\r\n    const result: Map<string, IProcessAssetResult> = new Map<string, IProcessAssetResult>();\r\n    for (const [locale, { source, size }] of reconstructedAsset.result) {\r\n      const newAsset: IAsset = lodash.clone(options.asset);\r\n      newAsset.source = () => source;\r\n      newAsset.size = () => size;\r\n\r\n      result.set(locale, {\r\n        filename: reconstructedAssetName.result.get(locale)!.source,\r\n        asset: newAsset\r\n      });\r\n    }\r\n\r\n    const issues: string[] = [\r\n      ...parsedAsset.issues,\r\n      ...reconstructedAsset.issues,\r\n      ...parsedAssetName.issues,\r\n      ...reconstructedAssetName.issues\r\n    ];\r\n\r\n    if (issues.length > 0) {\r\n      options.compilation.errors.push(\r\n        Error(`localization:\\n${issues.map((issue) => `  ${issue}`).join('\\n')}`)\r\n      );\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  public static processNonLocalizedAsset(options: IProcessNonLocalizedAssetOptions): IProcessAssetResult {\r\n    const assetSource: string = options.asset.source();\r\n\r\n    const parsedAsset: IParseResult = AssetProcessor._parseStringToReconstructionSequence(\r\n      options.plugin,\r\n      assetSource,\r\n      this._getJsonpFunction(options.chunk, options.chunkHasLocalizedModules, options.noStringsLocaleName)\r\n    );\r\n    const reconstructedAsset: INonLocalizedReconstructionResult = AssetProcessor._reconstructNonLocalized(\r\n      parsedAsset.reconstructionSeries,\r\n      options.asset.size(),\r\n      options.noStringsLocaleName\r\n    );\r\n\r\n    const parsedAssetName: IParseResult = AssetProcessor._parseStringToReconstructionSequence(\r\n      options.plugin,\r\n      options.assetName,\r\n      () => {\r\n        throw new Error('unsupported');\r\n      }\r\n    );\r\n    const reconstructedAssetName: INonLocalizedReconstructionResult = AssetProcessor._reconstructNonLocalized(\r\n      parsedAssetName.reconstructionSeries,\r\n      options.assetName.length,\r\n      options.noStringsLocaleName\r\n    );\r\n\r\n    const issues: string[] = [\r\n      ...parsedAsset.issues,\r\n      ...reconstructedAsset.issues,\r\n      ...parsedAssetName.issues,\r\n      ...reconstructedAssetName.issues\r\n    ];\r\n\r\n    if (issues.length > 0) {\r\n      options.compilation.errors.push(\r\n        Error(`localization:\\n${issues.map((issue) => `  ${issue}`).join('\\n')}`)\r\n      );\r\n    }\r\n\r\n    const newAsset: IAsset = lodash.clone(options.asset);\r\n    newAsset.source = () => reconstructedAsset.result.source;\r\n    newAsset.size = () => reconstructedAsset.result.size;\r\n    return {\r\n      filename: reconstructedAssetName.result.source,\r\n      asset: newAsset\r\n    };\r\n  }\r\n\r\n  private static _reconstructLocalized(\r\n    reconstructionSeries: IReconstructionElement[],\r\n    locales: Set<string>,\r\n    fillMissingTranslationStrings: boolean,\r\n    defaultLocale: string,\r\n    initialSize: number\r\n  ): ILocalizedReconstructionResult {\r\n    const localizedResults: Map<string, IReconstructedString> = new Map<string, IReconstructedString>();\r\n    const issues: string[] = [];\r\n\r\n    for (const locale of locales) {\r\n      const reconstruction: string[] = [];\r\n\r\n      let sizeDiff: number = 0;\r\n      for (const element of reconstructionSeries) {\r\n        switch (element.kind) {\r\n          case 'static': {\r\n            reconstruction.push((element as IStaticReconstructionElement).staticString);\r\n            break;\r\n          }\r\n\r\n          case 'localized': {\r\n            const localizedElement: ILocalizedReconstructionElement = element as ILocalizedReconstructionElement;\r\n            let newValue: string | undefined = localizedElement.values[locale];\r\n            if (!newValue) {\r\n              if (fillMissingTranslationStrings) {\r\n                newValue = localizedElement.values[defaultLocale];\r\n              } else {\r\n                issues.push(\r\n                  `The string \"${localizedElement.stringName}\" in \"${localizedElement.locFilePath}\" is missing in ` +\r\n                    `the locale ${locale}`\r\n                );\r\n\r\n                newValue = '-- MISSING STRING --';\r\n              }\r\n            }\r\n\r\n            const escapedBackslash: string = localizedElement.escapedBackslash || '\\\\';\r\n\r\n            // Replace backslashes with the properly escaped backslash\r\n            newValue = newValue.replace(/\\\\/g, escapedBackslash);\r\n\r\n            // @todo: look into using JSON.parse(...) to get the escaping characters\r\n            const escapingCharacterSequence: string = escapedBackslash.substr(escapedBackslash.length / 2);\r\n\r\n            // Ensure the the quotemark, apostrophe, tab, and newline characters are properly escaped\r\n            newValue = newValue.replace(/\\r/g, `${escapingCharacterSequence}r`);\r\n            newValue = newValue.replace(/\\n/g, `${escapingCharacterSequence}n`);\r\n            newValue = newValue.replace(/\\t/g, `${escapingCharacterSequence}t`);\r\n            newValue = newValue.replace(/\\\"/g, `${escapingCharacterSequence}u0022`);\r\n            newValue = newValue.replace(/\\'/g, `${escapingCharacterSequence}u0027`);\r\n\r\n            reconstruction.push(newValue);\r\n            sizeDiff += newValue.length - localizedElement.size;\r\n            break;\r\n          }\r\n\r\n          case 'dynamic': {\r\n            const dynamicElement: IDynamicReconstructionElement = element as IDynamicReconstructionElement;\r\n            const newValue: string = dynamicElement.valueFn(locale, dynamicElement.token);\r\n            reconstruction.push(newValue);\r\n            sizeDiff += newValue.length - dynamicElement.size;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      const newAssetSource: string = reconstruction.join('');\r\n      localizedResults.set(locale, {\r\n        source: newAssetSource,\r\n        size: initialSize + sizeDiff\r\n      });\r\n    }\r\n\r\n    return {\r\n      issues,\r\n      result: localizedResults\r\n    };\r\n  }\r\n\r\n  private static _reconstructNonLocalized(\r\n    reconstructionSeries: IReconstructionElement[],\r\n    initialSize: number,\r\n    noStringsLocaleName: string\r\n  ): INonLocalizedReconstructionResult {\r\n    const issues: string[] = [];\r\n\r\n    const reconstruction: string[] = [];\r\n\r\n    let sizeDiff: number = 0;\r\n    for (const element of reconstructionSeries) {\r\n      switch (element.kind) {\r\n        case 'static': {\r\n          reconstruction.push((element as IStaticReconstructionElement).staticString);\r\n          break;\r\n        }\r\n\r\n        case 'localized': {\r\n          const localizedElement: ILocalizedReconstructionElement = element as ILocalizedReconstructionElement;\r\n          issues.push(\r\n            `The string \"${localizedElement.stringName}\" in \"${localizedElement.locFilePath}\" appeared in an asset ` +\r\n              'that is not expected to contain localized resources.'\r\n          );\r\n\r\n          const newValue: string = '-- NOT EXPECTED TO BE LOCALIZED --';\r\n          reconstruction.push(newValue);\r\n          sizeDiff += newValue.length - localizedElement.size;\r\n          break;\r\n        }\r\n\r\n        case 'dynamic': {\r\n          const dynamicElement: IDynamicReconstructionElement = element as IDynamicReconstructionElement;\r\n          const newValue: string = dynamicElement.valueFn(noStringsLocaleName, dynamicElement.token);\r\n          reconstruction.push(newValue);\r\n          sizeDiff += newValue.length - dynamicElement.size;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    const newAssetSource: string = reconstruction.join('');\r\n    return {\r\n      issues,\r\n      result: {\r\n        source: newAssetSource,\r\n        size: initialSize + sizeDiff\r\n      }\r\n    };\r\n  }\r\n\r\n  private static _parseStringToReconstructionSequence(\r\n    plugin: LocalizationPlugin,\r\n    source: string,\r\n    jsonpFunction: (locale: string, chunkIdToken: string | undefined) => string\r\n  ): IParseResult {\r\n    const issues: string[] = [];\r\n    const reconstructionSeries: IReconstructionElement[] = [];\r\n\r\n    let lastIndex: number = 0;\r\n    let regexResult: RegExpExecArray | null;\r\n    while ((regexResult = PLACEHOLDER_REGEX.exec(source))) {\r\n      // eslint-disable-line no-cond-assign\r\n      const staticElement: IStaticReconstructionElement = {\r\n        kind: 'static',\r\n        staticString: source.substring(lastIndex, regexResult.index)\r\n      };\r\n      reconstructionSeries.push(staticElement);\r\n\r\n      const [placeholder, escapedBackslash, elementLabel, token, placeholderSerialNumber] = regexResult;\r\n\r\n      let localizedReconstructionElement: IReconstructionElement;\r\n      switch (elementLabel) {\r\n        case Constants.STRING_PLACEHOLDER_LABEL: {\r\n          const stringData: IStringData | undefined = plugin.getDataForSerialNumber(placeholderSerialNumber);\r\n          if (!stringData) {\r\n            issues.push(`Missing placeholder ${placeholder}`);\r\n            const brokenLocalizedElement: IStaticReconstructionElement = {\r\n              kind: 'static',\r\n              staticString: placeholder\r\n            };\r\n            localizedReconstructionElement = brokenLocalizedElement;\r\n          } else {\r\n            const localizedElement: ILocalizedReconstructionElement = {\r\n              kind: 'localized',\r\n              values: stringData.values,\r\n              size: placeholder.length,\r\n              locFilePath: stringData.locFilePath,\r\n              escapedBackslash: escapedBackslash,\r\n              stringName: stringData.stringName\r\n            };\r\n            localizedReconstructionElement = localizedElement;\r\n          }\r\n          break;\r\n        }\r\n\r\n        case Constants.LOCALE_NAME_PLACEHOLDER_LABEL: {\r\n          const dynamicElement: IDynamicReconstructionElement = {\r\n            kind: 'dynamic',\r\n            valueFn: (locale: string) => locale,\r\n            size: placeholder.length,\r\n            escapedBackslash: escapedBackslash\r\n          };\r\n          localizedReconstructionElement = dynamicElement;\r\n          break;\r\n        }\r\n\r\n        case Constants.JSONP_PLACEHOLDER_LABEL: {\r\n          const dynamicElement: IDynamicReconstructionElement = {\r\n            kind: 'dynamic',\r\n            valueFn: jsonpFunction,\r\n            size: placeholder.length,\r\n            escapedBackslash: escapedBackslash,\r\n            token: token.substring(1, token.length - 1)\r\n          };\r\n          localizedReconstructionElement = dynamicElement;\r\n          break;\r\n        }\r\n\r\n        default: {\r\n          throw new Error(`Unexpected label ${elementLabel}`);\r\n        }\r\n      }\r\n\r\n      reconstructionSeries.push(localizedReconstructionElement);\r\n      lastIndex = regexResult.index + placeholder.length;\r\n    }\r\n\r\n    const lastElement: IStaticReconstructionElement = {\r\n      kind: 'static',\r\n      staticString: source.substr(lastIndex)\r\n    };\r\n    reconstructionSeries.push(lastElement);\r\n\r\n    return {\r\n      issues,\r\n      reconstructionSeries\r\n    };\r\n  }\r\n\r\n  private static _getJsonpFunction(\r\n    chunk: Webpack.compilation.Chunk,\r\n    chunkHasLocalizedModules: (chunk: Webpack.compilation.Chunk) => boolean,\r\n    noStringsLocaleName: string\r\n  ): (locale: string, chunkIdToken: string | undefined) => string {\r\n    const idsWithStrings: Set<number | string> = new Set<number | string>();\r\n    const idsWithoutStrings: Set<number | string> = new Set<number | string>();\r\n\r\n    const asyncChunks: Set<Webpack.compilation.Chunk> = chunk.getAllAsyncChunks();\r\n    for (const asyncChunk of asyncChunks) {\r\n      const chunkId: number | string | null = asyncChunk.id;\r\n\r\n      if (chunkId === null || chunkId === undefined) {\r\n        throw new Error(`Chunk \"${asyncChunk.name}\"'s ID is null or undefined.`);\r\n      }\r\n\r\n      if (chunkHasLocalizedModules(asyncChunk)) {\r\n        idsWithStrings.add(chunkId);\r\n      } else {\r\n        idsWithoutStrings.add(chunkId);\r\n      }\r\n    }\r\n\r\n    if (idsWithStrings.size === 0) {\r\n      return () => JSON.stringify(noStringsLocaleName);\r\n    } else if (idsWithoutStrings.size === 0) {\r\n      return (locale: string) => JSON.stringify(locale);\r\n    } else {\r\n      // Generate an array [<locale>, <nostrings locale>] and an object that is used as an indexer into that\r\n      // object that maps chunk IDs to 0s for chunks with localized strings and 1s for chunks without localized\r\n      // strings\r\n      //\r\n      // This can be improved in the future. We can maybe sort the chunks such that the chunks below a certain ID\r\n      // number are localized and the those above are not.\r\n      const chunkMapping: { [chunkId: string]: number } = {};\r\n      for (const idWithStrings of idsWithStrings) {\r\n        chunkMapping[idWithStrings] = 0;\r\n      }\r\n\r\n      for (const idWithoutStrings of idsWithoutStrings) {\r\n        chunkMapping[idWithoutStrings] = 1;\r\n      }\r\n\r\n      return (locale: string, chunkIdToken: string | undefined) => {\r\n        if (!locale) {\r\n          throw new Error('Missing locale name.');\r\n        }\r\n\r\n        return `(${JSON.stringify([locale, noStringsLocaleName])})[${JSON.stringify(\r\n          chunkMapping\r\n        )}[${chunkIdToken}]]`;\r\n      };\r\n    }\r\n  }\r\n}\r\n"]}