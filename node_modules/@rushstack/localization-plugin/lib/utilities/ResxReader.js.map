{"version":3,"file":"ResxReader.js","sourceRoot":"","sources":["../../src/utilities/ResxReader.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport { FileSystem, Terminal, Text, NewlineKind } from '@rushstack/node-core-library';\r\nimport { XmlDocument, XmlElement } from 'xmldoc';\r\n\r\nimport { ILocalizedString, ILocalizationFile } from '../interfaces';\r\n\r\nconst STRING_NAME_RESX: RegExp = /^[A-z_$][A-z0-9_$]*$/;\r\n\r\nexport interface IResxReaderOptions {\r\n  resxFilePath: string;\r\n  terminal: Terminal;\r\n  newlineNormalization: NewlineKind | undefined;\r\n}\r\n\r\ninterface ILoggingFunctions {\r\n  logError: (message: string) => void;\r\n  logWarning: (message: string) => void;\r\n  logFileError: (message: string, filePath: string, line?: number, position?: number) => void;\r\n  logFileWarning: (message: string, filePath: string, line?: number, position?: number) => void;\r\n}\r\n\r\ninterface IResxReaderOptionsInternal {\r\n  resxFilePath: string;\r\n  resxContents: string;\r\n  loggingFunctions: ILoggingFunctions;\r\n  newlineNormalization: NewlineKind | undefined;\r\n}\r\n\r\nexport class ResxReader {\r\n  public static readResxFileAsLocFile(options: IResxReaderOptions): ILocalizationFile {\r\n    const resxContents: string = FileSystem.readFile(options.resxFilePath);\r\n    return ResxReader.readResxAsLocFile(resxContents, options);\r\n  }\r\n\r\n  public static readResxAsLocFile(resxContents: string, options: IResxReaderOptions): ILocalizationFile {\r\n    const writeError: (message: string) => void = options.terminal.writeErrorLine.bind(options.terminal);\r\n    const writeWarning: (message: string) => void = options.terminal.writeWarningLine.bind(options.terminal);\r\n    const loggingFunctions: ILoggingFunctions = {\r\n      logError: (message: string) => writeError(message),\r\n      logWarning: (message: string) => writeWarning(message),\r\n      logFileError: (message: string, filePath: string, line?: number, position?: number) => {\r\n        ResxReader._logWithLocation(writeError, message, filePath, line, position);\r\n      },\r\n      logFileWarning: (message: string, filePath: string, line?: number, position?: number) => {\r\n        ResxReader._logWithLocation(writeWarning, message, filePath, line, position);\r\n      }\r\n    };\r\n\r\n    return this._readResxAsLocFileInternal({\r\n      resxFilePath: options.resxFilePath,\r\n      resxContents,\r\n      loggingFunctions,\r\n      newlineNormalization: options.newlineNormalization\r\n    });\r\n  }\r\n\r\n  private static _readResxAsLocFileInternal(options: IResxReaderOptionsInternal): ILocalizationFile {\r\n    const xmlDocument: XmlDocument = new XmlDocument(options.resxContents);\r\n\r\n    if (xmlDocument.name !== 'root') {\r\n      ResxReader._logErrorWithLocation(\r\n        options,\r\n        `Expected RESX to have a \"root\" element, found \"${xmlDocument.name}\"`,\r\n        xmlDocument\r\n      );\r\n    }\r\n\r\n    const locFile: ILocalizationFile = {};\r\n\r\n    for (const childNode of xmlDocument.children) {\r\n      switch (childNode.type) {\r\n        case 'element': {\r\n          switch (childNode.name) {\r\n            case 'data': {\r\n              const stringName: string = childNode.attr.name;\r\n              if (!stringName) {\r\n                ResxReader._logErrorWithLocation(\r\n                  options,\r\n                  'Unexpected missing or empty string name',\r\n                  childNode\r\n                );\r\n              } else if (!STRING_NAME_RESX.test(stringName)) {\r\n                ResxReader._logErrorWithLocation(options, `Invalid string name \"${stringName}\"`, childNode);\r\n              } else {\r\n                if (locFile.hasOwnProperty(stringName)) {\r\n                  ResxReader._logErrorWithLocation(\r\n                    options,\r\n                    `Duplicate string value \"${stringName}\"`,\r\n                    childNode\r\n                  );\r\n                }\r\n\r\n                const locString: ILocalizedString | undefined = ResxReader._readDataElement(\r\n                  options,\r\n                  childNode\r\n                );\r\n\r\n                if (locString) {\r\n                  locFile[stringName] = locString;\r\n                }\r\n              }\r\n\r\n              break;\r\n            }\r\n\r\n            // Other allowed elements\r\n            case 'xsd:schema':\r\n            case 'resheader':\r\n              break;\r\n\r\n            default:\r\n              ResxReader._logErrorWithLocation(\r\n                options,\r\n                `Unexpected RESX element ${childNode.name}`,\r\n                childNode\r\n              );\r\n          }\r\n\r\n          break;\r\n        }\r\n\r\n        case 'text': {\r\n          if (childNode.text.trim() !== '') {\r\n            ResxReader._logErrorWithLocation(options, 'Found unexpected non-empty text node in RESX');\r\n          }\r\n\r\n          break;\r\n        }\r\n\r\n        case 'comment':\r\n          break;\r\n\r\n        default:\r\n          ResxReader._logErrorWithLocation(options, `Unexpected ${childNode.type} child in RESX`);\r\n          break;\r\n      }\r\n    }\r\n\r\n    return locFile;\r\n  }\r\n\r\n  private static _readDataElement(\r\n    options: IResxReaderOptionsInternal,\r\n    dataElement: XmlElement\r\n  ): ILocalizedString | undefined {\r\n    let foundCommentElement: boolean = false;\r\n    let foundValueElement: boolean = false;\r\n    let comment: string | undefined = undefined;\r\n    let value: string | undefined = undefined;\r\n\r\n    for (const childNode of dataElement.children) {\r\n      switch (childNode.type) {\r\n        case 'element': {\r\n          switch (childNode.name) {\r\n            case 'value': {\r\n              if (foundValueElement) {\r\n                ResxReader._logErrorWithLocation(options, 'Duplicate <value> element found', childNode);\r\n              } else {\r\n                foundValueElement = true;\r\n                value = ResxReader._readTextElement(options, childNode);\r\n                if (value && options.newlineNormalization) {\r\n                  value = Text.convertTo(value, options.newlineNormalization);\r\n                }\r\n              }\r\n\r\n              break;\r\n            }\r\n\r\n            case 'comment': {\r\n              if (foundCommentElement) {\r\n                ResxReader._logErrorWithLocation(options, 'Duplicate <comment> element found', childNode);\r\n              } else {\r\n                foundCommentElement = true;\r\n                comment = ResxReader._readTextElement(options, childNode);\r\n              }\r\n\r\n              break;\r\n            }\r\n\r\n            default:\r\n              ResxReader._logErrorWithLocation(\r\n                options,\r\n                `Unexpected RESX element ${childNode.name}`,\r\n                childNode\r\n              );\r\n              break;\r\n          }\r\n\r\n          break;\r\n        }\r\n\r\n        case 'text': {\r\n          if (childNode.text.trim() !== '') {\r\n            ResxReader._logErrorWithLocation(\r\n              options,\r\n              'Found unexpected non-empty text node in RESX <data> element',\r\n              dataElement\r\n            );\r\n          }\r\n\r\n          break;\r\n        }\r\n\r\n        case 'comment':\r\n          break;\r\n\r\n        default:\r\n          ResxReader._logErrorWithLocation(\r\n            options,\r\n            `Unexpected ${childNode.type} child in RESX <data> element`,\r\n            dataElement\r\n          );\r\n      }\r\n    }\r\n\r\n    if (!foundValueElement) {\r\n      ResxReader._logErrorWithLocation(options, 'Missing string value in <data> element', dataElement);\r\n    } else {\r\n      if (comment === undefined) {\r\n        ResxReader._logWarningWithLocation(options, 'Missing string comment in <data> element', dataElement);\r\n      }\r\n\r\n      return {\r\n        value: value || '',\r\n        comment\r\n      };\r\n    }\r\n  }\r\n\r\n  private static _readTextElement(\r\n    options: IResxReaderOptionsInternal,\r\n    element: XmlElement\r\n  ): string | undefined {\r\n    let foundText: string | undefined = undefined;\r\n\r\n    for (const childNode of element.children) {\r\n      switch (childNode.type) {\r\n        case 'cdata':\r\n        case 'text': {\r\n          if (foundText !== undefined) {\r\n            ResxReader._logErrorWithLocation(\r\n              options,\r\n              'More than one child node found containing text content',\r\n              element\r\n            );\r\n            break;\r\n          }\r\n\r\n          foundText = childNode.type === 'text' ? childNode.text : childNode.cdata;\r\n          break;\r\n        }\r\n\r\n        case 'comment':\r\n          break;\r\n\r\n        case 'element':\r\n          ResxReader._logErrorWithLocation(options, `Unexpected element`, childNode);\r\n          break;\r\n\r\n        default:\r\n          ResxReader._logErrorWithLocation(options, `Unexpected ${element.type} child`, element);\r\n          break;\r\n      }\r\n    }\r\n\r\n    return foundText;\r\n  }\r\n\r\n  private static _logErrorWithLocation(\r\n    options: IResxReaderOptionsInternal,\r\n    message: string,\r\n    element?: XmlElement | XmlDocument\r\n  ): void {\r\n    if (element) {\r\n      options.loggingFunctions.logFileError(\r\n        message,\r\n        options.resxFilePath,\r\n        element.line + 1,\r\n        element.column + 1\r\n      );\r\n    } else {\r\n      options.loggingFunctions.logFileError(message, options.resxFilePath);\r\n    }\r\n  }\r\n\r\n  private static _logWarningWithLocation(\r\n    options: IResxReaderOptionsInternal,\r\n    message: string,\r\n    element?: XmlElement | XmlDocument\r\n  ): void {\r\n    if (element) {\r\n      options.loggingFunctions.logFileWarning(\r\n        message,\r\n        options.resxFilePath,\r\n        element.line + 1,\r\n        element.column + 1\r\n      );\r\n    } else {\r\n      options.loggingFunctions.logFileWarning(message, options.resxFilePath);\r\n    }\r\n  }\r\n\r\n  private static _logWithLocation(\r\n    loggingFn: (message: string) => void,\r\n    message: string,\r\n    filePath: string,\r\n    line?: number,\r\n    position?: number\r\n  ): void {\r\n    let location: string;\r\n    if (position !== undefined) {\r\n      location = `${filePath}(${line},${position})`;\r\n    } else if (line !== undefined) {\r\n      location = `${filePath}(${line})`;\r\n    } else {\r\n      location = filePath;\r\n    }\r\n\r\n    loggingFn(`${location}: ${message}`);\r\n  }\r\n}\r\n"]}