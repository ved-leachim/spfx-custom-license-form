{"version":3,"file":"StreamCollator.js","sourceRoot":"","sources":["../src/StreamCollator.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport { InternalError } from '@rushstack/node-core-library';\r\nimport { TerminalWritable, ITerminalChunk } from '@rushstack/terminal';\r\n\r\nimport { CollatedWriter } from './CollatedWriter';\r\nimport { CollatedTerminal } from './CollatedTerminal';\r\n\r\n/**\r\n * Constructor options for {@link StreamCollator}.\r\n *\r\n * @beta\r\n */\r\nexport interface IStreamCollatorOptions {\r\n  /**\r\n   * The target {@link @rushstack/terminal#TerminalWritable} object that the\r\n   * {@link StreamCollator} will write its output to.\r\n   */\r\n  destination: TerminalWritable;\r\n\r\n  /**\r\n   * An event handler that is called when a {@link CollatedWriter} becomes output,\r\n   * before any of its chunks have been written to the destination.\r\n   *\r\n   * @remarks\r\n   *\r\n   * Each `CollatedWriter` object will become active exactly once\r\n   * before the `StreamCollator` completes.\r\n   */\r\n  onWriterActive?: (writer: CollatedWriter) => void;\r\n}\r\n\r\n/**\r\n * A static class which manages the output of multiple threads.\r\n *\r\n * @beta\r\n */\r\nexport class StreamCollator {\r\n  private _taskNames: Set<string> = new Set();\r\n  private _writers: Set<CollatedWriter> = new Set();\r\n\r\n  // The writer whose output is being shown in realtime, or undefined if none\r\n  private _activeWriter: CollatedWriter | undefined = undefined;\r\n\r\n  // Writers that are not closed yet, and have never been active\r\n  private _openInactiveWriters: Set<CollatedWriter> = new Set();\r\n\r\n  // Writers that are now closed, but have accumulated buffered chunks, and have never been active\r\n  private _closedInactiveWriters: Set<CollatedWriter> = new Set();\r\n\r\n  private _onWriterActive: ((writer: CollatedWriter) => void) | undefined;\r\n\r\n  private _preventReentrantCall: boolean = false;\r\n\r\n  public readonly destination: TerminalWritable;\r\n  public readonly terminal: CollatedTerminal;\r\n\r\n  public constructor(options: IStreamCollatorOptions) {\r\n    this.destination = options.destination;\r\n    this.terminal = new CollatedTerminal(this.destination);\r\n    this._onWriterActive = options.onWriterActive;\r\n  }\r\n\r\n  /**\r\n   * Returns the currently active `CollatedWriter`, or `undefined` if no writer\r\n   * is active yet.\r\n   */\r\n  public get activeWriter(): CollatedWriter | undefined {\r\n    return this._activeWriter;\r\n  }\r\n\r\n  /**\r\n   * For diagnostic purposes, returns the {@link CollatedWriter.taskName} for the\r\n   * currently active writer, or an empty string if no writer is active.\r\n   */\r\n  public get activeTaskName(): string {\r\n    if (this._activeWriter) {\r\n      return this._activeWriter.taskName;\r\n    }\r\n    return '';\r\n  }\r\n\r\n  /**\r\n   * The list of writers that have been registered by calling {@link StreamCollator.registerTask},\r\n   * in the order that they were registered.\r\n   */\r\n  public get writers(): ReadonlySet<CollatedWriter> {\r\n    return this._writers;\r\n  }\r\n\r\n  /**\r\n   * Registers a new task to be collated, and constructs a {@link CollatedWriter} object\r\n   * to receive its input.\r\n   */\r\n  public registerTask(taskName: string): CollatedWriter {\r\n    if (this._taskNames.has(taskName)) {\r\n      throw new Error('A task with that name has already been registered');\r\n    }\r\n\r\n    const writer: CollatedWriter = new CollatedWriter(taskName, this);\r\n\r\n    this._writers.add(writer);\r\n    this._taskNames.add(writer.taskName);\r\n\r\n    // When a task is initially registered, it is open and has not accumulated any buffered chunks\r\n    this._openInactiveWriters.add(writer);\r\n\r\n    if (this._activeWriter === undefined) {\r\n      // If there is no active writer, then the first one to be registered becomes active.\r\n      this._assignActiveWriter(writer);\r\n    }\r\n\r\n    return writer;\r\n  }\r\n\r\n  /** @internal */\r\n  public _writerWriteChunk(\r\n    writer: CollatedWriter,\r\n    chunk: ITerminalChunk,\r\n    bufferedChunks: ITerminalChunk[]\r\n  ): void {\r\n    this._checkForReentrantCall();\r\n\r\n    if (this._activeWriter === undefined) {\r\n      // If no writer is currently active, then the first one to write something becomes active\r\n      this._assignActiveWriter(writer);\r\n    }\r\n\r\n    if (writer.isActive) {\r\n      this.destination.writeChunk(chunk);\r\n    } else {\r\n      bufferedChunks.push(chunk);\r\n    }\r\n  }\r\n\r\n  /** @internal */\r\n  public _writerClose(writer: CollatedWriter, bufferedChunks: ITerminalChunk[]): void {\r\n    this._checkForReentrantCall();\r\n\r\n    if (writer.isActive) {\r\n      writer._flushBufferedChunks();\r\n\r\n      this._activeWriter = undefined;\r\n\r\n      // If any buffered writers are already closed, activate them each immediately\r\n      // We copy the set, since _assignActiveWriter() will be deleting from it.\r\n      for (const closedInactiveWriter of [...this._closedInactiveWriters]) {\r\n        try {\r\n          this._assignActiveWriter(closedInactiveWriter);\r\n        } finally {\r\n          this._activeWriter = undefined;\r\n        }\r\n      }\r\n\r\n      let writerToActivate: CollatedWriter | undefined = undefined;\r\n\r\n      // Try to activate a writer that already accumulated some data\r\n      for (const openInactiveWriter of this._openInactiveWriters) {\r\n        if (openInactiveWriter.bufferedChunks.length > 0) {\r\n          writerToActivate = openInactiveWriter;\r\n          break;\r\n        }\r\n      }\r\n      if (!writerToActivate) {\r\n        // Otherwise just take the first one\r\n        for (const openInactiveWriter of this._openInactiveWriters) {\r\n          writerToActivate = openInactiveWriter;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (writerToActivate) {\r\n        this._assignActiveWriter(writerToActivate);\r\n      }\r\n    } else {\r\n      this._openInactiveWriters.delete(writer);\r\n      this._closedInactiveWriters.add(writer);\r\n    }\r\n  }\r\n\r\n  private _assignActiveWriter(writer: CollatedWriter): void {\r\n    this._activeWriter = writer;\r\n\r\n    this._closedInactiveWriters.delete(writer);\r\n    this._openInactiveWriters.delete(writer);\r\n\r\n    if (this._onWriterActive) {\r\n      this._preventReentrantCall = true;\r\n      try {\r\n        this._onWriterActive(writer);\r\n      } finally {\r\n        this._preventReentrantCall = false;\r\n      }\r\n    }\r\n\r\n    writer._flushBufferedChunks();\r\n  }\r\n\r\n  private _checkForReentrantCall(): void {\r\n    if (this._preventReentrantCall) {\r\n      throw new InternalError('Reentrant call to StreamCollator');\r\n    }\r\n  }\r\n}\r\n"]}