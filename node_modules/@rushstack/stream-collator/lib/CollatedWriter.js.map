{"version":3,"file":"CollatedWriter.js","sourceRoot":"","sources":["../src/CollatedWriter.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAE3D,kDAAuE;AAGvE,yDAAsD;AAEtD;;;;GAIG;AACH,MAAa,cAAe,SAAQ,2BAAgB;IAOlD,YAAmB,QAAgB,EAAE,QAAwB;QAC3D,KAAK,CAAC,EAAE,gBAAgB,EAAE,IAAI,EAAE,CAAC,CAAC;QAElC,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,QAAQ,GAAG,IAAI,mCAAgB,CAAC,IAAI,CAAC,CAAC;QAE3C,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;QAE1B,IAAI,CAAC,eAAe,GAAG,EAAE,CAAC;IAC5B,CAAC;IAED;;OAEG;IACH,IAAW,QAAQ;QACjB,OAAO,IAAI,CAAC,SAAS,CAAC,YAAY,KAAK,IAAI,CAAC;IAC9C,CAAC;IAED;;;OAGG;IACH,IAAW,cAAc;QACvB,OAAO,IAAI,CAAC,eAAe,CAAC;IAC9B,CAAC;IAED,sEAAsE;IAC/D,YAAY,CAAC,KAAqB;QACvC,IAAI,CAAC,SAAS,CAAC,iBAAiB,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC;IACtE,CAAC;IAED,iEAAiE;IAC1D,OAAO;QACZ,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,IAAI,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC;IAC1D,CAAC;IAED,gBAAgB;IACT,oBAAoB;QACzB,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,eAAe,EAAE;YACxC,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;SAC9C;QACD,IAAI,CAAC,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC;IAClC,CAAC;CACF;AAlDD,wCAkDC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport { ITerminalChunk, TerminalWritable } from '@rushstack/terminal';\r\n\r\nimport { StreamCollator } from './StreamCollator';\r\nimport { CollatedTerminal } from './CollatedTerminal';\r\n\r\n/**\r\n * An writable interface for managing output of simultaneous processes.\r\n *\r\n * @beta\r\n */\r\nexport class CollatedWriter extends TerminalWritable {\r\n  private readonly _collator: StreamCollator;\r\n  private readonly _bufferedChunks: ITerminalChunk[];\r\n\r\n  public readonly taskName: string;\r\n  public readonly terminal: CollatedTerminal;\r\n\r\n  public constructor(taskName: string, collator: StreamCollator) {\r\n    super({ preventAutoclose: true });\r\n\r\n    this.taskName = taskName;\r\n    this.terminal = new CollatedTerminal(this);\r\n\r\n    this._collator = collator;\r\n\r\n    this._bufferedChunks = [];\r\n  }\r\n\r\n  /**\r\n   * Returns true if this is the active writer for its associated {@link StreamCollator}.\r\n   */\r\n  public get isActive(): boolean {\r\n    return this._collator.activeWriter === this;\r\n  }\r\n\r\n  /**\r\n   * For diagnostic purposes, if the writer is buffering chunks because it has\r\n   * not become active yet, they can be inspected via this property.\r\n   */\r\n  public get bufferedChunks(): ReadonlyArray<ITerminalChunk> {\r\n    return this._bufferedChunks;\r\n  }\r\n\r\n  /** {@inheritDoc @rushstack/terminal#TerminalWritable.onWriteChunk} */\r\n  public onWriteChunk(chunk: ITerminalChunk): void {\r\n    this._collator._writerWriteChunk(this, chunk, this._bufferedChunks);\r\n  }\r\n\r\n  /** {@inheritDoc @rushstack/terminal#TerminalWritable.onClose} */\r\n  public onClose(): void {\r\n    this._collator._writerClose(this, this._bufferedChunks);\r\n  }\r\n\r\n  /** @internal */\r\n  public _flushBufferedChunks(): void {\r\n    for (const chunk of this._bufferedChunks) {\r\n      this._collator.destination.writeChunk(chunk);\r\n    }\r\n    this._bufferedChunks.length = 0;\r\n  }\r\n}\r\n"]}