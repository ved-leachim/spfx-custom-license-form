{"version":3,"file":"SplitterTransform.js","sourceRoot":"","sources":["../src/SplitterTransform.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAE3D,yDAAgF;AAehF;;;;;;;;;;;GAWG;AACH,MAAa,iBAAkB,SAAQ,mCAAgB;IAGrD,YAAmB,OAAkC;QACnD,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,YAAY,GAAG,CAAC,GAAG,OAAO,CAAC,YAAY,CAAC,CAAC;IAChD,CAAC;IAES,YAAY,CAAC,KAAqB;QAC1C,KAAK,MAAM,WAAW,IAAI,IAAI,CAAC,YAAY,EAAE;YAC3C,WAAW,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;SAC/B;IACH,CAAC;IAES,OAAO;QACf,MAAM,MAAM,GAAY,EAAE,CAAC;QAE3B,2FAA2F;QAC3F,KAAK,MAAM,WAAW,IAAI,IAAI,CAAC,YAAY,EAAE;YAC3C,IAAI,CAAC,WAAW,CAAC,gBAAgB,EAAE;gBACjC,IAAI;oBACF,WAAW,CAAC,KAAK,EAAE,CAAC;iBACrB;gBAAC,OAAO,KAAK,EAAE;oBACd,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;iBACpB;aACF;SACF;QAED,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;YACrB,MAAM,MAAM,CAAC,CAAC,CAAC,CAAC;SACjB;IACH,CAAC;CACF;AAhCD,8CAgCC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport { TerminalWritable, ITerminalWritableOptions } from './TerminalWritable';\r\nimport { ITerminalChunk } from './ITerminalChunk';\r\n\r\n/**\r\n * Constructor options for {@link SplitterTransform}.\r\n *\r\n * @public\r\n */\r\nexport interface ISplitterTransformOptions extends ITerminalWritableOptions {\r\n  /**\r\n   * Each input chunk will be passed to each destination in the array.\r\n   */\r\n  destinations: TerminalWritable[];\r\n}\r\n\r\n/**\r\n * Use this instead of {@link TerminalTransform} if you need to output `ITerminalChunk`\r\n * data to more than one destination.\r\n *\r\n * @remarks\r\n *\r\n * Splitting streams complicates the pipeline topology and can make debugging more difficult.\r\n * For this reason, it is modeled as an explicit `SplitterTransform` node, rather than\r\n * as a built-in feature of `TerminalTransform`.\r\n *\r\n * @public\r\n */\r\nexport class SplitterTransform extends TerminalWritable {\r\n  public readonly destinations: ReadonlyArray<TerminalWritable>;\r\n\r\n  public constructor(options: ISplitterTransformOptions) {\r\n    super();\r\n    this.destinations = [...options.destinations];\r\n  }\r\n\r\n  protected onWriteChunk(chunk: ITerminalChunk): void {\r\n    for (const destination of this.destinations) {\r\n      destination.writeChunk(chunk);\r\n    }\r\n  }\r\n\r\n  protected onClose(): void {\r\n    const errors: Error[] = [];\r\n\r\n    // If an exception is thrown, try to ensure that the other destinations get closed properly\r\n    for (const destination of this.destinations) {\r\n      if (!destination.preventAutoclose) {\r\n        try {\r\n          destination.close();\r\n        } catch (error) {\r\n          errors.push(error);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (errors.length > 0) {\r\n      throw errors[0];\r\n    }\r\n  }\r\n}\r\n"]}