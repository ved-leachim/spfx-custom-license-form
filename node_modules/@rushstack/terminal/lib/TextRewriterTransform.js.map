{"version":3,"file":"TextRewriterTransform.js","sourceRoot":"","sources":["../src/TextRewriterTransform.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport { NewlineKind } from '@rushstack/node-core-library';\r\n\r\nimport { ITerminalChunk, TerminalChunkKind } from './ITerminalChunk';\r\nimport { TerminalTransform, ITerminalTransformOptions } from './TerminalTransform';\r\nimport { TextRewriter, TextRewriterState } from './TextRewriter';\r\nimport { RemoveColorsTextRewriter } from './RemoveColorsTextRewriter';\r\nimport { NormalizeNewlinesTextRewriter } from './NormalizeNewlinesTextRewriter';\r\n\r\n/**\r\n * Constructor options for {@link TextRewriterTransform}.\r\n *\r\n * @public\r\n */\r\nexport interface ITextRewriterTransformOptions extends ITerminalTransformOptions {\r\n  /**\r\n   * A list of rewriters to be applied.  More items may be appended to the list, for example\r\n   * if {@link ITextRewriterTransformOptions.removeColors} is specified.\r\n   *\r\n   * @remarks\r\n   * The final list must contain at least one item.\r\n   */\r\n  textRewriters?: TextRewriter[];\r\n\r\n  /**\r\n   * If specified, a {@link RemoveColorsTextRewriter} will be appended to the list of rewriters.\r\n   */\r\n  removeColors?: boolean;\r\n\r\n  /**\r\n   * If `normalizeNewlines` or `ensureNewlineAtEnd` is specified, a {@link NormalizeNewlinesTextRewriter}\r\n   * will be appended to the list of rewriters with the specified settings.\r\n   *\r\n   * @remarks\r\n   * See {@link INormalizeNewlinesTextRewriterOptions} for details.\r\n   */\r\n  normalizeNewlines?: NewlineKind;\r\n\r\n  /**\r\n   * If `normalizeNewlines` or `ensureNewlineAtEnd` is specified, a {@link NormalizeNewlinesTextRewriter}\r\n   * will be appended to the list of rewriters with the specified settings.\r\n   *\r\n   * @remarks\r\n   * See {@link INormalizeNewlinesTextRewriterOptions} for details.\r\n   */\r\n  ensureNewlineAtEnd?: boolean;\r\n}\r\n\r\n/**\r\n * A {@link TerminalTransform} subclass that performs one or more {@link TextRewriter} operations.\r\n * The most common operations are {@link NormalizeNewlinesTextRewriter} and {@link RemoveColorsTextRewriter}.\r\n *\r\n * @remarks\r\n * The `TextRewriter` operations are applied separately to the `stderr` and `stdout` streams.\r\n * If multiple {@link ITextRewriterTransformOptions.textRewriters} are configured, they are applied\r\n * in the order that they appear in the array.\r\n *\r\n * @public\r\n */\r\nexport class TextRewriterTransform extends TerminalTransform {\r\n  private readonly _stderrStates: TextRewriterState[];\r\n  private readonly _stdoutStates: TextRewriterState[];\r\n\r\n  public readonly textRewriters: ReadonlyArray<TextRewriter>;\r\n\r\n  public constructor(options: ITextRewriterTransformOptions) {\r\n    super(options);\r\n\r\n    const textRewriters: TextRewriter[] = options.textRewriters || [];\r\n\r\n    if (options.removeColors) {\r\n      textRewriters.push(new RemoveColorsTextRewriter());\r\n    }\r\n    if (options.normalizeNewlines) {\r\n      textRewriters.push(\r\n        new NormalizeNewlinesTextRewriter({\r\n          newlineKind: options.normalizeNewlines,\r\n          ensureNewlineAtEnd: options.ensureNewlineAtEnd\r\n        })\r\n      );\r\n    }\r\n\r\n    if (textRewriters.length === 0) {\r\n      throw new Error('TextRewriterTransform requires at least one matcher');\r\n    }\r\n\r\n    this.textRewriters = textRewriters;\r\n\r\n    this._stderrStates = this.textRewriters.map((x) => x.initialize());\r\n    this._stdoutStates = this.textRewriters.map((x) => x.initialize());\r\n  }\r\n\r\n  protected onWriteChunk(chunk: ITerminalChunk): void {\r\n    if (chunk.kind === TerminalChunkKind.Stderr) {\r\n      this._processText(chunk, this._stderrStates);\r\n    } else if (chunk.kind === TerminalChunkKind.Stdout) {\r\n      this._processText(chunk, this._stdoutStates);\r\n    } else {\r\n      this.destination.writeChunk(chunk);\r\n    }\r\n  }\r\n\r\n  private _processText(chunk: ITerminalChunk, states: TextRewriterState[]): void {\r\n    let text: string = chunk.text;\r\n    for (let i: number = 0; i < states.length; ++i) {\r\n      if (text.length > 0) {\r\n        text = this.textRewriters[i].process(states[i], text);\r\n      }\r\n    }\r\n    if (text.length > 0) {\r\n      // If possible, avoid allocating a new chunk\r\n      if (text === chunk.text) {\r\n        this.destination.writeChunk(chunk);\r\n      } else {\r\n        this.destination.writeChunk({\r\n          text: text,\r\n          kind: chunk.kind\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  private _closeRewriters(states: TextRewriterState[], chunkKind: TerminalChunkKind): void {\r\n    let text: string = '';\r\n    for (let i: number = 0; i < states.length; ++i) {\r\n      if (text.length > 0) {\r\n        text = this.textRewriters[i].process(states[i], text);\r\n      }\r\n      text += this.textRewriters[i].close(states[i]);\r\n    }\r\n    if (text.length > 0) {\r\n      this.destination.writeChunk({\r\n        text: text,\r\n        kind: chunkKind\r\n      });\r\n    }\r\n  }\r\n\r\n  protected onClose(): void {\r\n    this._closeRewriters(this._stderrStates, TerminalChunkKind.Stderr);\r\n    this._closeRewriters(this._stderrStates, TerminalChunkKind.Stdout);\r\n\r\n    this.autocloseDestination();\r\n  }\r\n}\r\n"]}