{"version":3,"file":"TextRewriter.js","sourceRoot":"","sources":["../src/TextRewriter.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AA6B3D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA6BG;AACH,MAAsB,YAAY;CAejC;AAfD,oCAeC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport { Brand } from '@rushstack/node-core-library';\r\n\r\n/**\r\n * Represents the internal state of a {@link TextRewriter} subclass.\r\n *\r\n * @remarks\r\n * For example, suppose that {@link NormalizeNewlinesTextRewriter} will be used to rewrite\r\n * the input `\"line 1\\r\\nline 2\\r\\n\"` to become `\"line 1\\nline 2\\n\"`.  But suppose that the `\"\\r\\n\"`\r\n * pair is split across two chunks:\r\n *\r\n * ```ts\r\n * const rewriter: NormalizeNewlinesTextRewriter = new NormalizeNewlinesTextRewriter(NewlineKind.Lf);\r\n * const state: TextRewriterState = rewriter.initialize();\r\n * let output: string = rewriter.process(state, 'line 1\\r');\r\n * output += rewriter.process(state, '\\nline 2\\r\\n');\r\n * output += rewriter.close(state);\r\n *\r\n * // The final \"output\" value is: \"line 1\\nline 2\\n\"\r\n * ```\r\n *\r\n * The `TextRewriterState` keeps track of this context, so that split `\"\\r\"` and `\"\\n\"` are\r\n * interpreted as a single newline.\r\n *\r\n * @public\r\n */\r\nexport type TextRewriterState = Brand<unknown, 'TextRewriterState'>;\r\n\r\n/**\r\n * The abstract base class for operations that can be applied by {@link TextRewriterTransform}.\r\n *\r\n * @remarks\r\n * The {@link TextRewriterTransform} applies one or more character rewriting operations to its\r\n * chunk stream.  Since these operations are applied separately to `stderr` and `stdout`, the\r\n * state is stored in an opaque `TextRewriterState` object.\r\n *\r\n * Conceptually, a `TextRewriter` subclass is very similar to a regular expression, with the difference\r\n * that `RegExp` operates on a text string, whereas `TextRewriter` operates on a stream of characters.\r\n *\r\n * The two most common subclasses are {@link NormalizeNewlinesTextRewriter} and {@link RemoveColorsTextRewriter}.\r\n *\r\n * A rewriting operation starts with `initialize()`, followed by any number of `process()` calls, and\r\n * then finishes with `close()`.  For example:\r\n *\r\n * ```ts\r\n * const rewriter: NormalizeNewlinesTextRewriter = new NormalizeNewlinesTextRewriter(NewlineKind.Lf);\r\n * const state: TextRewriterState = rewriter.initialize();\r\n * let output: string = rewriter.process(state, 'line 1\\r');\r\n * output += rewriter.process(state, '\\nline 2\\r\\n');\r\n * output += rewriter.close(state);\r\n *\r\n * // The final \"output\" value is: \"line 1\\nline 2\\n\"\r\n * ```\r\n *\r\n * After `close()` has been called, the `TextRewriterState` state should not be reused.\r\n *\r\n * @public\r\n */\r\nexport abstract class TextRewriter {\r\n  /**\r\n   * Create a new `TextRewriterState` object that can be used to process a stream of characters.\r\n   */\r\n  public abstract initialize(): TextRewriterState;\r\n\r\n  /**\r\n   * Rewrite the next sequence of characters from the input stream, returning the modified output.\r\n   */\r\n  public abstract process(state: TextRewriterState, input: string): string;\r\n\r\n  /**\r\n   * Close the `TextRewriterState` object and return any buffered output.\r\n   */\r\n  public abstract close(state: TextRewriterState): string;\r\n}\r\n"]}