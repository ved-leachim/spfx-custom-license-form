{"version":3,"file":"TerminalWritable.js","sourceRoot":"","sources":["../src/TerminalWritable.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAwB3D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAiDG;AACH,MAAsB,gBAAgB;IAKpC,YAAmB,OAAkC;QACnD,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;QAEpB,IAAI,CAAC,OAAO,EAAE;YACZ,OAAO,GAAG,EAAE,CAAC;SACd;QAED,IAAI,CAAC,gBAAgB,GAAG,CAAC,CAAC,OAAO,CAAC,gBAAgB,CAAC;IACrD,CAAC;IAED;;;;OAIG;IACH,IAAW,MAAM;QACf,OAAO,IAAI,CAAC,OAAO,CAAC;IACtB,CAAC;IAED;;;;;;;;;;;;OAYG;IACI,UAAU,CAAC,KAAqB;QACrC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;YACjB,MAAM,IAAI,KAAK,CAAC,2BAA2B,CAAC,CAAC;SAC9C;QACD,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;IAC3B,CAAC;IAOD;;;;;;;;;;;;OAYG;IACI,KAAK;QACV,IAAI,IAAI,CAAC,OAAO,EAAE;YAChB,IAAI,CAAC,OAAO,EAAE,CAAC;YACf,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;SACtB;IACH,CAAC;IAED;;;;;;;;;OASG;IACO,OAAO,KAAU,CAAC;CAC7B;AAhFD,4CAgFC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport { ITerminalChunk } from './ITerminalChunk';\r\n\r\n/**\r\n * Constructor options for {@link TerminalWritable}\r\n *\r\n * @public\r\n */\r\nexport interface ITerminalWritableOptions {\r\n  /**\r\n   * When this object is the {@link TerminalTransform.destination} for a transform,\r\n   * the transform will automatically close this object.  Set `preventAutoclose` to `true`\r\n   * to prevent that behavior.\r\n   *\r\n   * @remarks\r\n   * When a transform is closed, normally it will automatically close its destination\r\n   * `TerminalWritable` object.  There are two ways to prevent that: either by setting\r\n   * `preventDestinationAutoclose` to `true` for the transform, or by setting\r\n   * {@link TerminalWritable.preventAutoclose} to `true` for the `destination` object.\r\n   */\r\n  preventAutoclose?: boolean;\r\n}\r\n\r\n/**\r\n * The abstract base class for objects that can present, route, or process text output for\r\n * a console application.  This output is typically prepared using\r\n * the {@link @rushstack/node-core-library#Terminal} API.\r\n *\r\n * @remarks\r\n *\r\n * The design is based loosely on the `WritableStream` and `TransformStream` classes from\r\n * the system {@link https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Concepts\r\n * | Streams API}, except that instead of asynchronous byte streams, the `TerminalWritable`\r\n * system synchronously transmits human readable messages intended to be rendered on a text\r\n * console or log file.\r\n *\r\n * Consider a console application whose output may need to be processed in different ways\r\n * before finally being output.  The conceptual block diagram might look like this:\r\n *\r\n * ```\r\n *          [Terminal API]\r\n *                 |\r\n *                 V\r\n *        [normalize newlines]\r\n *                 |\r\n *                 V\r\n *       +----[splitter]-------+\r\n *       |                     |\r\n *       V                     V\r\n *   [shell console]     [remove ANSI colors]\r\n *                             |\r\n *                             V\r\n *                       [write to build.log]\r\n * ```\r\n *\r\n * The application uses the `Terminal` API to print `stdout` and `stderr` messages, for example with standardized\r\n * formatting for errors and warnings, and ANSI escapes to make nice colors.  Maybe it also includes text\r\n * received from external processes, whose newlines may be inconsistent.  Ultimately we want to write the\r\n * output to the shell console and a `build.log` file, but we don't want to put ANSI colors in the build log.\r\n *\r\n * For the above example, `[shell console]` and `[write to build.log]` would be modeled as subclasses of\r\n * `TerminalWritable`.  The `[normalize newlines]` and `[remove ANSI colors]` steps are modeled as subclasses\r\n * of {@link TerminalTransform}, because they output to a \"destination\" object.  The `[splitter]` would be\r\n * implemented using {@link SplitterTransform}.\r\n *\r\n * The stream of messages are {@link ITerminalChunk} objects, which can represent both `stdout` and `stderr`\r\n * channels.  The pipeline operates synchronously on each chunk, but by processing one chunk at a time,\r\n * it avoids storing the entire output in memory.  This means that operations like `[remove ANSI colors]`\r\n * cannot be simple regular expressions -- they must be implemented as state machines ({@link TextRewriter}\r\n * subclasses) capable of matching substrings that span multiple chunks.\r\n *\r\n * @public\r\n */\r\nexport abstract class TerminalWritable {\r\n  private _isOpen: boolean;\r\n\r\n  public readonly preventAutoclose: boolean;\r\n\r\n  public constructor(options?: ITerminalWritableOptions) {\r\n    this._isOpen = true;\r\n\r\n    if (!options) {\r\n      options = {};\r\n    }\r\n\r\n    this.preventAutoclose = !!options.preventAutoclose;\r\n  }\r\n\r\n  /**\r\n   * This property is initially `true` when the object is constructed, and becomes `false`\r\n   * when `close()` is called.\r\n   * @sealed\r\n   */\r\n  public get isOpen(): boolean {\r\n    return this._isOpen;\r\n  }\r\n\r\n  /**\r\n   * Upstream objects call this method to provide inputs to this object.\r\n   *\r\n   * @remarks\r\n   * The subclass provides its implementation via the the {@link TerminalWritable.onWriteChunk}\r\n   * method, which is called by `writeChunk()`.\r\n   *\r\n   * The object that calls `writeChunk()` must call `close()` when it is finished;\r\n   * failing to do so may introduce a resource leak, or may prevent some buffered data from\r\n   * being written.\r\n   *\r\n   * @sealed\r\n   */\r\n  public writeChunk(chunk: ITerminalChunk): void {\r\n    if (!this._isOpen) {\r\n      throw new Error('Writer was already closed');\r\n    }\r\n    this.onWriteChunk(chunk);\r\n  }\r\n\r\n  /**\r\n   * Subclasses should implement this `abstract` method to process the chunk.\r\n   */\r\n  protected abstract onWriteChunk(chunk: ITerminalChunk): void;\r\n\r\n  /**\r\n   * Calling this method flushes any remaining outputs and permanently transitions the\r\n   * `TerminalWritable` to a \"closed\" state, where no further chunks can be written.\r\n   *\r\n   * @remarks\r\n   * The subclass provides its implementation via the the {@link TerminalWritable.onClose}\r\n   * method, which is called by `close()`.\r\n   *\r\n   * If this method is called more than once, the additional calls are ignored;\r\n   * `TerminalWritable.onClose` will be called at most once.\r\n   *\r\n   * @sealed\r\n   */\r\n  public close(): void {\r\n    if (this._isOpen) {\r\n      this.onClose();\r\n      this._isOpen = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Subclasses can override this empty method to perform additional operations\r\n   * such as closing a file handle.\r\n   *\r\n   * @remarks\r\n   * It is guaranteed that this method will be called at most once during the lifetime\r\n   * of a `TerminalWritable` object.\r\n   *\r\n   * @virtual\r\n   */\r\n  protected onClose(): void {}\r\n}\r\n"]}