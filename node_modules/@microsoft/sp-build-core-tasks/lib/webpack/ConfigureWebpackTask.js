"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigureWebpackTask = exports.FILE_LOADER_EXTENSIONS = void 0;
const path = __importStar(require("path"));
const spfx_heft_plugins_1 = require("@microsoft/spfx-heft-plugins");
const node_core_library_1 = require("@rushstack/node-core-library");
const OdspGulpTask_1 = require("../OdspGulpTask");
const GulpTaskTerminalProvider_1 = require("../utilities/GulpTaskTerminalProvider");
const LegacyExternals_1 = require("./LegacyExternals");
exports.FILE_LOADER_EXTENSIONS = ['jpg', 'png', 'woff', 'eot', 'ttf', 'svg', 'gif', 'dds'];
/**
 * Configures the @microsoft/gulp-core-build-webpack task with some smart defaults based on the package configuration.
 */
class ConfigureWebpackTask extends OdspGulpTask_1.OdspGulpTask {
    constructor() {
        super('configure-webpack', {
            libraryName: undefined,
            webpack: undefined,
            additionalConfiguration: undefined
        });
    }
    loadSchema() {
        return node_core_library_1.JsonFile.load(path.join(__dirname, 'configure-webpack.schema.json'));
    }
    setConfig(config) {
        if (config.webpack && config.webpack.name !== 'webpack') {
            this.logWarning('Setting webpack property to non-"@microsoft/gulp-core-build-webpack"-type will ' +
                'prevent configuration');
        }
        super.mergeConfig(config);
    }
    async executeTask() {
        if (!this.taskConfig.webpack) {
            this.logWarning('"webpack" is not defined in the task configuration. Nothing to configure.');
            return;
        }
        let legacyExternals;
        if (this.taskConfig.useLegacyExternals) {
            legacyExternals = new LegacyExternals_1.LegacyExternals({
                gulpTask: this,
                singleLocale: this.taskConfig.singleLocale,
                configJson: this.properties.configJson,
                buildFolder: this.buildConfig.rootPath,
                serveMode: !!this.properties.serveMode
            });
        }
        const terminal = new node_core_library_1.Terminal(new GulpTaskTerminalProvider_1.GulpTaskTerminalProvider(this));
        let config = await spfx_heft_plugins_1.WebpackConfigurationGenerator.generateWebpackConfigurationAsync({
            configJson: this.properties.configJson,
            folders: {
                buildFolder: this.buildConfig.rootPath,
                tempFolder: path.join(this.buildConfig.rootPath, 'temp'),
                releaseFolder: path.join(this.buildConfig.rootPath, 'release'),
                outputFolder: path.join(this.buildConfig.rootPath, 'dist')
            },
            terminal,
            production: this.buildConfig.production,
            serveMode: !!this.properties.serveMode,
            projectPackageJson: node_core_library_1.PackageJsonLookup.instance.tryLoadPackageJsonFor(this.buildConfig.rootPath),
            localization: this.taskConfig.getLocalization ? this.taskConfig.getLocalization() : undefined,
            singleLocale: this.taskConfig.singleLocale,
            linkedExternalsToBundle: this.taskConfig.linkedExternalsToBundle,
            libraryName: this.taskConfig.libraryName,
            libraryTarget: this.taskConfig.libraryTarget,
            disableAsyncComponentLoading: this.taskConfig.disableAsyncComponentLoading,
            assetsAreVersioned: this.taskConfig.assetsAreVersioned
        });
        if (config) {
            this.taskConfig.webpack.isEnabled = () => true;
            legacyExternals === null || legacyExternals === void 0 ? void 0 : legacyExternals.updateWebpackConfiguration(config);
            if (this.taskConfig.additionalConfiguration) {
                config = this.taskConfig.additionalConfiguration(config);
            }
        }
        else {
            this.taskConfig.webpack.isEnabled = () => false;
        }
        this._setWebpackConfig(config);
    }
    _setWebpackConfig(config) {
        const webpackTask = this.taskConfig.webpack;
        const sourceMapWarningSuppression = /Cannot find SourceMap \'.+\'\: Error\:/;
        // Disable Performance hints.
        const performanceHintSuppression = /(asset|entrypoint) size limit.*/;
        const performanceRecommendationSuppression = /webpack performance recommendations.*/;
        const suppressedWarnings = webpackTask.taskConfig.suppressWarnings || [];
        if (webpackTask) {
            webpackTask.setConfig({
                config: config,
                configPath: null,
                suppressWarnings: suppressedWarnings.concat([
                    sourceMapWarningSuppression,
                    performanceHintSuppression,
                    performanceRecommendationSuppression
                ])
            });
        }
    }
}
exports.ConfigureWebpackTask = ConfigureWebpackTask;
//# sourceMappingURL=ConfigureWebpackTask.js.map