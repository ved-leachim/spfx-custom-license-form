"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PackageSolutionTask = void 0;
const colors_1 = __importDefault(require("colors"));
const glob = __importStar(require("glob"));
const path = __importStar(require("path"));
const through2 = __importStar(require("through2"));
const node_core_library_1 = require("@rushstack/node-core-library");
const createPackage_1 = __importDefault(require("./packageSolution/createPackage"));
// import {
//   default as ManifestValidator,
//   IManifestValidatorResult
// } from '@microsoft/sp-module-interfaces/lib/manifestSchemaValidator';
const OdspGulpTask_1 = require("../OdspGulpTask");
class PackageSolutionTask extends OdspGulpTask_1.OdspGulpTask {
    constructor() {
        super('package-solution', {
            paths: {
                packageDir: 'sharepoint',
                debugDir: path.join('solution', 'debug'),
                zippedPackage: path.join('solution', 'ClientSolution.sppkg'),
                featureXmlDir: 'feature_xml',
                sharepointAssetDir: 'assets',
                teamsDir: 'teams'
            },
            contentTypes: {
                xml: 'text/xml',
                rels: 'application/vnd.openxmlformats-package.relationships+xml',
                webpart: 'text/xml',
                htm: 'text/html',
                html: 'text/html',
                aspx: 'text/xml',
                resx: 'text/xml',
                js: 'application/javascript',
                json: 'application/json',
                png: 'image/png',
                jpg: 'image/jpeg',
                bmp: 'image/bmp',
                gif: 'image/gif'
            },
            solution: {
                name: 'A Sample Solution',
                id: '00000000-0000-0000-0000-000000000000'
            }
        });
        this._hasPrependedPaths = false;
    }
    loadSchema() {
        return node_core_library_1.JsonFile.load(path.join(__dirname, 'package-solution.schema.json'));
    }
    executeTask(gulp) {
        // We have a few warnings in this task that should not fail the build, regardless of whether we are in
        // ship mode or not.
        this.buildConfig.shouldWarningsFailBuild = false;
        const writeManifestConfig = node_core_library_1.JsonFile.load(path.join(this.buildConfig.rootPath, 'config', 'write-manifests.json'));
        const cdnBasePath = writeManifestConfig.cdnBasePath;
        const defaultCdnPath = '<!-- PATH TO CDN -->';
        if (this.taskConfig.solution.includeClientSideAssets && cdnBasePath !== defaultCdnPath) {
            // check the write-manifests task and see if the cdnBasePath has been changed
            this.logWarning(colors_1.default.yellow(`The "cdnBasePath" in "config/write-manifests.json" has been changed from its` +
                ` default value ("${defaultCdnPath}") to "${cdnBasePath}",` +
                ` however the "includeClientSideAssets" setting` +
                ` in "config/package-solution.json" is "true" and will be ignored.` +
                ` If you meant to deploy your assets in your SPPKG to SharePoint,` +
                ` reset the value of "cdnBasePath" to "${defaultCdnPath}".`));
            this.taskConfig.solution.includeClientSideAssets = false;
        }
        if (this.taskConfig.solution.includeClientSideAssets && !this.buildConfig.production) {
            this.logWarning(colors_1.default.yellow(`This is not a production build (--ship or --production),` +
                ` therefore the "includeClientSideAssets" setting will be ignored.`));
            this.taskConfig.solution.includeClientSideAssets = false;
        }
        this._prependBaseToConfigPaths();
        const ignoredAssets = ['**/*.map'];
        let assetsFolderPath;
        let manifestsFolderPath;
        if (this.buildConfig.production) {
            manifestsFolderPath = path.join(this.releasePath, 'manifests');
            assetsFolderPath = path.join(this.releasePath, 'assets');
        }
        else {
            manifestsFolderPath = assetsFolderPath = path.join(this.buildConfig.rootPath, 'dist');
        }
        const manifestMap = new Map();
        let foundAnyManifests = false;
        return gulp
            .src('*.json', {
            cwd: manifestsFolderPath
        })
            .pipe(through2.obj((file, enc, callback) => {
            foundAnyManifests = true;
            const manifest = JSON.parse(file.contents.toString(enc));
            this.log(`Found manifest: ${file.path}`);
            ignoredAssets.push(path.relative(manifestsFolderPath, file.path));
            manifestMap.set(manifest.id, manifest);
            callback();
        }, (callback) => {
            if (!manifestMap.size) {
                if (foundAnyManifests) {
                    callback(new Error(`Some manifests were found in '${manifestsFolderPath}', but were not valid. `));
                }
                else {
                    callback(new Error(`No manifests were found in '${manifestsFolderPath}'. ` +
                        'Ensure a build has completed successfully'));
                }
            }
            // read in all the assets, if necessary
            if (this.taskConfig.solution.includeClientSideAssets) {
                this.taskConfig.solution.clientSideAssets = glob
                    .sync('**/*.*', {
                    ignore: ignoredAssets,
                    cwd: assetsFolderPath
                })
                    .map((filename) => {
                    this.log(colors_1.default.cyan(`Found client-side build resource: ${filename}`));
                    return {
                        originalFilename: path.join(assetsFolderPath, filename),
                        packageFilename: filename
                    };
                });
            }
            // Always copy everything from the teams folder
            const teamsIcons = glob
                .sync('**/*.*', {
                ignore: ignoredAssets,
                cwd: this.taskConfig.paths.teamsDir
            })
                .map((filename) => {
                this.log(colors_1.default.cyan(`Found teams icons: ${filename}`));
                return {
                    originalFilename: path.join(this.taskConfig.paths.teamsDir, filename),
                    packageFilename: filename
                };
            });
            if (this.taskConfig.solution.clientSideAssets !== undefined) {
                this.taskConfig.solution.clientSideAssets = this.taskConfig.solution.clientSideAssets.concat(teamsIcons);
            }
            else {
                this.taskConfig.solution.clientSideAssets = teamsIcons;
            }
            createPackage_1.default(this.taskConfig, manifestMap).then(callback, callback);
        }));
    }
    getCleanMatch(buildConfig) {
        this.buildConfig = buildConfig;
        this._prependBaseToConfigPaths();
        return [this.taskConfig.paths.debugDir, this.taskConfig.paths.zippedPackage];
    }
    _prependBaseToConfigPaths() {
        if (!this._hasPrependedPaths) {
            this.taskConfig.paths.debugDir = path.join(this.taskConfig.paths.packageDir, this.taskConfig.paths.debugDir);
            this.taskConfig.paths.zippedPackage = path.join(this.taskConfig.paths.packageDir, this.taskConfig.paths.zippedPackage);
            this.taskConfig.paths.featureXmlDir = path.join(this.taskConfig.paths.packageDir, this.taskConfig.paths.featureXmlDir);
            this.taskConfig.paths.sharepointAssetDir = path.join(this.taskConfig.paths.packageDir, this.taskConfig.paths.sharepointAssetDir);
            this._hasPrependedPaths = true;
        }
    }
}
exports.PackageSolutionTask = PackageSolutionTask;
//# sourceMappingURL=PackageSolutionTask.js.map