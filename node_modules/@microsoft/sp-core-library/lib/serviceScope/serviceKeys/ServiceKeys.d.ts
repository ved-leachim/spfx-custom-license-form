/**
 * @Copyright (c) Microsoft Corporation.  All rights reserved.
 */
import ServiceKey from '../ServiceKey';
import { IDynamicDataParentIframeCommunicator } from '../../common/interfaces/IDynamicDataParentIframeCommunicator';
/**
 * Centralized list of service keys used.
 * Maintaining all the service keys here, would make consumption of services
 * free of any cyclic dependencies.
 *
 * @internal
 */
export declare class ServiceKeys {
    /**
     * A unique ServiceKey to identify the ParentIframeCommunicator as a service in the ServiceScope.
     *
     * @remarks
     * This is a slightly special case where we can't provide a default implementation because it depends
     * on a context which only exists in the isolated web part scenario. Hence, consuming this service key
     * in non-isolated scenarios will throw the below error.
     */
    static readonly parentIFrameCommunicatorServiceKey: ServiceKey<IDynamicDataParentIframeCommunicator>;
    /**
     * A unique ServiceKey to identify the IDynamicDataManager as a service in the ServiceScope.
     *
     * @remarks
     * It is a special case where the same is key is used to register two different services i.e.,
     * DynamicDataManager and IsolatedDynamicDataManager. When in isolated application IsolatedDynamicDataManager
     * is provided to the root service scope, in all the other cases DynamicDataManager is provided.
     *
     * Using the same service key for both the services, will ensure that consumers need not worry about which
     * manager they get. Hence, the key is in common place.
     */
    static readonly iDynamicDataManagerServiceKey: ServiceKey<unknown>;
}
//# sourceMappingURL=ServiceKeys.d.ts.map