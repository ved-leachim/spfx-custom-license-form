import { _LogSource, _logSourceServiceKey, _QosMonitor } from '@microsoft/sp-diagnostics';
import { ServiceKey, Validate, _ClientManifestData } from '@microsoft/sp-core-library';
import OAuthTokenProvider from '../oauthTokenProvider/OAuthTokenProvider';
import { fetchProviderServiceKey } from '../httpClient/FetchProvider';
import GraphHttpClientResponse from './GraphHttpClientResponse';
import HttpClientHelper from '../httpClient/HttpClientHelper';
import SPHttpClientHelper from '../spHttpClient/SPHttpClientHelper';
import { predefinedConfigurations } from './GraphHttpClientConfiguration';
import GraphHttpClientContext from './GraphHttpClientContext';
import { CacheManager } from '../caching/CacheManager';
import { getCacheDataProviderServiceKey } from '../caching/CacheDataProviderService';
/**
 * GraphHttpClient is used to perform REST calls against Microsoft Graph. It adds default
 * headers and collects telemetry that helps the service to monitor the performance of an application.
 * https://developer.microsoft.com/en-us/graph/
 *
 * @remarks
 * For communicating with SharePoint, use the {@link SPHttpClient} class instead.
 * For communicating with other internet services, use the {@link HttpClient} class instead.
 *
 * @internal
 * @deprecated The GraphHttpClient class has been superseded by the MSGraphClient class.
 * @sealed
 */
var GraphHttpClient = /** @class */ (function () {
    function GraphHttpClient(serviceScope) {
        var _this = this;
        this._serviceScope = serviceScope;
        this._serviceScope.whenFinished(function () {
            _this._tokenProvider = serviceScope.consume(OAuthTokenProvider.serviceKey);
            _this._parentSource = serviceScope.consume(_logSourceServiceKey);
            _this._graphContext = serviceScope.consume(GraphHttpClientContext.serviceKey);
            _this._fetchProvider = serviceScope.consume(fetchProviderServiceKey);
            _this._clientManifestData = _this._serviceScope.consume(_ClientManifestData.serviceKey);
        });
    }
    GraphHttpClient.prototype.fetch = function (url, configuration, options, cacheConfiguration) {
        var _this = this;
        // Default fetch behavior - No caching
        // If no caching options are provided, or If Cache Provider is not present continue to API call
        if (!cacheConfiguration || !this._cacheDataProvider) {
            return this._fetch(url, configuration, options);
        }
        // Get the cache Key
        // tslint:disable-next-line:no-any
        var cacheKey = this._cacheDataProvider.getCacheKey(url, configuration, options);
        // Fetch data and Cache according to the cacheConfiguration
        return CacheManager.fetchAndCache(cacheKey, this._cacheDataProvider, cacheConfiguration, function () { return _this._fetch(url, configuration, options); });
    };
    GraphHttpClient.prototype.get = function (url, configuration, options, cacheConfiguration) {
        if (cacheConfiguration) {
            return this.fetch(url, configuration, HttpClientHelper.overrideHttpMethod(options, 'GET'), cacheConfiguration);
        }
        else {
            return this.fetch(url, configuration, HttpClientHelper.overrideHttpMethod(options, 'GET'));
        }
    };
    /**
     * Calls fetch(), but sets the method to "POST".
     * @param url - the URL to fetch
     * @param configuration - determines the default behavior of GraphHttpClient; normally this should
     *   be the latest version number from GraphHttpClientConfigurations
     * @param options - additional options that affect the request
     * @returns a promise that will return the result
     */
    GraphHttpClient.prototype.post = function (url, configuration, options) {
        return this._fetch(url, configuration, HttpClientHelper.overrideHttpMethod(options, 'POST'));
    };
    GraphHttpClient.prototype._fetch = function (url, configuration, options) {
        var _this = this;
        this._validateGraphRelativeUrl(url);
        return this._getOAuthToken().then(function () {
            if (!options) {
                options = {};
            }
            var modifiedOptions = Object.assign({}, options);
            var defaultHeaders = new Headers();
            defaultHeaders.append('Accept', 'application/json');
            defaultHeaders.append('Authorization', 'Bearer ' + _this._token);
            defaultHeaders.append('Content-Type', 'application/json; charset=utf-8');
            var userHeaders = SPHttpClientHelper.cloneHeaders(options);
            modifiedOptions.headers = _this._mergeUserHeaders(defaultHeaders, userHeaders);
            return _this._fetchWithInstrumentation(configuration, new Request(_this._graphContext.getGraphEndpointUrl() + '/' + url, modifiedOptions)).then(function (response) {
                return new GraphHttpClientResponse(response);
            });
        });
    };
    GraphHttpClient.prototype._fetchWithInstrumentation = function (configuration, request) {
        return HttpClientHelper.fetchCore(configuration, request, this._serviceScope, this._fetchProvider, GraphHttpClient._className)
            .then(function (response) {
            return response;
        })
            .catch(function (error) {
            return Promise.reject(error);
        });
    };
    GraphHttpClient.prototype._getOAuthToken = function () {
        var _this = this;
        var qosMonitor = new _QosMonitor('GraphHttpClient.FetchGraphToken');
        if (this._clientManifestData.manifest) {
            qosMonitor.extraData = {
                alias: this._clientManifestData.manifest.alias,
                componentId: this._clientManifestData.manifest.id
            };
        }
        // VSO 331685 SharePoint/Graph should tell the GraphHttpClient where to fetch the Graph token from
        return this._tokenProvider
            .getOAuthToken(this._graphContext.getGraphEndpointUrl(), this._graphContext.getWebServerRelativeUrl())
            .then(function (response) {
            _this._writeQosMonitorUpdate(response, qosMonitor, 'FetchGraphToken');
            _this._token = response.token;
        })
            .catch(function (error) {
            qosMonitor.writeUnexpectedFailure('FetchGraphToken', error, { source: _this._logSourceId });
            return Promise.reject(error);
        });
    };
    Object.defineProperty(GraphHttpClient.prototype, "_cacheDataProvider", {
        /**
         * Gets the cache data provider
         */
        // tslint:disable-next-line:no-any
        get: function () {
            if (!this._cacheProvider) {
                this._cacheProvider = this._serviceScope.consume(getCacheDataProviderServiceKey())._provider;
            }
            return this._cacheProvider;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GraphHttpClient.prototype, "_logSourceId", {
        get: function () {
            if (this._parentSource.isEmpty()) {
                return GraphHttpClient._logSource.id;
            }
            return this._parentSource.id;
        },
        enumerable: false,
        configurable: true
    });
    GraphHttpClient.prototype._mergeUserHeaders = function (defaultHeaders, userHeaders) {
        userHeaders.forEach(function (value, name) {
            defaultHeaders.set(name, value); // note name/value are reversed
        });
        return defaultHeaders;
    };
    GraphHttpClient.prototype._writeQosMonitorUpdate = function (response, qosMonitor, operation) {
        if (response.status >= 200 && response.status <= 299) {
            qosMonitor.writeSuccess({ source: this._logSourceId });
        }
        else if (response.status >= 300 && response.status <= 499) {
            qosMonitor.writeExpectedFailure(operation, undefined, {
                source: this._logSourceId,
                responseStatus: response.status
            });
        }
        else {
            qosMonitor.writeUnexpectedFailure(operation, undefined, {
                source: this._logSourceId,
                responseStatus: response.status
            });
        }
    };
    /**
     * This function verifies that
     */
    GraphHttpClient.prototype._validateGraphRelativeUrl = function (url) {
        Validate.isNotNullOrUndefined(url, 'url');
        if (url.charAt(0) === '/') {
            throw new Error('GraphHttpClient requests cannot begin with a / character');
        }
        if (url.indexOf('http://', 0) === 0) {
            throw new Error('GraphHttpClient requests cannot specify a different graph server with the url.');
        }
        if (url.indexOf('https://', 0) === 0) {
            throw new Error('GraphHttpClient requests cannot specify a different graph server with the url.');
        }
    };
    /**
     * The standard predefined GraphHttpClientConfiguration objects for use with
     * the GraphHttpClient class.
     */
    GraphHttpClient.configurations = predefinedConfigurations;
    /**
     * The service key for GraphHttpClient.
     */
    GraphHttpClient.serviceKey = ServiceKey.create('sp-http:GraphHttpClient', GraphHttpClient);
    GraphHttpClient._className = 'GraphHttpClient';
    GraphHttpClient._logSource = _LogSource.create('graphHttpClient');
    return GraphHttpClient;
}());
export default GraphHttpClient;
//# sourceMappingURL=GraphHttpClient.js.map