import { CacheStrategy } from './IRequestCacheOptions';
/**
 * Cache Manager for http Requests
 *
 * @internal
 */
var CacheManager = /** @class */ (function () {
    function CacheManager() {
    }
    /**
     * Fetches latest data from server or cache. Updates the cache from server if needed.
     * @param cacheKey - The cache Key
     * @param cacheProvider - The cache Provider
     * @param cacheStrategy - The Cache Strategy
     * @param serverFetch - The server fetch call
     * @param serverFetchArgs - The arguments to be used on the server fetch call
     */
    CacheManager.fetchAndCache = function (cacheKey /* tslint:disable-line:no-any */, cacheProvider, cacheConfiguration, serverFetch) {
        var cacheStrategy = cacheConfiguration.cacheStrategy;
        // 3rd party default behavior - If cacheStrategy is undefined, make a cache or network request
        if (cacheStrategy === undefined) {
            return cacheProvider
                .getData(cacheKey, cacheConfiguration)
                .then(function (cacheData) { return cacheData.data; })
                .catch(function () {
                // Cache Miss, update cache with serverData
                return CacheManager._fetchAndUpdateCache(serverFetch, cacheKey, cacheProvider, cacheConfiguration).catch(function (e) {
                    throw e;
                });
            });
        }
        // First Party Caching Strategies
        if (cacheStrategy === CacheStrategy.CacheThenNetwork) {
            return CacheManager._applyCacheThenNetworkStrategy(cacheKey, cacheProvider, cacheConfiguration, serverFetch);
        }
        var cachableResponse = CacheManager._applyCacheStrategy(cacheKey, cacheProvider, cacheConfiguration, serverFetch);
        return Promise.resolve(cachableResponse);
    };
    CacheManager._applyCacheThenNetworkStrategy = function (cacheKey /* tslint:disable-line:no-any */, cacheProvider, cacheConfiguration, serverFetch) {
        var cachableResponse = {
            cachedResponse: undefined,
            serverResponse: undefined
        };
        return cacheProvider
            .getData(cacheKey, cacheConfiguration)
            .then(function (cacheData) {
            cachableResponse.cachedResponse = Promise.resolve(cacheData.data);
            if (cacheData.stats && cacheData.stats.isStale) {
                cachableResponse.serverResponse = CacheManager._fetchAndUpdateCache(serverFetch, cacheKey, cacheProvider, cacheConfiguration);
            }
            return cachableResponse;
        })
            .catch(function () {
            // Only serverData can be available and returned
            cachableResponse.serverResponse = CacheManager._fetchAndUpdateCache(serverFetch, cacheKey, cacheProvider, cacheConfiguration);
            return cachableResponse;
        });
    };
    CacheManager._applyCacheStrategy = function (cacheKey /* tslint:disable-line:no-any */, cacheProvider, cacheConfiguration, serverFetch) {
        var cacheStrategy = cacheConfiguration.cacheStrategy;
        var cachableResponse = {
            cachedResponse: undefined,
            serverResponse: undefined
        };
        if (cacheStrategy === CacheStrategy.CacheOnly || cacheStrategy === CacheStrategy.CacheAndNetwork) {
            cachableResponse.cachedResponse = cacheProvider
                .getData(cacheKey, cacheConfiguration)
                .then(function (cacheData) { return cacheData.data; });
        }
        if (cacheStrategy === CacheStrategy.NetworkOnly || cacheStrategy === CacheStrategy.CacheAndNetwork) {
            cachableResponse.serverResponse = CacheManager._fetchAndUpdateCache(serverFetch, cacheKey, cacheProvider, cacheConfiguration);
        }
        return cachableResponse;
    };
    CacheManager._fetchAndUpdateCache = function (serverFetch, cacheKey /* tslint:disable-line:no-any */, cacheProvider, cacheConfiguration) {
        return serverFetch().then(function (response) {
            if (response.clone) {
                CacheManager._updateCache(cacheKey, cacheProvider, response.clone(), cacheConfiguration);
            }
            return response;
        });
    };
    CacheManager._updateCache = function (cacheKey /* tslint:disable-line:no-any */, cacheProvider, response, cacheConfiguration) {
        // Only update the cache if the server response is valid and a non-empty response
        if (response.status >= 200 && response.status < 300 && response.status !== 204) {
            response
                .json()
                .then(function (freshData) {
                if (freshData) {
                    // Update the cache when there is fresh data available from the server
                    setTimeout(function () { return cacheProvider.setData(cacheKey, freshData, cacheConfiguration); }, 0);
                }
            })
                .catch(function (e) {
                throw e;
            });
        }
    };
    return CacheManager;
}());
export { CacheManager };
//# sourceMappingURL=CacheManager.js.map