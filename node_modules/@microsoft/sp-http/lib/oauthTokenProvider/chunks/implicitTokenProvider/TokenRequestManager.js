import { Guid, _BrowserDetection, _SPEventManager, _SPKillSwitch } from '@microsoft/sp-core-library';
import { _QosMonitor } from '@microsoft/sp-diagnostics';
import { default as AadTokenProvider, TokenAcquisitionEventArgs } from '../../AadTokenProvider';
import AadConstants from '../../AadConstants';
import { AadErrorHandler } from '../../AadErrorHandler';
import { ACCESS_TOKEN_KEY, EXPIRATION_KEY, TokenStorage } from './TokenStorage';
import * as strings from '../../../SPHttpStrings.resx';
import { AadKillSwitches } from '../../AadKillSwitches';
var DEFAULT_TOKEN_EXPIRATION = '3600';
var PLUS_SIGN_REGEX = /\+/g;
var SEARCH_REGEX = /([^&=]+)=([^&]*)/g;
var TokenRequestManager = /** @class */ (function () {
    function TokenRequestManager(configuration) {
        this._defaultConfiguration = configuration;
        this._resourceMap = new Map();
        this._tokenRequestDictionary = new Map();
    }
    TokenRequestManager.isSuccessfulResponse = function (tokenResponse) {
        return (!!tokenResponse.token &&
            !!tokenResponse.expiration);
    };
    TokenRequestManager.isExpectedError = function (errorMessage) {
        var userAgentString = _BrowserDetection.getBrowserInformation().userAgent || '';
        return (AadErrorHandler._doesAadErrorCodeExist(errorMessage, AadConstants.EXPECTED_AAD_ERRORS) ||
            userAgentString.indexOf('TabStop/1.0') > -1); // MSAL Implicit seems to have issues with test infra.
    };
    TokenRequestManager._createResourceMetadata = function (resourceEndpoint) {
        return {
            correlationId: Guid.newGuid().toString(),
            state: Guid.newGuid().toString(),
            uri: resourceEndpoint
        };
    };
    /**
     * FROM MSAL.JS WindowUtils.monitorWindowForHash
     * @hidden
     * Monitors a window until it loads a url with a hash
     * @ignore
     */
    TokenRequestManager._monitorWindowForHash = function (contentWindow, timeout) {
        var POLLING_INTERVAL_MS = 50;
        return new Promise(function (resolve, reject) {
            var maxTicks = timeout / POLLING_INTERVAL_MS;
            var ticks = 0;
            var startTime = Date.now();
            var intervalId = setInterval(function () {
                if (contentWindow.closed) {
                    clearInterval(intervalId);
                    reject(new Error('User closed iframe'));
                }
                var hash;
                try {
                    /*
                     * Will throw if cross origin,
                     * which should be caught and ignored
                     * since we need the interval to keep running while on STS UI.
                     */
                    hash = contentWindow.location.hash;
                }
                catch (e) {
                    // Ignore this error as it's expected for cross domain requests
                }
                ticks++;
                if (hash) {
                    clearInterval(intervalId);
                    // ADAL.JS mentions that sometimes the hash may be followed by /
                    // WEX VSO Item: BUG 906637
                    if (hash.indexOf('#/') > -1) {
                        hash = hash.substring(hash.indexOf('#/') + 2);
                    }
                    else if (hash.indexOf('#') > -1) {
                        hash = hash.substring(1);
                    }
                    resolve(hash);
                }
                else if (ticks > maxTicks) {
                    clearInterval(intervalId);
                    // Return timeout if we've been trying to fetch the token for over a minute
                    if (Date.now() > startTime + 1000 * 60) {
                        reject(new Error('Timeout due to TAB suspension'));
                    }
                    else {
                        reject(new Error('Token retrieval timeout'));
                    }
                }
            }, POLLING_INTERVAL_MS);
        });
    };
    /**
     * Parses the query string parameters into a key-value pair object.
     * From ADAL.JS
     * @ignore
     */
    TokenRequestManager._deserialize = function (hash) {
        var match;
        var pl = PLUS_SIGN_REGEX, search = SEARCH_REGEX, decode = function (s) {
            return decodeURIComponent(s.replace(pl, ' '));
        }, obj = {};
        match = search.exec(hash);
        while (match) {
            obj[decode(match[1])] = decode(match[2]);
            match = search.exec(hash);
        }
        return obj;
    };
    /**
     * Adds the hidden iframe for silent token renewal. This code is a security fix to ADAL.js's iframe
     * rendering code. IE11 doesn't support dynamically setting attributes on an iFrame element, so
     * we must patch the original implementation. Original code is in ADAL.js addAdalFrame.
     * https://github.com/AzureAD/azure-activedirectory-library-for-js/ for source code
     */
    TokenRequestManager._createIframe = function (iframeId, tokenRequestUrl) {
        var sandboxAttributes = 'allow-same-origin allow-scripts allow-forms allow-pointer-lock';
        var ifr = document.createElement('iframe');
        ifr.setAttribute('id', iframeId);
        ifr.setAttribute('aria-hidden', 'true');
        ifr.setAttribute('sandbox', sandboxAttributes);
        ifr.style.visibility = 'hidden';
        ifr.style.position = 'absolute';
        ifr.style.width = ifr.style.height = ifr.style.border = '0';
        var iFrameReference = document.getElementsByTagName('body')[0].appendChild(ifr);
        iFrameReference.src = tokenRequestUrl;
        return iFrameReference;
    };
    TokenRequestManager.prototype.getToken = function (resourceUri, useLoginHint) {
        var resourceMetadata = this._resourceMap.get(resourceUri);
        if (!resourceMetadata) {
            resourceMetadata = TokenRequestManager._createResourceMetadata(resourceUri);
            this._resourceMap.set(resourceUri, resourceMetadata);
        }
        var tokenRequest = AadKillSwitches.isUpdateTokenForImplicitTokenProviderEnabled()
            ? undefined
            : this._tokenRequestDictionary.get(JSON.stringify(resourceMetadata));
        if (!tokenRequest) {
            tokenRequest = this._getToken(resourceUri, useLoginHint, resourceMetadata, 0);
        }
        if (!AadKillSwitches.isUpdateTokenForImplicitTokenProviderEnabled()) {
            this._tokenRequestDictionary.set(JSON.stringify(resourceMetadata), tokenRequest);
        }
        return tokenRequest;
    };
    TokenRequestManager.prototype._getToken = function (resourceUri, useLoginHint, resourceMetadata, attemptCount) {
        var _this = this;
        if (attemptCount === void 0) { attemptCount = 0; }
        var acquireAccessTokenQosMonitor = new _QosMonitor('ImplicitTokenProvider.FetchAccessTokenSilent');
        var extraData = this._generateTelemetryExtraData(resourceUri, resourceMetadata.correlationId);
        var tokenRequest = this._generateTokenRequestPromise(resourceMetadata, useLoginHint);
        return tokenRequest
            .then(function (response) {
            if (TokenRequestManager.isSuccessfulResponse(response)) {
                acquireAccessTokenQosMonitor.writeSuccess(extraData);
            }
            else {
                _this._handleAuthErrors(acquireAccessTokenQosMonitor, resourceUri, response.errorDescription, response.errorCode, extraData);
                if (attemptCount < 1) {
                    var localLoginHint = useLoginHint;
                    if (!_SPKillSwitch.isActivated('3d883034-d2f0-4034-8c1e-9ade277ceb6c' /* '8/5/2020', 'Retry Authentication' */) &&
                        response.errorDescription.indexOf(AadConstants.LOGIN_REQUIRED) > -1) {
                        localLoginHint = false;
                    }
                    return _this._getToken(resourceUri, localLoginHint, resourceMetadata, ++attemptCount);
                }
            }
            return response;
        })
            .catch(function (error) {
            // Timeout failure
            acquireAccessTokenQosMonitor.writeUnexpectedFailure('Timeout', error);
            if (attemptCount < 1) {
                return _this._getToken(resourceUri, useLoginHint, resourceMetadata, ++attemptCount);
            }
            throw error;
        });
    };
    TokenRequestManager.prototype._generateTelemetryExtraData = function (resourceUri, correlationId) {
        // alias is being used to detect cache hits
        return {
            alias: 'false',
            CorrelationId: correlationId,
            isInternal: this._defaultConfiguration.servicePrincipalId === AadConstants.PRE_AUTHORIZED_APP_PRINCIPAL_ID,
            name: resourceUri
        };
    };
    TokenRequestManager.prototype._handleAuthErrors = function (monitor, resourceUri, errorMessage, errorCode, extraData) {
        if (AadErrorHandler._isInteractionRequired(errorMessage, errorCode)) {
            try {
                // SPFxSingleSignOn will read this value and use it redirect back to this page for MFA failures
                sessionStorage.setItem('adal.login.request', window.location.href);
                sessionStorage.setItem('SPORedirectTokenKey', TokenStorage.getCacheKey(this._defaultConfiguration.aadUserId || '', this._defaultConfiguration.servicePrincipalId, ACCESS_TOKEN_KEY, resourceUri));
                sessionStorage.setItem('SPORedirectExpirationKey', TokenStorage.getCacheKey(this._defaultConfiguration.aadUserId || '', this._defaultConfiguration.servicePrincipalId, EXPIRATION_KEY, resourceUri));
            }
            catch (e) {
                // If session storage is unavailable, SPFxSingleSignOn will redirect to window.location.host
            }
            _SPEventManager.instance.raiseEvent(AadTokenProvider._tokenAcquisitionEventId, new TokenAcquisitionEventArgs(strings.additionalCredentialsWarning, this._getTokenRequestUrl(TokenRequestManager._createResourceMetadata(resourceUri), false, false)));
        }
        var err = new Error(errorCode + ': ' + errorMessage);
        if (TokenRequestManager.isExpectedError(errorMessage)) {
            monitor.writeExpectedFailure(errorCode, err, extraData);
        }
        else {
            monitor.writeUnexpectedFailure(errorCode, err, extraData);
        }
    };
    TokenRequestManager.prototype._getTokenRequestUrl = function (resourceMetadata, useLoginHint, isSilent) {
        var tokenResponseType = 'token';
        var implicitTokenProviderName = 'SPFxImplicitTokenProvider';
        var loginHintQueryParameter = useLoginHint && this._defaultConfiguration.userPrincipalName
            ? '&login_hint=' + encodeURIComponent(this._defaultConfiguration.userPrincipalName)
            : '';
        var isSilentQueryParameter = isSilent ? '&prompt=none' : '&prompt=select_account';
        return (this._defaultConfiguration.aadInstanceUrl +
            '/' +
            this._defaultConfiguration.aadTenantId +
            '/oauth2/authorize' +
            '?response_type=' +
            tokenResponseType +
            '&client_id=' +
            encodeURIComponent(this._defaultConfiguration.servicePrincipalId) +
            '&resource=' +
            encodeURIComponent(resourceMetadata.uri) +
            '&redirect_uri=' +
            encodeURIComponent(this._defaultConfiguration.redirectUri) +
            '&state=' +
            encodeURIComponent(resourceMetadata.state) +
            loginHintQueryParameter +
            '&client-request-id=' +
            encodeURIComponent(resourceMetadata.correlationId) +
            '&x-client-SKU=Js' +
            '&x-client-Ver=' +
            implicitTokenProviderName +
            isSilentQueryParameter);
    };
    TokenRequestManager.prototype._generateTokenRequestPromise = function (resourceMetadata, useLoginHint) {
        var _this = this;
        var tokenRequestUrl = this._getTokenRequestUrl(resourceMetadata, useLoginHint, true);
        var tokenRequestIFrame = TokenRequestManager._createIframe(resourceMetadata.correlationId + '|' + resourceMetadata.uri, tokenRequestUrl);
        return TokenRequestManager._monitorWindowForHash(tokenRequestIFrame.contentWindow, 10000).then(function (hash) {
            return _this._convertHashtoTokenResponse(resourceMetadata, hash);
        });
    };
    TokenRequestManager.prototype._convertHashtoTokenResponse = function (tokenRequest, hash) {
        var parameters = TokenRequestManager._deserialize(hash);
        if (tokenRequest.state !== parameters.state) {
            return {
                errorCode: 'Invalid State',
                errorDescription: 'State mismatch. Expected:' + tokenRequest.state + ' Actual: ' + parameters.state,
                isExpected: false
            };
        }
        var token = parameters.access_token;
        if (token) {
            return {
                expiration: parameters.expires_in || DEFAULT_TOKEN_EXPIRATION,
                token: token
            };
        }
        else {
            return {
                errorCode: parameters.error || 'Unknown',
                errorDescription: parameters.error_description || 'Error Description was missing',
                isExpected: TokenRequestManager.isExpectedError(parameters.error_description || 'Error Description was missing')
            };
        }
    };
    return TokenRequestManager;
}());
export { TokenRequestManager };
//# sourceMappingURL=TokenRequestManager.js.map