import { __extends } from "tslib";
import { BaseComponent } from '@microsoft/sp-component-base';
import { Guid, UrlQueryParameterCollection, Validate, _SPEventManager, _SPKillSwitch, _SPFlight, _BrowserUtilities, SPEvent } from '@microsoft/sp-core-library';
import { _EngagementLogger, _QosMonitor } from '@microsoft/sp-diagnostics';
import { _SPLoaderFlights } from '@microsoft/sp-loader';
import { isEqual, get } from '@microsoft/sp-lodash-subset';
import { _PerformanceLogger, _PerformanceFlight } from '@ms/sp-telemetry';
import { SuiteNavManager, SuiteNavManagerConfiguration } from '@ms/sp-suite-nav';
import { createTheme, registerOnThemeChangeCallback, removeOnThemeChangeCallback } from '@ms/uifabric-styling-bundle';
import { spLoadTheme } from '@ms/odsp-datasources/lib/providers/theming/ThemeUtilities';
import * as loadThemedStyles from '@microsoft/load-themed-styles';
import BaseApplicationContext from './BaseApplicationContext';
import AadPlaceholderManager from './frameworkPlaceholders/AadPlaceholderManager';
import SPThemeProvider from './pageChrome/SPThemeProvider';
import { ApplicationLoadType } from './ApplicationLoadType';
import ApplicationManager from './ApplicationManager';
var SUITE_NAV_USE_SPO_BEHAVIOR_KILL_SWITCH = Guid.parse('22F8084E-9DEB-4642-B63E-E70A7F87C998');
// Qos constants
var loadQosScenarioName = 'BaseApplication.load';
var renderQosScenarioName = 'BaseApplication.render';
var unloadQosScenarioName = 'BaseApplication.unload';
// tslint:disable-next-line: no-any
function addChangeCallback(object, propertyName, onChange) {
    var hiddenPropertyName = "_sp_workaround" + propertyName;
    object[hiddenPropertyName] = object[propertyName];
    Object.defineProperty(object, propertyName, {
        set: function (value) {
            object[hiddenPropertyName] = value;
            if (onChange) {
                onChange(object[hiddenPropertyName]);
            }
        },
        get: function () { return object[hiddenPropertyName]; }
    });
}
/**
 * This is the system base class for client-side applications.  It manages the overall
 * life cycle of your application, and is the first entry point for your code to start
 * executing when the page loads.  The two main events are onLoad() which occurs first,
 * and onRender() which occurs after the application manager has initialized the environment
 * and completed rendering the page chrome.
 *
 * @alpha
 */
var BaseApplication = /** @class */ (function (_super) {
    __extends(BaseApplication, _super);
    function BaseApplication() {
        var _this = _super.call(this) || this;
        _this._handleSecondFlush = function (data) {
            _this.context._updateSecondFlushData(data);
            _this.onLoad()
                .then(function () {
                _this._onRender();
            })
                .catch(function (e) {
                throw e;
            });
        };
        _this._handleThemeChange = function (changedTheme) {
            // if the incoming theme isn't the latest version of the theme, someone is calling an outdated loadTheme(),
            // so pass it to the latest version of loadTheme()
            if (!isEqual(createTheme(changedTheme), changedTheme)) {
                spLoadTheme(changedTheme);
            }
        };
        // tslint:disable-next-line:no-string-literal
        _this['__type'] = 'BaseApplication';
        // Merge Fabric global settings to avoid run-time exception in Fabric component code.
        addChangeCallback(get(window, '__globalSettings__'), 'customizations', function (value) {
            return _this._handleThemeChange(value.settings.theme);
        });
        addChangeCallback(get(window, '__globalSettings__.customizations'), 'settings', function (value) {
            return _this._handleThemeChange(value.theme);
        });
        addChangeCallback(get(window, '__globalSettings__.customizations.settings'), 'theme', function (value) {
            return _this._handleThemeChange(value);
        });
        if (_SPLoaderFlights._isMinimalStartFlightEnabled()) {
            _this._onSecondFlushEvent = new SPEvent('onSecondFlush');
            _this._onSecondFlushEvent.add(_this, function (data) {
                _this._secondFlushEventRaised = true;
                _this._secondFlushPreloadedData = data;
            });
        }
        return _this;
    }
    Object.defineProperty(BaseApplication.prototype, "domElement", {
        /**
         * Returns the DOM element where the application is expected to render its content.
         * The domElement will be undefined until the onRender() event occurs.
         *
         * @remarks
         * IMPORTANT: The application should not access DOM elements outside of this subtree,
         * as they are system-defined and may change over time.
         *
         * Throws an error if the domElement is undefined.
         */
        get: function () {
            Validate.isNotNullOrUndefined(this.context, 'context');
            Validate.isNotDisposed(this.context, 'context');
            Validate.isNotNullOrUndefined(this.context.chrome, 'chrome');
            Validate.isNotDisposed(this.context.chrome, 'chrome');
            return this.context.chrome.appDiv;
        },
        set: function (value) {
            throw new Error('The property cannot be assigned because it is read-only');
        },
        enumerable: false,
        configurable: true
    });
    /**
     * RESERVED FOR INTERNAL USAGE. This method is invoked automatically by the application manager.
     * The application code should not call it directly.
     *
     * @internal
     */
    BaseApplication.prototype._load = function (contextParameters) {
        var _this = this;
        var qosMonitor = new _QosMonitor(loadQosScenarioName);
        try {
            var applicationContext = this._getApplicationContext(contextParameters);
            this._initializeContext(applicationContext);
            var aadPlaceholderManager = new AadPlaceholderManager();
            aadPlaceholderManager.setUpTokenAcquistionFailurePlaceholder(this, this.context.serviceScope);
            var loadPromise = void 0;
            if (_SPLoaderFlights._isMinimalStartFlightEnabled()) {
                loadPromise = this.onBeforeLoad().then(function () {
                    // Either the second flush was fast or this is an app-to-app transition
                    if (_this._secondFlushEventRaised) {
                        // If this is an app-to-app transition then the preloaded data is already up to date
                        if (_this.context.preloadedData.isFirstFlush) {
                            _EngagementLogger.logEvent('_load.SecondFlushBeforeFirstFlushFinished');
                            _this.context._updateSecondFlushData(_this._secondFlushPreloadedData);
                        }
                        _this._loadedDuringFirstFlush = true;
                        return _this.onLoad();
                    }
                });
            }
            else {
                loadPromise = this.onLoad();
            }
            return loadPromise
                .then(function () { return qosMonitor.writeSuccess(); })
                .catch(function (e) {
                qosMonitor.writeExpectedFailure('onLoadFailure', e);
                throw e;
            });
        }
        catch (error) {
            qosMonitor.writeUnexpectedFailure('SyncError', error);
            return Promise.reject(error);
        }
    };
    /**
     * RESERVED FOR INTERNAL USAGE. This method is invoked automatically by the application manager
     * to render the application.
     * The application code should not call it directly.
     *
     * @internal
     */
    BaseApplication.prototype._render = function () {
        var qosMonitor = new _QosMonitor(renderQosScenarioName);
        try {
            // We load styles async by default, which is good for performance.
            // At this point in time we want to ensure that all styles in buffer are mounted before
            // rendering the app.
            loadThemedStyles.flush();
            this.context.chrome.show();
            var isFullPageLoad = this.context.loadType === ApplicationLoadType.FullPageLoad;
            var suiteNavManager = this.context.serviceScope.consume(SuiteNavManager.serviceKey);
            suiteNavManager.initialize(this.context.chrome.suiteNavDiv, isFullPageLoad);
            this.context.initializeSuiteNavManager(suiteNavManager);
            var config = this.suiteNavConfiguration();
            if (!config.isSuiteNavDisabled()) {
                var useNewFlow = _SPFlight.isEnabled(1309 /* SPClientSuiteNavCommon */) && config.isSuiteNavLoadingDeferred();
                if (useNewFlow) {
                    if (this.componentId === '1f019ae1-2de1-4f44-b723-00a6ec1d7445' /* SPHome app id */) {
                        _PerformanceLogger.trackFlight(_PerformanceFlight.CSISPHomeLazyLoadSearchPackage);
                    }
                    else {
                        // Every other sp-client app uses the SPPages flight
                        _PerformanceLogger.trackFlight(_PerformanceFlight.CSISPPagesLazyLoadSearchPackage);
                    }
                    suiteNavManager.loadSuiteNavNewFlow(config); // uses new suite nav flow
                }
                else {
                    suiteNavManager.loadSuiteNav(config);
                }
            }
            // We would have only loaded during the first flush if the second flush happened before a call to `_load`
            if (_SPLoaderFlights._isMinimalStartFlightEnabled() && !this._loadedDuringFirstFlush) {
                this._onSecondFlushEvent.add(this, this._handleSecondFlush);
            }
            else {
                this._onRender();
            }
            qosMonitor.writeSuccess();
        }
        catch (error) {
            qosMonitor.writeExpectedFailure('onRenderError', error);
        }
    };
    /**
     * RESERVED FOR INTERNAL USAGE. This method is invoked by the application manager
     * to unload the application. The page chrome is still available at this point
     * The application code should not call it directly.
     *
     * @internal
     */
    BaseApplication.prototype._unload = function () {
        var qosMonitor = new _QosMonitor(unloadQosScenarioName);
        try {
            this.onUnload();
            qosMonitor.writeSuccess();
        }
        catch (error) {
            qosMonitor.writeExpectedFailure('onUnloadError', error);
        }
    };
    /**
     * RESERVED FOR INTERNAL USAGE. This method is invoked automatically by the application manager
     * to load the application specific theme.
     * The application code should not call it directly.
     *
     * @internal
     */
    BaseApplication.prototype._loadTheme = function () {
        // When cleaning up the killswitch, keep the check for isChromelessApplication here and remove the check from
        // other code calling this function
        if (!ApplicationManager._isChromelessApplication(this.componentId)) {
            registerOnThemeChangeCallback(this._handleThemeChange);
            var themeProvider = this._getThemeProvider();
            themeProvider.loadThemedStyles();
        }
    };
    /**
     * RESERVED FOR INTERNAL USAGE.
     * Internal API to dispose the application.
     * See onDispose for more details
     * override
     */
    BaseApplication.prototype.dispose = function () {
        removeOnThemeChangeCallback(this._handleThemeChange);
        this.onDispose();
        _super.prototype.dispose.call(this);
    };
    /**
     * This virtual function returns the default configuration and can be configured by applications
     * when required.
     * virtual
     */
    BaseApplication.prototype.suiteNavConfiguration = function () {
        var config = new SuiteNavManagerConfiguration(this._getSuiteNavManagerConfigurationData());
        config.updateSuiteNavHeight = this._suiteNavHeightHandler.bind(this);
        return config;
    };
    /**
     * This virtual function returns the default application context and can be configured by applications
     * when required.
     *
     * virtual
     * @internal
     */
    BaseApplication.prototype._getApplicationContext = function (contextParameters) {
        return new BaseApplicationContext(contextParameters);
    };
    /**
     * This virtual function returns the default application theme provider and can be overridden by applications
     * when required.
     * virtual
     *
     * @internal
     */
    BaseApplication.prototype._getThemeProvider = function () {
        return new SPThemeProvider(this.context.serviceScope);
    };
    /**
     * Perform operations dependent only on `_IMinimalPreloadedData` while waiting for the second flush to provide
     * `_IPreloadedData`. Any operations dependent on `_IPreloadedData` should happen in `onLoad`.
     *
     * @internal
     * @virtual
     */
    BaseApplication.prototype.onBeforeLoad = function () {
        return Promise.resolve();
    };
    /**
     * This life cycle event occurs immediately after the application manager has loaded the application,
     * before the DOM is constructed.  Applications can use this event to load scripts
     * or start asynchronous operations that need to occur early in the lifecycle.
     * Inside the onLoad() event, applications may also modify the rendering of various
     * page chrome elements, for example by calling this.context.suiteNav.setComponentVisibility(false).
     * virtual
     */
    BaseApplication.prototype.onLoad = function () {
        // (implemented by subclass)
        return Promise.resolve();
    };
    /**
     * This lifecycle event occurs before hiding the application chrome. At this point the application still has
     * the DOM element available and can perform specific operations before the chrome is hidden from the view-port
     * virtual
     */
    BaseApplication.prototype.onUnload = function () {
        // (implemented by subclass)
    };
    /**
     * This lifecycle event occurs after the application manager has constructed the DOM for the page chrome.
     * At this time, the domElement property will be initialized, and the application can begin
     * rendering its own DOM elements.
     * virtual
     */
    BaseApplication.prototype.onRender = function () {
        // (implemented by subclass)
    };
    /**
     * This API is called at the end of the application lifecycle. It should be used to dispose any local
     * resources (i.e. DOM elements) that the application is holding onto.
     *
     * This API is expected to be called in scenarios like cross-application navigation
     * i.e. the host is transitioning from one application to another and disposes the application that is being
     * transitioned out.
     * virtual
     */
    BaseApplication.prototype.onDispose = function () {
        // (implemented by subclass)
    };
    /**
     * Provides the data necessary to construct an instance of SuiteNavManagerConfiguration
     * @internal
     */
    BaseApplication.prototype._getSuiteNavManagerConfigurationData = function () {
        var pageContext = this.context.pageContext;
        var webTemplateId;
        if (!_SPKillSwitch.isActivated(SUITE_NAV_USE_SPO_BEHAVIOR_KILL_SWITCH, '9/08/2017', 'SuiteNavUseSPOBehaviors')) {
            webTemplateId = pageContext.legacyPageContext.webTemplateId;
        }
        var disableSuiteNavSearchBox = pageContext.legacyPageContext.searchBoxInNavBar === 3 /* Hidden */;
        return {
            currentUICultureName: pageContext.cultureInfo.currentUICultureName,
            disableSuiteNav: this._shouldDisableSuiteNav(),
            preloadedData: this.context.preloadedData,
            settingsData: pageContext.legacyPageContext.MenuData
                ? pageContext.legacyPageContext.MenuData.SettingsData
                : undefined,
            signoutUrl: pageContext.legacyPageContext.MenuData
                ? pageContext.legacyPageContext.MenuData.SignOutUrl
                : undefined,
            siteClientTag: pageContext.legacyPageContext.siteClientTag,
            systemUserKey: pageContext.legacyPageContext.systemUserKey,
            userDisplayName: pageContext.user.displayName,
            webServerRelativeUrl: pageContext.web.serverRelativeUrl,
            webTemplateId: webTemplateId,
            disableSuiteNavSearchBox: disableSuiteNavSearchBox
        };
    };
    /**
     * Causes the navigator to navigate to a new page
     *
     * @remarks
     * This will be removed soon. Please use navigator from application context
     * to invoke public APIs
     */
    BaseApplication.prototype._navigate = function (url, props) {
        Validate.isNonemptyString(url, 'url');
        return this.context.navigator.navigate(url, props);
    };
    /**
     * Allows the navigator to reinitialize SPFx components with `_IPreloadedData`.
     *
     * @remarks
     * This will be removed soon. Please use navigator from application context
     * to invoke public APIs
     *
     * Navigation is an async operation but calling this API ignores the promise.
     * This is used by List application to change the context, so the framework will send the appropriate events
     * for the context change, but it doesn't impact the application.
     */
    BaseApplication.prototype._navigateToPreloadedData = function (preloadedData) {
        Validate.isNotNullOrUndefined(preloadedData, 'preloadedData');
        this.context.navigator.navigateToPreloadedData(preloadedData);
    };
    /**
     * Invalidates a cached resource by its URL. Any subsequent request for the resource
     * will be fetched from its origin and recached.
     *
     * @param url - URL to invalidate
     *
     * @remarks
     * This will be removed soon. Please use navigator from application context
     * to invoke public APIs
     */
    BaseApplication.prototype._invalidate = function (url) {
        Validate.isNotNullOrUndefined(url, 'url');
        return this.context.navigator.invalidate(url);
    };
    /**
     * Raises an event for a layout change.
     */
    BaseApplication.prototype.raiseLayoutChangedEvent = function () {
        _SPEventManager.instance.raiseEvent(BaseApplication._layoutChangedEventName, {});
    };
    BaseApplication.prototype._onRender = function () {
        this.onRender();
        // After we render we can stop listening for a secondFlush
        _SPEventManager.instance.removeEvent('onSecondFlush');
    };
    BaseApplication.prototype._shouldDisableSuiteNav = function () {
        var urlQueryParams = new UrlQueryParameterCollection(window.location.href);
        return (window.location.hostname === 'localhost' ||
            urlQueryParams.getValue('disableSuiteNav') === 'true' ||
            _BrowserUtilities.isEmbedded() ||
            !this.manifest.hasSuiteNav);
    };
    /**
     * This is a handler to update Suite Nav container height, when sp-suite-nav wants to update it.
     *
     * @param height - Height of the suite nav bar container to be set.
     */
    BaseApplication.prototype._suiteNavHeightHandler = function (height) {
        if (this.context.chrome) {
            this.context.chrome.changeSuiteNavHeight(height);
        }
    };
    /**
     * SPEvent name for page navigation.
     * @internal
     */
    BaseApplication._navigatedEventName = 'application.navigatedEvent';
    /**
     * SPEvent name for layout changes.
     * @internal
     */
    BaseApplication._layoutChangedEventName = 'application.layoutChangedEvent';
    /**
     * SPEvent name for prefetched data availability.
     * @internal
     */
    BaseApplication._prefetchedDataEventName = 'application.prefetchedDataEvent';
    /**
     * SPEvent name for application pre in-place navigation.
     * @internal
     */
    BaseApplication._onBeforeNavigationEventName = 'application.onBeforeNavigationEventName';
    return BaseApplication;
}(BaseComponent));
export default BaseApplication;
//# sourceMappingURL=BaseApplication.js.map