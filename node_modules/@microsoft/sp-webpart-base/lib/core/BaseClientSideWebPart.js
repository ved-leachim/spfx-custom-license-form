// Copyright (c) Microsoft. All rights reserved.
import { __extends } from "tslib";
import { _PerformanceLogger } from '@ms/sp-telemetry';
import { _LogSource, _QosMonitor, _TraceLogger } from '@microsoft/sp-diagnostics';
import { _SPKillSwitch, DisplayMode, Environment, Guid } from '@microsoft/sp-core-library';
import BaseWebPart from './BaseWebPart';
import ClassicPageUtils from './classicPages/ClassicPageUtils';
import KillSwitches, { isAllowProactiveRenderFailureKsActivated, isMoveAsyncTimerKSActivated } from './../common/KillSwitches';
import { SPWebPartError, SPWebPartErrorCode } from './error/SPWebPartError';
import WebPartWidthCacheManager from './WebPartWidthCacheManager';
import baseStyles from './styles/cswp-base.module.scss';
/**
 * This abstract class implements the the base functionality for a client-side web part. Every client-side web part
 * needs to inherit from this class.
 *
 * @remarks
 * Along with the base functionality, this class provides some APIs that can be
 * used by the web part. These APIs fall in two catagories.
 *
 * The first category of APIs provide data and functionality. Example, the web part context (i.e. this.context). This
 * API should be used to access contextual data relevant to this web part instance.
 *
 * The second category of APIs provide a base implementation for the web part lifecycle and can be overridden for an
 * updated implementation. The render() API is the only API that is mandatory to be implemented/overridden by a web
 * part. All other life cycle APIs have a base implementation and can be overridden based on the needs of the web part.
 * Please refer to the documentation of the individual APIs to make the right decision.
 *
 * @public
 */
var BaseClientSideWebPart = /** @class */ (function (_super) {
    __extends(BaseClientSideWebPart, _super);
    /**
     * Constructor for the BaseClientSideWebPart class.
     *
     * @remarks
     * It is highly recommended that the web part use the `onInit()` API to perform any web part specific
     * initialization.  Most of the web part features like this.context and `this.properties` are not
     * available to be used before the the `onInit()` part of the web part loading lifecycle.
     */
    function BaseClientSideWebPart() {
        var _this = _super.call(this) || this;
        _this._logSource = _LogSource.create('BaseClientSideWebPart');
        _this._asyncRenderQosMonitor = new _QosMonitor("WebPartAsyncRender");
        // Disallow instantiation of the base class by itself
        // tslint:disable-next-line:no-string-literal no-any
        if (_this.constructor['name'] === 'BaseClientSideWebPart') {
            throw SPWebPartError.create(SPWebPartErrorCode.BaseConstructError);
        }
        _this._firstTimeRenderPromises = [];
        return _this;
    }
    Object.defineProperty(BaseClientSideWebPart.prototype, "domElement", {
        // Readonly protected properties. To change these to readonly once TypeScript supports that feature.
        /**
         * This property is a pointer to the root DOM element of the web part. This is a DIV element and contains the whole
         * DOM subtree of the web part.
         *
         * @readonly
         */
        get: function () {
            return this.context.domElement;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseClientSideWebPart.prototype, "width", {
        /**
         *
         * This propery returns the width of the container for the web part.
         * @returns Width (in pixels) of the container for the web part.
         *
         * @remarks
         * Web parts should utilize this property to perform operations such as any conditional styling of components
         * based on the initial available width for the web part.
         * @internalRemarks
         * This function retrieves web part's key to get stored section width from cache.
         * If cache key does not exist in cache it will calculate and store the width before returning.
         *
         * In the case where getWebPartCacheKey is not passed down, it will go through the original
         * workflow to caculate web part width.
         * @readonly
         */
        get: function () {
            if (this.displayMode === DisplayMode.Read) {
                this._width = WebPartWidthCacheManager.getOrCalculateWidth(this.domElement, this._getExtendedWidthCacheKey());
            }
            else {
                if (this._width === undefined) {
                    this._width = WebPartWidthCacheManager.calculateWebPartWidth(this.domElement);
                }
            }
            return this._width;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseClientSideWebPart.prototype, "renderedOnce", {
        /**
         * This property indicates whether the web part has been rendered once or not. After the first time rendering,
         * the value of this property is always true until a full re-render of the web part happens.
         *
         * @readonly
         */
        get: function () {
            return !!this._renderedOnce;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseClientSideWebPart.prototype, "renderedFromPersistedData", {
        /**
         * This property indicates whether the web part was rendered from the persisted data (serialized state from the
         * last time that the web part was saved) or not.
         *
         * @remarks
         * Example: When web part is added for the first time using toolbox then the value is false.
         *
         * @readonly
         */
        get: function () {
            return !!this._renderedFromPersistedData;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseClientSideWebPart.prototype, "canOpenPopupOnRender", {
        /**
         * This property indicates whether a web part can open a popup on initial render.
         *
         * @remarks
         * In some environments the host
         * re-renders the web parts frequently, and therefore opening popups during render will cause popups to open
         * repeatedly, which is a poor user experience. As an example, the classic SharePoint pages perform postbacks
         * causing the page to re-render on all button clicks.
         *
         * If a web part needs to open a popup on render, it should use this API before opening the popup. If this API
         * returns false, the web part should not open popup on initial render. Some web parts that open popups during
         * render are the document embed web part that pops up the file picker on initial render, embedded video web part
         * that pops up the PropertyPane on initial render.
         *
         * @readonly
         */
        get: function () {
            // @todo (SPPPLAT VSO#243602): if the classic page experience is usable, we should remove this API.
            return true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseClientSideWebPart.prototype, "isRenderAsync", {
        /**
         * Indicates whether the web part is rendering in Async mode.
         *
         * @remarks
         * If the web part overrides this field to return true, then it needs to call renderCompleted API
         * after the web part rendering is complete.
         *
         * The default value is false.
         *
         * @virtual
         */
        get: function () {
            return false;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Internal API to update the webpart upon a resize of the DOM window's viewport
     *
     * See onAfterResize for more details.
     *
     * @internal
     */
    BaseClientSideWebPart.prototype._internalOnAfterResize = function () {
        this._width = undefined;
        this.onAfterResize(this.width);
    };
    /**
     * Internal API for the first time render of the web part. The purpose of this API is to enforce initialization steps
     * before the actual render is called. This API is called only once during the web part loading lifecycle.
     *
     * @returns The promise indicates the render loop is finished (success or fail).
     *
     * @internal
     */
    BaseClientSideWebPart.prototype._internalFirstTimeRender = function () {
        var _this = this;
        /* tslint:enable:no-unused-variable */
        if (this._renderPromiseResolver) {
            throw SPWebPartError.create(SPWebPartErrorCode.FirstTimeRenderCalledMoreThanOnce, this.context.webPartTag);
        }
        return new Promise(function (resolve, reject) {
            _this._renderPromiseResolver = resolve;
            _this._renderPromiseRejecter = reject;
            _this._onInViewport();
        });
    };
    /**
     * @internal
     */
    BaseClientSideWebPart.prototype._internalSetDisplayMode = function (newDisplayMode) {
        if (this.displayMode !== newDisplayMode) {
            // Switch display mode will change the canvas width of web part. Clear the cache of width here.
            this._width = undefined;
            this._renderedFromPersistedData = true;
        }
        _super.prototype._internalSetDisplayMode.call(this, newDisplayMode);
    };
    /**
     * @internal
     * {@inheritDoc BaseWebPart._internalInitialize}
     */
    BaseClientSideWebPart.prototype._internalInitialize = function (webPartContext, addedFromPersistedData, mode) {
        _super.prototype._internalInitialize.call(this, webPartContext, addedFromPersistedData, mode);
        this._renderedOnce = false;
        this['__type'] = 'BaseClientSideWebPart'; // tslint:disable-line:no-string-literal no-any
        // Bind the callbacks
        this.render = this.render.bind(this);
        this.onDispose = this.onDispose.bind(this);
        this.renderError = this.renderError.bind(this);
        this.clearError = this.clearError.bind(this);
        this.renderCompleted = this.renderCompleted.bind(this);
        this._asyncRenderTimeout = this._asyncRenderTimeout.bind(this);
    };
    /**
     * This API should be called by web parts that perform Async rendering. Those web part are required to override
     * the isRenderAsync API and return true. One such example is web parts that render content in an IFrame. The
     * web part initiates the IFrame rendering in the `render()` API but the actual rendering is complete only after
     * the iframe loading completes.
     */
    BaseClientSideWebPart.prototype.renderCompleted = function (error) {
        if (!isAllowProactiveRenderFailureKsActivated() && error) {
            this._handleAsyncRenderFailed(error);
        }
        else {
            this._renderCompleted();
        }
    };
    /**
     * This event method is called when the display mode of a web part is changed.
     *
     * @remarks
     * The default implementation of this API calls
     * the web part render method to re-render the web part with the new display mode. If a web part developer does not
     * want a full re-render to happen on display mode change, they can override this API and perform specific updates
     * to the web part DOM to switch its display mode.
     *
     * @param oldDisplayMode - The old display mode.
     *
     * @virtual
     */
    BaseClientSideWebPart.prototype.onDisplayModeChanged = function (oldDisplayMode) {
        var _this = this;
        _super.prototype.onDisplayModeChanged.call(this, oldDisplayMode);
        if (oldDisplayMode === this.displayMode) {
            return;
        }
        // Note: this quirk has existed for a very long time now. Long enough that it can be considered
        // a part of the design :(. Consider the scenario when the page is loaded with "&Mode=Edit" query
        // string parameter. As per the original design, the host, say, the ModernPage in this case, should call
        // the ClientSideWebPartManager.loadWebPart API with "displayMode == Edit" value. But that is not
        // the case. The ModernPage calls loadWebPart with "displayMode == Read" and then calls
        // ClientSideWebPartManager.setDisplayMode(displayMode == Edit). This opens the door for race condition
        // bugs to occur. Especially as the web part loading lifecycle is becoming more complex. To avoid these
        // race conditions from happening we need to to make sure all the first time rendering promises are
        // resolved before this._renderWithAccessibleTitle can be called.
        if (!_SPKillSwitch.isActivated(Guid.parse('222961df-4439-412b-9e41-2e659ae18ab6'), '5/11/2018', 'FirstRenderPromises')) {
            Promise.all(this._firstTimeRenderPromises)
                .then(function () { return _this._renderWithAccessibleTitle(); })
                .catch(function (e) { return _TraceLogger.logVerboseData({ source: _this._logSource, message: e.message }); });
        }
        else {
            this._renderWithAccessibleTitle();
        }
    };
    /**
     * This API should be used to refresh the contents of the PropertyPane.
     *
     * @remarks
     * This API is called at the end of the web part lifecycle on a page. It should be used to dispose any local
     * resources (i.e. DOM elements) that the web part is holding onto. This API is expected to be called in scenarios
     * like page navigation i.e. the host is transitioning from one page to another and disposes the page that is being
     * transitioned out.
     *
     * @virtual
     */
    BaseClientSideWebPart.prototype.onDispose = function () {
        /* EMPTY BLOCK */
    };
    /**
     * This API is invoked when the web part container dom element width is changed, e.g. when the
     * browser window is resized and when the property pane is toggled open/closed.
     *
     * @param newWidth - Width (in pixels) of the container for the web part after the resize event.
     * @remarks
     * Web parts should utilize this method to perform operations such as potentially re-rendering components
     * based on the new available width for the web part.
     *
     * @virtual
     */
    BaseClientSideWebPart.prototype.onAfterResize = function (newWidth) {
        /* EMPTY BLOCK */
    };
    /**
     * This API should be used to render an error message in the web part display area. Also logs the error message
     * using the trace logger.
     *
     * @param error - An error object containing the error message to render.
     */
    BaseClientSideWebPart.prototype.renderError = function (error) {
        this.context.statusRenderer.clearLoadingIndicator(this.domElement);
        this.context.statusRenderer.renderError(this.domElement, error);
        _TraceLogger.logError(this._logSource, error);
    };
    /**
     * This API should be used to clear the error message from the web part display area.
     */
    BaseClientSideWebPart.prototype.clearError = function () {
        this.context.statusRenderer.clearError(this.domElement);
    };
    /**
     * Internal API to trigger a refresh to the WebPart's visual rendition.
     * In this implementation of the BaseWebPart class we call the render API.
     *
     * @internal
     */
    BaseClientSideWebPart.prototype._refresh = function () {
        this._renderWithAccessibleTitle();
    };
    /**
     * Internal API triggered by a dynamic property's callback.
     * In this implementation of the BaseWebPart class we call the render API, only if rendered once.
     *
     * @internal
     */
    BaseClientSideWebPart.prototype._dynamicPropertyRefresh = function () {
        if (this.renderedOnce) {
            this.render();
        }
    };
    /**
     * @returns extends base width cache key with additional info to minimize reflows.
     *  Otherwise if base cache key does not exist return undefined.
     * @internal
     */
    BaseClientSideWebPart.prototype._getExtendedWidthCacheKey = function () {
        var baseKey = this.context.widthCacheKey;
        return baseKey ? this.displayMode + "-" + baseKey : undefined;
    };
    /**
     * The actual initialization and rendering of the Web part starts when it is close enough
     * to the Viewport
     */
    BaseClientSideWebPart.prototype._onInViewport = function () {
        var _this = this;
        // Render promise callback should be defined at this time.
        if (!this._renderPromiseResolver || !this._renderPromiseRejecter) {
            throw SPWebPartError.create(SPWebPartErrorCode.RenderPromiseUndefined, this.context.webPartTag);
        }
        // Perform web part initialization and then render the web part.
        var initPromise = this.onInit();
        if (!initPromise) {
            var error = SPWebPartError.create(SPWebPartErrorCode.OnInitReturnedNullPromise, this.context.webPartTag);
            this._renderPromiseRejecter(error);
            this._clearRenderPromises();
            return;
        }
        this._firstTimeRenderPromises.push(initPromise);
        initPromise
            .then(function () {
            _PerformanceLogger.markComponent(_this.context.webPartTag, 'init');
            var getDataPromise = Promise.resolve();
            // Perform web part initialization and then render the web part.
            getDataPromise = _this._internalGetData();
            if (!getDataPromise) {
                throw SPWebPartError.create(SPWebPartErrorCode.GetDataReturnedNullPromise, _this.context.webPartTag);
            }
            _this._firstTimeRenderPromises.push(getDataPromise);
            var renderPromise = getDataPromise.then(function () {
                _PerformanceLogger.markComponent(_this.context.webPartTag, 'getDataComplete');
                // Clear the loading indicator
                _this.context.statusRenderer.clearLoadingIndicator(_this.domElement);
                var isAsyncTimerKSActivated = isMoveAsyncTimerKSActivated();
                if (!isAsyncTimerKSActivated && _this.isRenderAsync) {
                    _this._startAsyncRenderGuardTimer();
                }
                _this._renderWithAccessibleTitle();
                // Record the time framework has finished calling render(). By this time framework is accountable
                // for loading web part module through fasted CDN and loading web part data through appropriate
                // techniques like Web part cache and synchronous time to execute web part's render() method.
                _PerformanceLogger.markComponent(_this.context.webPartTag, 'syncRender');
                // If rendering happened synchronously, simply complete the rendering cycle.
                // Else, create a new promise and wait for it to be resolved. The resolution
                // can happen when the web part completes the promise or when the timeout fires.
                if (!_this.isRenderAsync) {
                    _this._resolveOrRejectOnRenderPromise();
                }
                else if (isAsyncTimerKSActivated) {
                    _this._startAsyncRenderGuardTimer();
                }
            });
            return renderPromise;
        })
            .catch(function (e) {
            if (_this._renderPromiseRejecter) {
                _this._renderPromiseRejecter(e);
                _this._clearRenderPromises();
            }
        });
    };
    /**
     * Wraps render to ensure any type of rendering has access to the latest context
     * to provide the most accurate accessible info to screen readers.
     */
    BaseClientSideWebPart.prototype._renderWithAccessibleTitle = function () {
        _PerformanceLogger.devMark("webpart(" + this.context.webPartTag + ")._renderWithAccessibleTitle");
        this.render();
        // The accessible label is only required in edit mode. It is also not required for mobile devices
        // which only provide view mode
        if (this.displayMode === DisplayMode.Edit) {
            // Render the accessible description after and associate by ID to avoid re-rendering the whole zone
            // when webpart updates contextual info.
            var accessibleContext = this.accessibleTitle || this._getDefaultAccessibleTitle();
            if (accessibleContext) {
                // Keep ID in sync with ControlZone.render
                var contextualLabelId = "cswpAccessibleLabelContextual_" + this.context.instanceId;
                var accessibleDiv = this.domElement.querySelector("#" + contextualLabelId);
                var isNewLabelElement = !accessibleDiv;
                if (isNewLabelElement) {
                    accessibleDiv = document.createElement('div');
                    accessibleDiv.id = contextualLabelId;
                    accessibleDiv.className = baseStyles.screenReaderOnly;
                    accessibleDiv.setAttribute('aria-hidden', 'true');
                }
                accessibleDiv.textContent = accessibleContext;
                if (isNewLabelElement) {
                    this.domElement.appendChild(accessibleDiv);
                }
            }
            // Perform classic page fixup. It should only be called in edit mode otherwise it will
            // make anchor elements not working in view mode.
            ClassicPageUtils.disableAutomaticPostbacks(this.domElement, Environment.type);
        }
    };
    /**
     * Start async guard timer. This timer is to help avoid losing performance markers for a web part
     * that renders asynchronously but does not call the `renderCompleted` API;
     */
    BaseClientSideWebPart.prototype._startAsyncRenderGuardTimer = function () {
        var _this = this;
        // Note: the timer is 25 seconds because after 30 seconds, the PerformanceLogger will auto expire
        // the log timer and we will lose data. This value needs to be smaller than that.
        this._clearAsyncRenderGuardTimer();
        this._asyncRenderGuardTimer = window.setTimeout(function () {
            _this._asyncRenderTimeout();
        }, 25000);
    };
    /**
     * Render completed.
     */
    BaseClientSideWebPart.prototype._renderCompleted = function () {
        if (this._asyncRenderGuardTimer) {
            this._clearAsyncRenderGuardTimer();
            this._asyncRenderQosMonitor.writeSuccess({
                alias: this.context.manifest.alias,
                webPartId: this.context.manifest.id
            });
            this._resolveOrRejectOnRenderPromise();
        }
    };
    BaseClientSideWebPart.prototype._handleAsyncRenderFailed = function (error) {
        this._logAsyncRenderError(error, 'Failed');
        this._resolveOrRejectOnRenderPromise(error);
    };
    /**
     * Async render timed out. Log error information and
     */
    BaseClientSideWebPart.prototype._asyncRenderTimeout = function () {
        // There is a potential race condition when the async guard timer gets queued into the javascript
        // task queue right at the time when renderCompleted API gets called. Protect against that.
        if (this._asyncRenderGuardTimer) {
            this._clearAsyncRenderGuardTimer();
            // At this time we only log an error and fail the QOS monitor when the async guard timer fires.
            var error = SPWebPartError.create(SPWebPartErrorCode.RenderCompletedCallNotCalled, this.context.webPartTag);
            this._logAsyncRenderError(error, 'Timeout');
            this._resolveOrRejectOnRenderPromise();
        }
    };
    BaseClientSideWebPart.prototype._logAsyncRenderError = function (error, qosFailureTag) {
        _TraceLogger.logErrorData({
            source: this._logSource,
            error: error,
            serviceScope: this.context.serviceScope
        });
        this._asyncRenderQosMonitor.writeUnexpectedFailure(qosFailureTag, error, {
            alias: this.context.manifest.alias,
            webPartId: this.context.manifest.id,
            instanceId: this.instanceId
        });
    };
    BaseClientSideWebPart.prototype._clearAsyncRenderGuardTimer = function () {
        if (this._asyncRenderGuardTimer) {
            window.clearTimeout(this._asyncRenderGuardTimer);
            this._asyncRenderGuardTimer = undefined;
        }
    };
    /**
     * This is called for every web part whether sync or async once rendering is completed.
     */
    BaseClientSideWebPart.prototype._resolveOrRejectOnRenderPromise = function (error) {
        this._renderedOnce = true;
        _PerformanceLogger.devMark("webpart(" + this.context.webPartTag + ").complete");
        if (!isAllowProactiveRenderFailureKsActivated() && error) {
            if (this._renderPromiseRejecter) {
                this._renderPromiseRejecter(error);
            }
        }
        else {
            if (this._renderPromiseResolver) {
                if (!KillSwitches.isResolveRenderTimeActivated()) {
                    this._renderPromiseResolver(_PerformanceLogger.now());
                }
                else {
                    this._renderPromiseResolver();
                }
            }
        }
        this._clearRenderPromises();
    };
    BaseClientSideWebPart.prototype._clearRenderPromises = function () {
        this._renderPromiseResolver = undefined;
        this._renderPromiseRejecter = undefined;
        // Reset minHeight
        this.domElement.style.minHeight = null; // tslint:disable-line:no-null-keyword no-any
    };
    return BaseClientSideWebPart;
}(BaseWebPart));
export default BaseClientSideWebPart;
//# sourceMappingURL=BaseClientSideWebPart.js.map