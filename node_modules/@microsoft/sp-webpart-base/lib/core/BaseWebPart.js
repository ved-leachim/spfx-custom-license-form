// Copyright (c) Microsoft. All rights reserved.
import { __extends } from "tslib";
import { BaseComponent, DynamicProperty } from '@microsoft/sp-component-base';
import { DisplayMode, Text, Validate, Version } from '@microsoft/sp-core-library';
import { _EngagementLogger, _LogEntry, _LogSource, _LogType, _TraceLogger } from '@microsoft/sp-diagnostics';
import * as lodash from '@microsoft/sp-lodash-subset';
import { executeAndReThrow } from '../utils/ExecuteAndReThrow';
import { deepFreeze } from '../utils/Object';
import { PropertyPaneFieldType } from '../SPPropertyPane';
import { SPWebPartError, SPWebPartErrorCode } from './error/SPWebPartError';
import * as strings from './loc/Strings.resx';
/**
 * This abstract class implements the UI-agnostic base functionality for a client-side web part.
 * The purpose is to allow a common core between 2D and MR WebParts.
 *
 * @privateRemarks
 * The _refresh() and _dynamicPropertyRefresh() API are the only API that are
 * mandatory to be implemented by our base WebPart classes.
 *
 * @public
 */
var BaseWebPart = /** @class */ (function (_super) {
    __extends(BaseWebPart, _super);
    /**
     * Constructor for the `BaseWebPart` class.
     *
     * @remarks
     * It is highly recommended that the web part use the OnInit API to perform any web part specific initialization.
     * Most of the web part features like this.context and this.properties are not available to be used before the
     * the onInit part of the web part loading lifecycle.
     */
    function BaseWebPart() {
        var _this = _super.call(this) || this;
        _this._initialized = false;
        _this._baseLogSource = _LogSource.create('BaseWebPart');
        /**
         * It makes sure we only log edit events once during one editing session.
         */
        _this._hasEditLogged = false;
        _this._emptyResolvedPromise = Promise.resolve();
        _this._disposeDynamicPropertiesIfRequired = _this._disposeDynamicPropertiesIfRequired.bind(_this);
        // Disallow instantiation of the base class by itself
        // tslint:disable-next-line:no-string-literal no-any
        if (_this.constructor['name'] === 'BaseWebPart') {
            throw SPWebPartError.create(SPWebPartErrorCode.BaseConstructError);
        }
        return _this;
    }
    Object.defineProperty(BaseWebPart.prototype, "previewImageUrl", {
        /**
         * This property points to the preview image for the web part. The base implementation returns undefined. Web parts
         * that want to provide a valid preview image url need to override this API. The preview image url can be used to
         * create a preview of the web part or of the page on which the web part is present.
         * virtual
         */
        get: function () {
            return undefined;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseWebPart.prototype, "displayMode", {
        /**
         * This property is the current display mode of the web part.
         *
         * @readonly
         */
        get: function () {
            return this._displayMode;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseWebPart.prototype, "dataVersion", {
        /**
         * The value of this property is stored in the serialized data of the web part to allow developers to manage
         * versioning of their web part. The default version is 1.0
         */
        get: function () {
            return Version.parse('1.0');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseWebPart.prototype, "properties", {
        /**
         * This property is the pointer to the custom property bag of the web part.
         *
         * @readonly
         */
        get: function () {
            if (this._initialized) {
                return this._properties;
            }
            else {
                throw SPWebPartError.create(SPWebPartErrorCode.NotInitializedError);
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseWebPart.prototype, "propertiesMetadata", {
        /**
         * This property defines metadata for the web part property bag. The metadata can help SharePoint understand
         * the content of the properties better and perform relevant services on the data.
         * virtual
         *
         * @remarks
         * See {@link IWebPartPropertiesMetadata} for more information about how to define metadata
         */
        get: function () {
            return undefined;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseWebPart.prototype, "disableReactivePropertyChanges", {
        /**
         * This property is used to change the web part's property pane interaction from Reactive to NonReactive.
         * virtual
         *
         * @remarks
         * The default behavior is Reactive.
         *
         * Reactive implies that changes made in the PropertyPane are transmitted to the web part instantly and the user can
         * see instant updates. This helps the page creator get instant feedback and decide if they should keep the new
         * configuration changes or not.
         *
         * NonReactive implies that the configuration changes are transmitted to the web part only after "Apply" PropertyPane
         * button is clicked.
         */
        get: function () {
            return false;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseWebPart.prototype, "accessibleTitle", {
        /**
         * This property points to the accessible title of web part made available to screen readers. The base implementation
         * returns that default title in the manifest. Web parts that want to provide more descriptive title containing
         * contextual information need to override this API.
         * virtual
         */
        get: function () {
            return this._getDefaultAccessibleTitle();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseWebPart.prototype, "title", {
        /**
         * Title of the WebPart
         *
         * @readonly
         */
        get: function () {
            return this._title;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseWebPart.prototype, "iconImageUrl", {
        /**
         * Icon image URL of the WebPart
         *
         * @internal
         */
        get: function () {
            return this._iconImageUrl;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseWebPart.prototype, "description", {
        /**
         * Description of the WebPart
         *
         * @readonly
         */
        get: function () {
            return this._description;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseWebPart.prototype, "persistedProperties", {
        /**
         * This property is a pointer to the current set of properties which are already or needs to be persisted.
         *
         * @readonly
         */
        get: function () {
            return this.disableReactivePropertyChanges && this._backupProperties
                ? this._backupProperties
                : this.properties;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * API to get property pane configuration asynchronously.
     *
     * @internal
     */
    // tslint:disable-next-line:no-any
    BaseWebPart.prototype._getPropertyPaneData = function (isDetails, context) {
        var _this = this;
        return this._loadPropertyPaneResources().then(function () {
            var configuration = isDetails
                ? _this.getDetailsPaneConfiguration(context)
                : _this.getPropertyPaneConfiguration();
            _this._fixUpDynamicDataConfiguration(configuration);
            return {
                webPartId: _this.context.instanceId,
                title: _this.title,
                isReactive: !_this.disableReactivePropertyChanges,
                configuration: configuration,
                properties: _this._cloneProperties(_this.properties),
                // Below methods are being overridden in the PropertyPane controller and hence
                // we do not need to bind it here. We still do not want to make it optional because
                // that could lead to unwanted bugs.
                onPropertyPaneFieldChanged: undefined,
                onConfigurationEvent: undefined,
                onRendered: _this.onPropertyPaneRendered,
                dynamicConfiguration: {
                    defaultCallback: (function () {
                        _this._dynamicPropertyRefresh();
                    }).bind(_this),
                    dynamicDataProvider: _this.context.dynamicDataProvider
                }
            };
        });
    };
    /**
     * API to enable asynchronous loading of property pane related resources of a web part.
     *
     * @internal
     */
    BaseWebPart.prototype._loadPropertyPaneResources = function () {
        // Below promise will be undefined only when the web part is opening its property pane for the first time.
        if (!this._loadPropertyPaneResourcesPromise) {
            this._loadPropertyPaneResourcesPromise = this.loadPropertyPaneResources();
        }
        return this._loadPropertyPaneResourcesPromise;
    };
    /**
     * Internal API which is invoked when a property field is changed on the property pane.
     * This API is invoked only for the reactive property pane.
     *
     * @remarks
     * If the old value is of type DynamicProperty, but the new value is a static value
     * (This could happen when the 'targetProperty' is same for both a DynamicField on the
     * Dynamic Data Widget and a TextField which represents afore mentioned Dynamic Field
     * when the DD connection is removed by the end user on the property pane UI. In that
     * case, property pane sends in the static value which corresponds to the dynamic property(DP)
     * present before the DD connection is removed)
     *  then to respect the web part developer's choice of that target property being a DP,
     *  we create a new instace of DP and assign the incoming value as the static value
     *    then update the properties bag with the newly created DP instance.
     * else, update the properties bag with the new value for the property.
     *
     * @param propertyPath - JSON path of the property in the property bag.
     * @param newValue - New value of the property.
     *
     * @internal
     */
    BaseWebPart.prototype._onPropertyPaneFieldChanged = function (propertyPath, newValue /* tslint:disable-line:no-any */, fieldType) {
        var _this = this;
        var oldValue = lodash.get(this._properties, propertyPath); // tslint:disable-line:no-any
        // Property updates and web part re-rendering happens only in the following cases:
        //  case 1: when there is no change in the old and new value or
        //  case 2: when the event is coming from a button click(this is because, in this case
        //          regtardless of what newValue is we need to re-render the web part.)
        //  case 3: when the event is coming from a custom field(this is because, framework wouldn't
        //          know what exactly changed inside the custom field and we come to this spot in case
        //          case of custom field only when the web part specifically requests it.)
        if (!lodash.isEqual(oldValue, newValue) ||
            fieldType === PropertyPaneFieldType.Button ||
            fieldType === PropertyPaneFieldType.Custom) {
            // Create backupProperties if it is non-reactive property pane.
            if (this.disableReactivePropertyChanges && !this._backupProperties) {
                this._backupProperties = this._cloneProperties(this.properties);
            }
            if (oldValue instanceof DynamicProperty && !(newValue instanceof DynamicProperty)) {
                var newDynamicProperty = new DynamicProperty(// tslint:disable-line:no-any
                this.context.dynamicDataProvider, (function () {
                    _this._dynamicPropertyRefresh();
                }).bind(this));
                newDynamicProperty.setValue(newValue);
                newValue = newDynamicProperty;
            }
            this._updateProperty(propertyPath, newValue);
            this.onPropertyPaneFieldChanged(propertyPath, oldValue, newValue);
            this._afterPropertyUpdated(!this.disableReactivePropertyChanges);
        }
    };
    /**
     * Internal API which is invoked when one of the predefined configuration events
     * (defined in `PropertyPaneLifeCycleEvent` enum.) is triggered.
     *
     * See PropertyPaneLifeCycleEvent for more details on the event definitions.
     *
     * @param event - Type of PropertyPaneLifeCycleEvent.
     * @param isOrWillPaneOpen - Indicates whether the pane is already open to configure or
     *  will open now, to be configured.
     *
     * @internal
     */
    BaseWebPart.prototype._onPropertyPaneLifeCycleEvent = function (event) {
        var _this = this;
        // Invoke the callback so that the host can handle the property pane life cycle event.
        if (this.context.host.propertyPaneLifeCycleEventCallback) {
            this.context.host.propertyPaneLifeCycleEventCallback(event, {
                webPartData: this._internalSerialize(),
                isPropertyPaneReactive: this._isPropertyPaneReactive()
            });
        }
        switch (event) {
            case 'ConfigurationStart':
                this._loadPropertyPaneResources()
                    .then(function () { return _this.onPropertyPaneConfigurationStart(); })
                    .catch(function (e) {
                    return _TraceLogger.logVerboseData({ source: _this._baseLogSource, message: e.message });
                });
                break;
            case 'ConfigurationComplete':
                // Make sure we discard any backed up properties in the non-reactive mode.
                if (this.disableReactivePropertyChanges && this._backupProperties) {
                    // resetting the properties bag.
                    this._properties = this._backupProperties;
                    this._backupProperties = undefined;
                }
                this.onPropertyPaneConfigurationComplete();
                break;
            case 'ApplyClicked':
                // Updating the _backUpProperties with new set of properties.
                this._backupProperties = this.properties;
                this.onAfterPropertyPaneChangesApplied();
                this._afterPropertyUpdated(true);
                break;
        }
    };
    /**
     * Indicates whether the property pane is reactive or not.
     *
     * @remarks
     * The default behavior is Reactive.
     *
     * Reactive implies that changes made in the PropertyPane are transmitted to the web part instantly and the user can
     * see instant updates. This helps the page creator get instant feedback and decide if they should keep the new
     * configuration changes or not.
     *
     * NonReactive implies that the configuration changes are transmitted to the web part only after "Apply" PropertyPane
     * button is clicked.
     *
     * @internal
     */
    BaseWebPart.prototype._isPropertyPaneReactive = function () {
        return !this.disableReactivePropertyChanges;
    };
    /**
     * Internal API to serialize the web part properties.
     *
     * @internal
     */
    BaseWebPart.prototype._internalSerialize = function () {
        var _this = this;
        var data; // tslint:disable-line:no-any
        executeAndReThrow(function () {
            _this.onBeforeSerialize();
            var propertiesJson = JSON.stringify(_this.properties);
            // Only log edit, if properties have changed and it haven't been logged.
            if (!_this._hasEditLogged && _this._initPropertiesSnapshot !== propertiesJson) {
                var isInternal = !!_this.context.manifest.isInternal;
                var logEntry = new _LogEntry(_this._baseLogSource.id, 'WebPartEdited', _LogType.Event, {
                    alias: _this.context.manifest.alias,
                    isInternal: isInternal.toString()
                });
                _EngagementLogger.logEventWithLogEntry(logEntry);
                _this._hasEditLogged = true;
            }
            var serializedData = _this._serialize();
            Validate.isNotNullOrUndefined(serializedData.dataVersion, 'serialized data version');
            // Avoid doing extra work if we know there is no dynamic data
            if (propertiesJson && propertiesJson.indexOf(DynamicProperty._TYPE_NAME) !== -1) {
                _this._serializeDynamicData(serializedData);
            }
            data = {
                // The serialized data wrapped by the framework
                id: _this.context.manifest.id,
                instanceId: _this.context.instanceId,
                title: _this.title,
                description: _this.description,
                // The serialized data provided by the web part
                serverProcessedContent: serializedData.serverProcessedContent,
                dynamicDataPaths: serializedData.dynamicDataPaths,
                dynamicDataValues: serializedData.dynamicDataValues,
                dataVersion: serializedData.dataVersion.toString(),
                properties: serializedData.properties
            };
        }, SPWebPartError.create(SPWebPartErrorCode.SerializationFailed, this.context.webPartTag), this._baseLogSource);
        return data;
    };
    /**
     * Internal API to dispose the web part.
     *
     * See onDispose for more details.
     *
     * @internal
     */
    BaseWebPart.prototype._internalDispose = function () {
        this._disposeDynamicPropertiesIfRequired();
        _super.prototype.dispose.call(this);
    };
    /**
     * Internal API triggered upon a resize of the DOM window's viewport
     *
     * @internal
     */
    BaseWebPart.prototype._internalOnAfterResize = function () {
        /* EMPTY BLOCK */
    };
    /**
     * Internal API to update the web part data.
     *
     * !!!WARNING!!! updating the web part data can be risky. If you end up updating the web part properties
     *  to an invalid format, this could cause the web part to persist invalid data format.
     *
     * @internal
     */
    BaseWebPart.prototype._internalSetWebPartData = function (webPartData) {
        // tslint:disable-line:no-unused-variable
        var oldProperties = this.properties;
        this._internalDeserialize(webPartData);
        this.onAfterPropertiesUpdatedExternally(oldProperties);
    };
    /**
     * Internal API to switch the web part's display mode. This API updates the display mode and then re-renders the web
     * part in the new mode.
     * @internal
     */
    BaseWebPart.prototype._internalSetDisplayMode = function (newDisplayMode) {
        if (this._displayMode !== newDisplayMode) {
            var oldDisplayMode = this._displayMode;
            this._displayMode = newDisplayMode;
            this.onDisplayModeChanged(oldDisplayMode);
        }
    };
    /**
     * Internal API to set the dirty bit on the web part host if the web part properties have changed.
     * @internal
     */
    BaseWebPart.prototype._internalSetDirtyBit = function () {
        // This method could get invoked in classic pages in read mode also. Just ignore the call.
        if (this.displayMode === DisplayMode.Read) {
            return;
        }
        var serializedState = this._internalSerialize();
        var newState = JSON.stringify(serializedState);
        // Don't set dirty bit the first time because the Canvas
        // would have done it when the webpart got added.
        if (!this._previousState) {
            this._previousState = newState;
        }
        else if (this._previousState !== newState && this.context.host.setDirty) {
            this.context.host.setDirty(this.context.instanceId, serializedState);
            this._previousState = newState;
        }
    };
    /**
     * This is the initial entry point, which is called by the `ClientSideWebPartManager` immediately
     * after the web part is constructed.  The initialization contract is internal.
     *
     * @param addedFromPersistedData - Tells the Web Part it will need to reinstate some properties
     * from server processed content (see BaseWebPart._reInstateServerProcessedData)
     *
     * @internal
     */
    BaseWebPart.prototype._internalInitialize = function (webPartContext, addedFromPersistedData, mode) {
        Validate.isNotNullOrUndefined(webPartContext, 'webPartContext');
        /* tslint:enable:use-named-parameter */
        deepFreeze(webPartContext.manifest);
        _super.prototype._initializeContext.call(this, webPartContext);
        // Bind the callbacks
        this.onDispose = this.onDispose.bind(this);
        this.onPropertyPaneRendered = this.onPropertyPaneRendered.bind(this);
        this._initialized = true;
        // Set the display mode of the web part
        this._displayMode = mode;
        // This is important for reinstating properties the way they were
        // before serialization. It must be set before any deserialization occurs.
        this._renderedFromPersistedData = addedFromPersistedData;
        if (!this._renderedFromPersistedData) {
            var isInternal = this.context.manifest.isInternal || false;
            var logEntry = new _LogEntry(this._baseLogSource.id, 'WebPartAdded', _LogType.Event, {
                alias: this.context.manifest.alias,
                isInternal: isInternal.toString()
            });
            _EngagementLogger.logEventWithLogEntry(logEntry);
        }
    };
    /**
     * Internal base implementation of the web part data deserialization.
     *
     * @param data - web part data
     *
     * @internal
     */
    BaseWebPart.prototype._internalDeserialize = function (data) {
        if (data) {
            if (data.title) {
                this._title = data.title;
            }
            if (data.description) {
                this._description = data.description;
            }
            if (data.iconImageUrl) {
                this._iconImageUrl = data.iconImageUrl;
            }
            // For backward-compatibality, convert non-string versions to '1.0'
            // Because we used to serialize the version object in the early versions
            if (typeof data.dataVersion !== 'string') {
                data.dataVersion = '1.0';
            }
            // Note: it is okay not to create clones here
            var deserializedData = {
                properties: data.properties,
                serverProcessedContent: data.serverProcessedContent,
                dynamicDataPaths: data.dynamicDataPaths,
                dynamicDataValues: data.dynamicDataValues,
                dataVersion: Version.tryParse(data.dataVersion)
            };
            this._deserializeDynamicData(deserializedData);
            // Note: Initialization of DynamicProperties should always happen after the
            // properties are deserialized. This ensures that all the properties have proper
            // values constructed with types, if required.
            this._initializeDynamicPropertiesIfRequired(deserializedData.properties);
            /* tslint:disable-next-line:no-any */
            var deserializedPropsObject = this._reInstateServerProcessedData(deserializedData.properties, deserializedData.serverProcessedContent);
            // Give the web part an opportunity to deserialize the properties. If the web part
            // returns a valid property bag, use it as is else perform default deserialization.
            var fixedProps = this.onAfterDeserialize(deserializedPropsObject, deserializedData.dataVersion);
            // Cache the properties data just deserialized.
            this._initPropertiesSnapshot = JSON.stringify(deserializedPropsObject);
            if (!fixedProps) {
                throw SPWebPartError.create(SPWebPartErrorCode.OnAfterDeserializeReturnedNull, this.context.webPartTag);
            }
            this._properties = fixedProps;
        }
    };
    /**
     * This event method is called when the web part is initialized.
     * virtual
     *
     * @remarks
     * This API should be overridden to perform long running operations e.g. data fetching from a remote service before
     * the initial rendering of the web part. The loading indicator is displayed during the lifetime of this method.
     * This API is called only once during the lifecycle of a web part.
     */
    BaseWebPart.prototype.onInit = function () {
        // Return a resolved promise by default
        return Promise.resolve(undefined);
    };
    /**
     * This event method is called when the display mode of a web part is changed.
     * virtual
     *
     * @remarks
     * The default implementation of this API calls
     * the web part render method to re-render the web part with the new display mode. If a web part developer does not
     * want a full re-render to happen on display mode change, they can override this API and perform specific updates
     * to the web part DOM to switch its display mode.
     *
     * @remarks
     * If the web part is initialized or re-initialized in a different display mode then this
     * lifecycle method is not called.
     *
     * @param oldDisplayMode - The old display mode.
     */
    BaseWebPart.prototype.onDisplayModeChanged = function (oldDisplayMode) {
        /* EMPTY BLOCK */
    };
    /**
     * This event method is called before the web part is serialized.
     * virtual
     *
     * @remarks
     * The default implementation is a no-op. The serialization
     * process serializes the web part property bag i.e. this.properties. This API gives the web part a chance to
     * update it's property bag before the serialization happens. Some web part's may keep their state other objects
     * or even in the DOM. If a web part needs to persist some of that state, it needs to override this API and update
     * the web part property bag to the latest state. If a web part updates the property bag with invalid property
     * values, those will get persisted. So that should be avoided. The web part property bag should always contain
     * valid property values.
     */
    BaseWebPart.prototype.onBeforeSerialize = function () {
        /* EMPTY BLOCK */
    };
    /**
     * This API is called after the web part is deserialized to an object, right before the property bag is populated.
     * virtual
     *
     * @remarks
     * The default implementation is a no-op. A web part developer can override this API if the deserialized object
     * does not fully reflect the initial state of the property bag. This gives the web part developer a chance to
     * populate the property bag right after the data is deserialized to an object.
     *
     * An important scenario to use deserialize is upgrading. An upgraded web part may load the data
     * that was serialized by an older version of the web part that supported a different schema of the property bag,
     * resulting the deserialized object to be incosistent with the current schema of the property bag. The developer
     * can use `onAfterDeserialize` to check the dataVersion and fix the property bag.
     *
     * @param deserializedObject - The object deserialized from the stored data. Note that the schema of  this object
     * is not necessarily consistent with the current property bag, because the serialization could have been done by
     * an older version of the web part
     * @param dataVersion - The data version of the stored data being deserialized. You can use this value to determine
     * if the data was serialized by an older web part. Web parts can define their data version by overriding the
     * dataVersion property.
     *
     * @returns The property bag of the web part
     */
    /* tslint:disable-next-line:no-any */
    BaseWebPart.prototype.onAfterDeserialize = function (deserializedObject, dataVersion) {
        return deserializedObject;
    };
    /**
     * This API enables asynchronous loading of property pane related resources of the web part.
     * @virtual
     *
     * @remarks
     * If not overridden by the web part, base web part resolves the promise immediately.
     *
     * This method is called before any property pane APIs are called.
     * Other property pane APIs cannot be called until this promise is resolved.
     * No other property pane related events are raised except 'PropertyPaneConfigurationComplete'.
     *
     * 'PropertyPaneConfigurationComplete' event can be raised to clean up any pending resources
     * including 'loadPropertyPaneResources' promise.
     */
    BaseWebPart.prototype.loadPropertyPaneResources = function () {
        return this._emptyResolvedPromise;
    };
    /**
     * This API is used to ger the configuration to build the property pane for the web part. If the web part wants
     * to use the PropertyPane for configuration, this API needs to be overridden and the web part needs to return
     * the configuration for the PropertyPane.
     *
     * This API is not invoked until the 'loadPropertyPaneResources' promise is resolved.
     *
     * See IPropertyPane and other PropertyPane integration wiki documentation for more details.
     * virtual
     */
    BaseWebPart.prototype.getPropertyPaneConfiguration = function () {
        return {
            pages: []
        };
    };
    /**
     * This API is used to get the configuration to build the property pane for details.
     * If the web part wants to use the PropertyPane for details configuration,
     * this API needs to be overridden and the web part needs to return the configuration for details.
     *
     * This API is not invoked until the 'loadPropertyPaneResources' promise is resolved.
     *
     * See IPropertyPane and other PropertyPane integration wiki documentation for more details.
     * virtual
     *
     * @param context - additional context passed to getPropertyPaneDetailsConfiguration
     *
     * @alpha
     */
    // tslint:disable-next-line:no-any
    BaseWebPart.prototype.getDetailsPaneConfiguration = function (context) {
        return {
            pages: []
        };
    };
    /**
     * This API should be used to refresh the contents of the PropertyPane.
     * virtual
     *
     * @remarks
     * This API is called at the end of the web part lifecycle on a page. It should be used to dispose any local
     * resources (i.e. DOM elements) that the web part is holding onto. This API is expected to be called in scenarios
     * like page navigation i.e. the host is transitioning from one page to another and disposes the page that is being
     * transitioned out.
     */
    BaseWebPart.prototype.onDispose = function () {
        /* EMPTY BLOCK */
    };
    /**
     * This API is invoked after updating the new value of the property in the property bag when the PropertyPane
     * is being used in Reactive mode.
     * virtual
     *
     * @param propertyPath - JSON path of the property in the property bag.
     *  In the case of custom field, if no target property is provided then a custom value is assigned,
     *  which will be in the form of `__CustomField_<key provided when the custom field is created>`.
     * @param oldValue - Old value of the property.
     *  This value could be undefined/empty in the case of custom field.
     * @param newValue - New value of the property.
     *  This value could be undefined/empty in the case of custom field.
     */
    /* tslint:disable-next-line:no-any */
    BaseWebPart.prototype.onPropertyPaneFieldChanged = function (propertyPath, oldValue, newValue) {
        /* EMPTY BLOCK */
    };
    /**
     * This event method is invoked when the configuration starts on the PropertyPane.
     * virtual
     *
     * @remarks
     * This event method is invoked in the following cases:
     *
     *  - When the PropertyPane is opened.
     *
     *  - When the user switches web parts then the new web part gets this event.
     */
    BaseWebPart.prototype.onPropertyPaneConfigurationStart = function () {
        /* EMPTY BLOCK */
    };
    /**
     * This API is invoked when the configuration is completed on the PropertyPane.
     * virtual
     *
     * @remarks
     * This event method is invoked in the following cases:
     *
     *  - When the CONFIGURATION_COMPLETE_TIMEOUT((currently the value is 5 secs) elapses after the last change.
     *
     *  - When user clicks the "X" (close) button before the CONFIGURATION_COMPLETE_TIMEOUT elapses.
     *
     *  - When user clicks the 'Apply' button before the CONFIGURATION_COMPLETE_TIMEOUT elapses.
     *
     *  - When the user switches web parts then the current web part gets this event.
     */
    BaseWebPart.prototype.onPropertyPaneConfigurationComplete = function () {
        /* EMPTY BLOCK */
    };
    /**
     * This API is invoked after the changes made on the PropertyPane are applied when the PropertyPane is used in
     * Non-Reactive mode. This API is not invoked when the PropertyPane is used in Reactive mode.
     * virtual
     */
    BaseWebPart.prototype.onAfterPropertyPaneChangesApplied = function () {
        /* EMPTY BLOCK */
    };
    /**
     * This API is invoked when the PropertyPane is rendered.
     * virtual
     * @privateRemarks
     * From framework standpoint, we do not want to allow this event handler to be passed in, and trigger it.
     * This api should be deprecated and then removed as part of refactoring.
     */
    BaseWebPart.prototype.onPropertyPaneRendered = function () {
        /* EMPTY BLOCK */
    };
    /**
     * This API is invoked after properties are updated by sources other than the property pane or the web part host.
     * virtual
     *
     * @alpha
     * @param prevProperties - The web part properties before the update.
     */
    BaseWebPart.prototype.onAfterPropertiesUpdatedExternally = function (prevProperties) {
        return this._refresh();
    };
    /**
     * @internal
     */
    BaseWebPart.prototype._internalGetData = function () {
        return this._emptyResolvedPromise;
    };
    /**
     * Gets default accessible title in the format `"<Web part name> web part"`, such as "Image web part".
     * Note: pulled into own method because TypeScript doesn't allow derived classes to call super protected properties.
     *
     * @internal
     */
    BaseWebPart.prototype._getDefaultAccessibleTitle = function () {
        return Text.format(strings.GenericAccessibleLabelTemplate, this.title);
    };
    /**
     * This method consumes the properties object from the serialized data and re-applies
     * the field values from the serverProcessedContent. This process will result in the
     * properties bag as it was when the serialization happened.
     */
    /* tslint:disable:no-any */
    BaseWebPart.prototype._reInstateServerProcessedData = function (deserializedProperties, serverProcessedContent) {
        /* tslint:enable:no-any */
        var _this = this;
        if (!deserializedProperties) {
            return {};
        }
        /* tslint:disable-next-line:no-any */
        var fixedProperties = deserializedProperties;
        if (!this._renderedFromPersistedData) {
            return fixedProperties;
        }
        // @privateRemarks Clear out the properties with isHtmlString metadata for security reasons. We only want to
        // propagate values from the serverProcessed content as they are security sanitized by the server. Note, there is a
        // scenario when an end user can update the list item with whatever data they like. In that case, they can
        // eliminate the serverProcessed content and that can cause a potential security hole. Hence, we always want
        // clear out the property values that have isHtmlString metadata.
        this._forEachPropertyWithMetaData(function (propPath, metadata) {
            // This is a temporary hack to make sure that the webparts published using the Mobile app keep rendering.
            // Currently, for those pages, the DocumentEmbedWebPart does not have HTMLProperties pupulated. Hence,
            // we are doing this work around to not unset the property bag.
            // (SPPPLAT VSO#289988) tracks removal of this code.
            if (_this.context.manifest.id !== 'b7dd04e1-19ce-4b24-9132-b60a1c2b910d' && metadata.isHtmlString) {
                lodash.set(fixedProperties, propPath, undefined);
            }
        }, fixedProperties);
        if (serverProcessedContent) {
            // Re-instate the server processed values in the specified path in the property bag.
            // There is a change that the new shape of the property bag is different. But the
            // the purpose of the inbuilt deserialization is to provide the same properties object
            // back to the web part that has the same shape as when the serialization happened.
            var htmlMaps = [
                serverProcessedContent.htmlStrings,
                serverProcessedContent.searchablePlainTexts,
                serverProcessedContent.imageSources,
                serverProcessedContent.links,
                serverProcessedContent.componentDependencies
            ];
            for (var _i = 0, htmlMaps_1 = htmlMaps; _i < htmlMaps_1.length; _i++) {
                var htmlMap = htmlMaps_1[_i];
                if (htmlMap) {
                    for (var propPath in htmlMap) {
                        /* tslint:disable-line:forin */
                        // WARNING: This is critical code. Please do not modify without fully understanding the data pipeline
                        var value = htmlMap[propPath];
                        if (typeof value === 'string') {
                            lodash.set(fixedProperties, propPath, value);
                        }
                    }
                }
            }
        }
        return fixedProperties;
    };
    /**
     * Iterates and validates each metadata property before calling metadata processor.
     *
     * @param metadataProcessor - Callback handler to to process validated metadata.
     * @param properties - Optional Properies to process instead of default this.properties
     * @param iteration - Current iteration in case path is being iterated based on wildcard *
     */
    BaseWebPart.prototype._forEachPropertyWithMetaData = function (metadataProcessor, properties /* tslint:disable-line:no-any */) {
        if (this.propertiesMetadata) {
            var _loop_1 = function (propPath) {
                /* tslint:disable-line:forin */
                var metadata = this_1.propertiesMetadata[propPath];
                this_1._validateAndIteratePath(propPath, properties || this_1.properties, function (fixedPropPath, index) {
                    metadataProcessor(fixedPropPath, metadata, index);
                });
            };
            var this_1 = this;
            for (var propPath in this.propertiesMetadata) {
                _loop_1(propPath);
            }
        }
    };
    /**
     * Validates path and iterate over one or multiple wildcard paths
     *
     * @param propPath - Original property path provided in metadata
     * @param properties - Properties to look for the given path.
     * @param propertyPathHandler - Handler to process validated and fixed path
     */
    BaseWebPart.prototype._validateAndIteratePath = function (propPath, properties /* tslint:disable-line:no-any */, propertyPathHandler) {
        var wildcardCount = (propPath.match(/\*/g) || []).length;
        if (wildcardCount > 1) {
            // Skip if there are more than one asterisks in the path (not supported)
            console.warn("Invalid property path: Multiple wildcards are not supported in property paths.\nEntry with path '" + propPath + "' got ignored in the properties metadata.");
            return;
        }
        else if (wildcardCount === 1) {
            var index = propPath.indexOf('[*]');
            if (index < -1) {
                console.warn("Invalid property path: Wildcards are only supported inside brackets to select array\nindices as in 'foo[*].bar'. Entry with path '" + propPath + "' got ignored in the properties metadata.");
                // Skip if the wildcard is not used for an array (not supported)
                return;
            }
            else {
                // Handle the array wildcard by generating each individual property path
                var arrayPath = propPath.substr(0, index);
                /* tslint:disable-next-line:no-any */
                var arrayInstance = lodash.get(properties, arrayPath);
                if (!arrayInstance) {
                    console.warn("Invalid property path: Could not find an array named '" + arrayPath + "' in the properties.\nEntry with path '" + propPath + "' got ignored in the properties metadata.");
                    return;
                }
                else {
                    for (var i = 0; i < arrayInstance.length; i++) {
                        var fixedPropPath = propPath.replace('*', "" + i);
                        propertyPathHandler(fixedPropPath, i);
                    }
                }
            }
        }
        else {
            propertyPathHandler(propPath);
        }
    };
    /**
     * Iterates and validates each custom property path before calling custom metadata processor.
     *
     * @param metadata - Web part property metadata containing.
     * @param iteration - Current iteration in case path is being iterated based on wildcard *
     * @param customMetadataProcessor - Responsible for processing custom metadata properties.
     */
    BaseWebPart.prototype._foreachCustomMetadata = function (metadata, iteration, customMetadataProcessor, properties /* tslint:disable-line:no-any */) {
        if (metadata && metadata.customMetadata) {
            var _loop_2 = function (propName) {
                /* tslint:disable-line:forin */
                var propPath = metadata.customMetadata[propName];
                if (iteration !== undefined && propPath.indexOf('*') !== -1) {
                    // Custom metadata should be resolved with current iteration of wildcard
                    propPath = propPath.replace('*', iteration.toString());
                }
                this_2._validateAndIteratePath(propPath, properties || this_2.properties, function (fixedPropPath, customIteration) {
                    // Custom metadata should be resolved without iteration
                    if (customIteration === undefined && metadata.customMetadata) {
                        customMetadataProcessor(fixedPropPath, propName);
                    }
                });
            };
            var this_2 = this;
            for (var propName in metadata.customMetadata) {
                _loop_2(propName);
            }
        }
    };
    /**
     * Operations to be done after the property bag is updated.
     *
     * @param shouldRefresh - Indicating whether web part needs to be shouldRefresh or not.
     */
    BaseWebPart.prototype._afterPropertyUpdated = function (shouldRefresh) {
        this._internalSetDirtyBit();
        if (shouldRefresh) {
            this._refresh();
        }
    };
    /**
     * Fixes up a property pane configuration to use dynamic data. This happens in-place.
     * The fix-up consists on adding the necessary hooks to the web part that are required,
     * like the dynamic data provider, the render function and the object it refers to.
     *
     * @param configuration - Property pane configuration to fix up.
     */
    BaseWebPart.prototype._fixUpDynamicDataConfiguration = function (configuration) {
        var _this = this;
        configuration.pages.forEach(function (page) {
            page.groups.forEach(function (group) {
                // Checking if the group is PropertyPaneConditionalGroup, if yes then extracting
                // the required group from it.
                if ('primaryGroup' in group) {
                    var _a = group, primaryGroup = _a.primaryGroup, secondaryGroup = _a.secondaryGroup, showSecondaryGroup = _a.showSecondaryGroup;
                    group = showSecondaryGroup ? secondaryGroup : primaryGroup;
                }
                group = group;
                group.groupFields.forEach(function (field) {
                    if (field.type === PropertyPaneFieldType.DynamicTextField) {
                        var props = field.properties;
                        props.dynamicDataProvider = _this.context.dynamicDataProvider;
                        props.changeCallback = (function () {
                            _this._dynamicPropertyRefresh();
                        }).bind(_this);
                    }
                });
            });
        });
    };
    /**
     * The serializer for the exposed part of the web part data
     *
     * @privateRemarks
     * This serialize API is a public candidate for post-GA (after removing the input parameter)
     */
    BaseWebPart.prototype._serialize = function () {
        var _this = this;
        var serverProcessedContent = {
            htmlStrings: {},
            searchablePlainTexts: {},
            imageSources: {},
            links: {}
        };
        // Since we will end up mutating the property bag during serialization, we need to clone it.
        var properties = this._cloneProperties(this.persistedProperties);
        this._forEachPropertyWithMetaData(function (propPath, metadata, iteration) {
            // Remove fields with shouldNotPersist metadata
            if (metadata.shouldNotPersist) {
                lodash.set(properties, propPath, undefined);
            }
            // Use the property path as the key in server-processed content maps
            var key = propPath;
            // WARNING: This is critical code. Please do not modify without fully understanding the data pipeline
            var value = lodash.get(properties, propPath);
            // Skip if the property is non-string or undefined
            if (serverProcessedContent && typeof value === 'string' && value) {
                if (serverProcessedContent.htmlStrings && metadata.isHtmlString) {
                    serverProcessedContent.htmlStrings[key] = value;
                }
                else if (serverProcessedContent.searchablePlainTexts && metadata.isSearchablePlainText) {
                    serverProcessedContent.searchablePlainTexts[key] = value;
                }
                else if (serverProcessedContent.links && metadata.isLink) {
                    serverProcessedContent.links[key] = value;
                }
                else if (serverProcessedContent.imageSources && metadata.isImageSource) {
                    serverProcessedContent.imageSources[key] = value;
                }
                else if (metadata.isComponentDependency) {
                    if (!serverProcessedContent.componentDependencies) {
                        serverProcessedContent.componentDependencies = {};
                    }
                    serverProcessedContent.componentDependencies[key] = value;
                }
                if (metadata.customMetadata) {
                    _this._internalSerializeCustomMetadata(key, metadata, properties, serverProcessedContent, iteration);
                }
                // Unset the extracted property to avoid duplication
                lodash.set(properties, propPath, undefined);
            }
        });
        return {
            dataVersion: this.dataVersion,
            properties: properties,
            serverProcessedContent: serverProcessedContent
        };
    };
    /**
     * Serialize custom metadata as specified by web part
     *
     * @param propertyPath - Property path used as key of the serialized custom metadata
     * @param metadata - Web part property metadata
     * @param properties - Web part persisted properties
     * @param serverProcessedContent - Server processed data's custom metadata is updated
     * @param iteration - Current iteration in case path is being iterated based on wildcard *
     */
    BaseWebPart.prototype._internalSerializeCustomMetadata = function (propertyPath, metadata, properties, serverProcessedContent, iteration) {
        // Build custom metadata for the given property path
        var customMetadata = {};
        this._foreachCustomMetadata(metadata, iteration, function (customPropertyPath, customPropertyName) {
            var customValue = lodash.get(properties, customPropertyPath);
            if (serverProcessedContent && customValue !== undefined) {
                // Insert custom metadata key and value
                customMetadata[customPropertyName] = customValue;
            }
        });
        if (!serverProcessedContent.customMetadata) {
            serverProcessedContent.customMetadata = {};
        }
        // Store serialized custom metadata for the given the property path.
        serverProcessedContent.customMetadata[propertyPath] = customMetadata;
    };
    /**
     * This function serializes the Dynamic Data objects from the web part properties into the serialized web part data.
     *
     * If there is a property "myDynamicProperty" in the property bag that points to `"PageContext:user"`,
     * the serialized data is updated as the following:
     * ```
     * serializedData = {
     *   dynamicDataPaths: {
     *     "myDynamicProperty": "PageContext:user"
     *   }
     * }
     * ```
     */
    BaseWebPart.prototype._serializeDynamicData = function (serializedData) {
        var props = serializedData.properties;
        var dynamicDataPaths = {};
        var dynamicDataValues = {}; // tslint:disable-line:no-any
        var key = lodash.findKey(props, { __type: DynamicProperty._TYPE_NAME });
        while (key) {
            var dynamicDataReference = lodash.get(props, key + '.reference');
            var dynamicDataValue = lodash.get(props, key + '.value');
            if (dynamicDataReference) {
                dynamicDataPaths[key] = dynamicDataReference;
                lodash.unset(props, key);
            }
            else if (dynamicDataValue !== undefined) {
                // Explicitly checking for 'undefined' because, empty string is a valid dynamicDataValue.
                dynamicDataValues[key] = dynamicDataValue;
                lodash.unset(props, key);
            }
            else {
                throw new Error('Dynamic Data is misconfigured');
            }
            key = lodash.findKey(props, { __type: DynamicProperty._TYPE_NAME });
        }
        serializedData.dynamicDataPaths = dynamicDataPaths;
        serializedData.dynamicDataValues = dynamicDataValues;
    };
    /**
     * This function deserializes the Dynamic Data objects from serialized web part data into web part properties.
     *
     * If the serializedData has a "dynamicDataPaths" or "dynamicDataValues" property,
     * it creates DynamicData objects for it.
     *
     * Example:
     * ```
     * serializedData = {
     *   dynamicDataPaths: {
     *     "myDynamicProperty": "PageContext:user"
     *   }
     * }
     * ```
     *
     * This will create a property "myDynamicProperty" in the web parts properties, with a new DynamicData object that
     * points at "PageContext:user"
     */
    BaseWebPart.prototype._deserializeDynamicData = function (data) {
        var _this = this;
        if (data.dynamicDataPaths) {
            for (var path in data.dynamicDataPaths) {
                if (data.dynamicDataPaths.hasOwnProperty(path)) {
                    var dynamicProperty = new DynamicProperty(// tslint:disable-line:no-any
                    this.context.dynamicDataProvider, (function () {
                        _this._dynamicPropertyRefresh();
                    }).bind(this));
                    dynamicProperty.setReference(data.dynamicDataPaths[path]);
                    lodash.set(data.properties, path, dynamicProperty);
                }
            }
        }
        if (data.dynamicDataValues) {
            for (var path in data.dynamicDataValues) {
                if (data.dynamicDataValues.hasOwnProperty(path)) {
                    var dynamicProperty = new DynamicProperty(// tslint:disable-line:no-any
                    this.context.dynamicDataProvider, (function () {
                        _this._dynamicPropertyRefresh();
                    }).bind(this));
                    dynamicProperty.setValue(data.dynamicDataValues[path]);
                    lodash.set(data.properties, path, dynamicProperty);
                }
            }
        }
    };
    /**
     * For each property in the serialized properties of the web part, we check if the property is declared
     * as dynamicProperty in the properties metadata of the web part.
     *  - If yes, then we check
     *    - if the value of it is an instance of DynamicProperty
     *      - If No, then we create and assign a DynamicProperty with the type given specified in the
     *        'dynamicPropertyType' property
     *      - else, it's a no-op.
     *  - If no, then it's a no-op
     *
     * While creating the DynamicProperty, we use the pre-configured value associated with that property from
     * the web part's property bag as the default value.
     * @param deSerializedProperties - deserialized properties of the web part.
     */
    // tslint:disable-next-line:no-any
    BaseWebPart.prototype._initializeDynamicPropertiesIfRequired = function (deSerializedProperties) {
        var _this = this;
        var defaultDynamicPropertyValues = new Map([
            ['boolean', false],
            ['number', 0],
            ['string', ''],
            ['array', []],
            ['object', {}]
        ]);
        this._forEachPropertyWithMetaData(function (propPath, metadata) {
            if (metadata.dynamicPropertyType) {
                var propValue = lodash.get(deSerializedProperties, propPath); /* tslint:disable-line:no-any */
                if (!(propValue instanceof DynamicProperty)) {
                    var dynamicProperty = void 0; /* tslint:disable-line:no-any */
                    switch (metadata.dynamicPropertyType) {
                        case 'boolean':
                            dynamicProperty = new DynamicProperty(_this.context.dynamicDataProvider, (function () {
                                _this._dynamicPropertyRefresh();
                            }).bind(_this));
                            break;
                        case 'number':
                            dynamicProperty = new DynamicProperty(_this.context.dynamicDataProvider, (function () {
                                _this._dynamicPropertyRefresh();
                            }).bind(_this));
                            break;
                        case 'string':
                            dynamicProperty = new DynamicProperty(_this.context.dynamicDataProvider, (function () {
                                _this._dynamicPropertyRefresh();
                            }).bind(_this));
                            break;
                        case 'array':
                            dynamicProperty = new DynamicProperty(_this.context.dynamicDataProvider, (function () {
                                _this._dynamicPropertyRefresh();
                            }).bind(_this));
                            break;
                        case 'object':
                            dynamicProperty = new DynamicProperty(_this.context.dynamicDataProvider, (function () {
                                _this._dynamicPropertyRefresh();
                            }).bind(_this));
                            break;
                        default:
                            dynamicProperty = new DynamicProperty(// tslint:disable-line:no-any
                            _this.context.dynamicDataProvider, (function () {
                                _this._dynamicPropertyRefresh();
                            }).bind(_this));
                            break;
                    }
                    propValue = propValue || defaultDynamicPropertyValues.get(metadata.dynamicPropertyType);
                    dynamicProperty.setValue(propValue);
                    lodash.set(deSerializedProperties, propPath, dynamicProperty);
                }
            }
        }, deSerializedProperties);
    };
    /**
     * Disposing the dynamic properties, for those which are declared as dynamic properties.
     *
     * @privateRemarks
     * We are disposing only the declared dynamic properties because we created them on behalf of
     * the web part and hence it is our responsiblity to clean them.
     */
    BaseWebPart.prototype._disposeDynamicPropertiesIfRequired = function () {
        var _this = this;
        this._forEachPropertyWithMetaData(function (propPath, metadata) {
            if (metadata.dynamicPropertyType) {
                // tslint:disable-next-line:no-any
                var propValue = lodash.get(_this.persistedProperties, propPath);
                if (propValue instanceof DynamicProperty) {
                    propValue.dispose();
                }
            }
        }, this.persistedProperties);
    };
    /**
     * Update the web part property if it is in the property bag.
     *
     * @param propertyPath - property path as expected by lodash update (https://lodash.com/docs#update).
     *   (e.g. 'o.a.b', 'o[0].a.b[1].c'). These paths are similar to those in the JSONPath spec described by
     *   Stefan Goessner at (http://goessner.net/articles/JsonPath/). Currently we plan to use lodash.get, has
     *   and update APIs which support paths. Some day we may migrate to using actual JSONPath.js. But that
     *   should not be an issue because the path formatting conventions are same in lodash and JSONPath.
     * @param newValue - new value entered by the user for the associated target property
     */
    // tslint:disable-next-line:no-any
    BaseWebPart.prototype._updateProperty = function (propertyPath, newValue) {
        // should we check if this is a valid property path. For now maybe not.
        lodash.update(this.properties, propertyPath, function () { return newValue; });
    };
    /**
     * Using 'cloneDeepWith' because the web part properties bag will now serialize the
     * dynamic properties as well. One of the building blocks of these properties are dataProviders,
     * which when serialized will result in 'Maximum call stack size exceeded' based on what kind of
     * sources they hold references to.
     * Hence using cloneDeepWith, which lets us handle the special cases and in this case if the property
     * in question is a 'DynamicProperty' and we call '_cloneDeep' api on the dynamicProperty.
     */
    BaseWebPart.prototype._cloneProperties = function (propertiesToClone) {
        return lodash.cloneDeepWith(propertiesToClone, function (prop) {
            if (prop instanceof DynamicProperty) {
                return prop._cloneDeep(prop); // tslint:disable-line:no-any
            }
        });
    };
    return BaseWebPart;
}(BaseComponent));
export default BaseWebPart;
//# sourceMappingURL=BaseWebPart.js.map