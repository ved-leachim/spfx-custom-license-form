import { AsyncSeriesHook } from 'tapable';
import { AsyncSeriesWaterfallHook } from 'tapable';
import { BlobService } from 'azure-storage';
import { EntityMarker } from '@rushstack/localization-plugin/lib/utilities/EntityMarker';
import { GenerateCssClassNameFunction } from '@microsoft/sp-css-loader';
import { HeftConfiguration } from '@rushstack/heft';
import { HeftSession } from '@rushstack/heft';
import { IClientSideComponentLoaderConfiguration } from '@microsoft/sp-module-interfaces';
import { IClientSideComponentManifest } from '@microsoft/sp-module-interfaces';
import { IHeftPlugin } from '@rushstack/heft';
import { ILocalizedPathModuleConfiguration } from '@microsoft/sp-module-interfaces';
import { ILocalizedString } from '@microsoft/sp-module-interfaces';
import { ILocalizedStrings } from '@rushstack/localization-plugin';
import { ILocalizedWebpackChunk } from '@rushstack/localization-plugin';
import { IModuleConfiguration } from '@microsoft/sp-module-interfaces';
import { IPackageJson } from '@rushstack/node-core-library';
import { LocalizationPlugin } from '@rushstack/localization-plugin';
import { SyncHook } from 'tapable';
import { SyncWaterfallHook } from 'tapable';
import { Terminal } from '@rushstack/node-core-library';
import * as webpack from 'webpack';

/**
 * @internal
 */
export declare class _ComponentNamePlugin implements webpack.Plugin {
    private _options;
    constructor(options: _IComponentNamePluginOptions);
    apply(compiler: webpack.Compiler): void;
}

/**
 * @internal
 */
export declare class _CumulativeManifestProcessor {
    private _options;
    private _discoveryCache;
    constructor(options: Partial<_ICumulativeManifestOptions> & _ICumulativeManifestEnvironmentOptions);
    /**
     * Ths function:
     *  1. discovers all packages referenced in package.json
     *  2a. looks for a file in each discovered project's temp folder called manifests.json
     *  2b. looks for <id>.manifest.json files in the dist folder
     *  3. keeps a record of all of the manifests discovered in the referenced projects, and resolves duplicates by
     *      taking the newest file
     *  4. generates new base URLs for each of the referenced projects' manifests to make them valid when "gulp serve"
     *      is run from this current project's directory
     *  5. collects all of these discovered manifests and the debugManifests parameter and generates an array of all
     *      manifests
     *  6. filters this array by the ignoreOutputManifestIds options
     *  7. drops a JSON file in the temp directory called manifests.json containing this array
     *  8. drops an initialization script in the temp directory called manifests.js that
     *      exports two functions. One that returns the array with the manifests' base URLs as fully-qualified, and the
     *      other with manifests' base URLs as relative to the page root.
     */
    generateCumulativeManifest(debugManifests: IClientSideComponentManifest[]): Promise<void>;
    reset(): void;
    discoverManifests(packagePath: string, forceSearchMode?: _DependencyDiscoveryMode, options?: _IDiscoverManifestsOptions): _IReferencedProjectMap;
    private _insertManifestIntoMap;
    private _doTemporaryManifestFixups;
    private _getTransformedManifest;
    private _resolvePackage;
}

declare const _default: SpfxHeftPlugin;
export default _default;

/**
 * @alpha
 */
export declare const DEFAULT_LOCALE: string;

/**
 * @internal
 */
export declare enum _DependencyDiscoveryMode {
    /**
     * Don't force a manifest search anywhere. Use the manifests.json file everywhere if it's found.
     */
    none = 0,
    /**
     * Don't force a manifest search in the first project, but use the manifests.json file in other packages.
     */
    shallow = 1,
    /**
     * Don't use the manifests.json file anywhere, and search every single package.
     */
    deep = 2,
    /**
     * Don't use the manifests.json file anywhere, but only recurse in packages where other manifests were found.
     */
    deepSparse = 3,
    /**
     * Don't use the manifests.json file anywhere, but only recurse in packages where other manifests were found,
     * except for the first project. Always recurse from the first project. This option is useful if it's uncertain
     * whether the first project has been built, but otherwise "deepSparse" is intended behavior.
     */
    deepSparseIgnoreFirstProject = 4
}

/**
 * Helper functions for dev-deploy.
 * @public
 */
export declare class DevDeployHelper {
    static getDefaultDeployConfig(): IDevDeployConfig;
    static deployFilesAsync(terminal: Terminal, deployConfig: IDevDeployConfig, deployData: IDevDeployData, deployPathsFunction?: (pathsToUpload: IDeployFile[]) => Promise<void>): Promise<void>;
}

/**
 * @public
 */
export declare class DevDeployHooks {
    /**
     * Initialize
     */
    readonly init: SyncHook<IDevDeployOptions>;
    /**
     * Perform any pre processing such as delete any existing deployment info json, clean up dist folder, etc.
     */
    readonly preProcess: SyncHook<void>;
    /**
     * Gets the files to be deployed to the CDN
     */
    readonly getFiles: AsyncSeriesWaterfallHook<IDevDeployData>;
    /**
     * Gets the name of the folder in the container into which files should be uploaded
     */
    readonly getContainerFolderName: SyncWaterfallHook<string>;
    /**
     * Gets the name of the Azure storage account
     */
    readonly getStorageAccountName: SyncWaterfallHook<string>;
    /**
     * Gets the name of the Azure storage account
     */
    readonly getStorageAccessKey: SyncWaterfallHook<string>;
    /**
     * Returns true if the deployment is in a prod environment
     */
    readonly isProd: SyncWaterfallHook<boolean>;
    /**
     * Perform any post processing, usually print the deploy link, save deployment info json, collect library files, etc.
     */
    readonly postProcess: AsyncSeriesHook<void>;
}

/**
 * Connects to the Azure Blob Storage service and returns a connection object
 *
 * @internal
 */
export declare function _ensureBlobService(account: string, accountKey: string): Promise<BlobService>;

/**
 * @internal
 */
export declare function _ensureContainer(terminal: Terminal, blobService: BlobService, containerName: string, containerOptions?: BlobService.CreateContainerOptions): Promise<BlobService>;

/**
 * @public
 */
export declare const FILE_LOADER_EXTENSIONS: string[];

/**
 * @internal
 */
export declare function _getFullHash(data: any): string;

/**
 * @internal
 */
export declare function _getVersionFromPackageJson(packageName: string): (projectRootPath: string) => string | undefined;

/**
 * @internal
 */
export declare interface _IAsyncOnlyDependenciesOptions {
    asyncOnlyDependencyNames: string[];
    violationsAsErrors: boolean;
}

/**
 * @internal
 */
export declare interface _IBaseConfigJsonResult {
    /**
     * True if the file is missing.
     */
    missingFile: boolean;
    /**
     * Parse error data.
     */
    readError?: {};
    /**
     * The version of the original config file.
     */
    version?: string;
    /**
     * True if the config file is the latest version.
     */
    isLatestVersion?: boolean;
}

/**
 * @internal
 */
export declare interface _IBundleComponent extends IConfigComponent {
    manifestData: IClientSideComponentManifest;
    manifestPath: string;
    exportName: string | undefined;
}

/**
 * @internal
 */
export declare interface _IBundleEntry {
    bundleName: string;
    components: {
        [id: string]: _IBundleComponent;
    };
}

/**
 * @internal
 */
export declare interface _IComponentDependenciesAuditFile {
    bundles: {
        [bundleName: string]: _IComponentDependenciesAuditFileBundle;
    };
}

/**
 * @internal
 */
export declare interface _IComponentDependenciesAuditFileBundle {
    dependencies: _IComponentDependenciesAuditFileDependency[];
}

/**
 * @internal
 */
export declare interface _IComponentDependenciesAuditFileDependency {
    componentId: string;
    componentName: string;
    componentVersion: string | undefined;
    isDirectDependency: boolean;
}

/**
 * @internal
 */
export declare interface _IComponentNamePluginOptions {
    getLibraryNameForChunk: (chunk: webpack.compilation.Chunk, existingId: string) => string | undefined;
}

/**
 * @public
 */
export declare interface IConfigBundle {
    /**
     * An array of components to be included in this bundle.
     */
    components: IConfigComponent[];
}

/**
 * @public
 */
export declare interface IConfigComponent {
    /**
     * The path to the code entrypoint for this component, relative to the project root.
     */
    entrypoint: string;
    /**
     * The path to the manifest for this component, relative to the project root.
     */
    manifest: string;
}

/**
 * @public
 */
export declare interface IConfigJson {
    $schema: string;
    /**
     * The config version
     */
    version: '2.0';
    /**
     * A list of bundle definitions. Bundle names may be between 10 and 30 lowercase alphanumeric or dash characters.
     */
    bundles: {
        [name: string]: IConfigBundle;
    };
    /**
     * The localized resources specified in config.json
     */
    localizedResources?: {
        [key: string]: string;
    };
    /**
     * The externals specified in config.json
     */
    externals?: {
        [name: string]: string | INonAMDExternalModuleConfig;
    };
    /**
     * A list of components that should generate a warning if made synchronous dependencies of any component in
     *  this project.
     */
    asyncComponents?: string[];
}

/**
 * @internal
 */
export declare interface _IConfigJsonResult extends _IBaseConfigJsonResult {
    /**
     * The data in the config file.
     */
    configData?: IConfigJson;
}

/**
 * @internal
 */
export declare interface _ICumulativeManifestEnvironmentOptions extends _IManifestsFileBuilderOptions {
    rootPath: string;
    tempFolderName: string;
    distFolderName: string;
}

/**
 * @internal
 */
export declare interface _ICumulativeManifestOptions {
    /**
     * IDs of manifests to exclude from the manifest map file.
     */
    ignoreOutputManifestIds: string[];
    /**
     * The base path for debug manifests. Expected to match the result of the "debugBasePath" function passed to the
     *  WriteManifestsTask task.
     */
    baseUrl?: string;
    /**
     * Optional array of IDs to ensure aren't filtered out of the results if they are discovered.
     */
    explicitInclude: string[];
    /**
     * If set to true, include assemblies. Defaults to false. Assemblies are excluded by default.
     */
    includeAssemblies: boolean;
}

/**
 * @internal
 */
export declare interface _ICustomActionConfiguration {
    /**
     * The type of custom action, use "ClientSideExtension.ApplicationCustomizer" for the Application Customizer
     *  extension.
     */
    location: 'ClientSideExtension.ApplicationCustomizer' | 'ClientSideExtension.ListViewCommandSet.ContextMenu' | 'ClientSideExtension.ListViewCommandSet.CommandBar' | 'ClientSideExtension.ListViewCommandSet' | 'ClientSideExtension.SearchQueryModifier';
    properties?: any;
}

/**
 * @public
 */
export declare interface IDeployFile {
    localPath: string;
    deployPath: string;
}

/**
 * @public
 */
export declare interface IDevDeployConfig {
    accountName: string;
    accessKey: string;
    container: string;
    /**
     * The directory in the Azure container to use. Recommended to be set to something that includes your user name
     *  to ensure you don't clobber others' work.
     */
    folderNameInContainer?: string;
    /**
     * If false, the current project directory and its dependencies are deployed. If true, we attempt to find a
     *  rush.json file and deploy everything in the repo. Defaults to false.
     */
    useRush: boolean;
    /**
     * The number of upload retries
     */
    maxRetries: number;
    /**
     * Include these folders alongside the "dist" directory. This is useful for deploying integration tests.
     *
     * @internal
     */
    _additionalFoldersToInclude?: string[];
    /**
     * True if the deployment is in a prod environment.
     */
    isProd?: boolean;
}

/**
 * @public
 */
export declare interface IDevDeployData {
    filesToUpload: IDeployFile[];
    loaderPath: string;
    debugManifestPath: string;
}

/**
 * @public
 * Dev-deploy metadata
 */
export declare interface IDevDeployMetadata {
    loaderUrl: string;
    debugManifestUrl: string;
    deployUrl: string;
}

/**
 * @public
 */
export declare interface IDevDeployOptions {
    /**
     * If false, the current project directory and its dependencies are deployed. If true, we attempt to find a
     *  rush.json file and deploy everything in the repo. Defaults to false.
     */
    useRush?: boolean;
    /**
     * If true, projects will be uploaded into individual directories. This is useful if projects have files that may
     *  have conflicting names. If this is false and a collision is detected, a warning will be printed. Defaults to true.
     */
    isolateProjects?: boolean;
    /**
     * The project root path
     */
    rootPath: string;
    terminal: Terminal;
    ignoreCollisions?: boolean;
    /**
     * Include these directories alongside the "dist" directory. This is useful for deploying integration tests.
     *
     * @internal
     */
    _additionalDirectoriesToInclude?: string[];
    devDeployConfig: IDevDeployConfig;
}

/**
 * @public
 */
export declare interface IDevDeployPluginAccessor {
    hooks: DevDeployHooks;
}

/**
 * @internal
 */
export declare interface _IDiscoverManifestsOptions {
    /**
     * The directory in each project's directory where we should search for manifests. Defaults to "dist"
     */
    projectTargetFolder?: string;
    /**
     * The regex to use to search for manifest files. Defaults to /^[^\.\\\/]+\.manifest\.json$/
     */
    manifestFileRegex?: RegExp;
}

/**
 * @internal
 */
export declare interface _IDynamicExternalProject extends _IExternalProject {
    /**
     * A function to get the failover path given the package's root.
     */
    getFailoverPath?: (projectRootPath: string) => string;
    /**
     * A function to get the version of the package. Return undefined if the package is not a dependency.
     */
    getVersion: (projectRootPath: string, referencedProjects: _IReferencedProjectMap) => string | undefined;
}

/**
 * @internal
 */
export declare interface _IExternalProject {
    /**
     * The ID of the project from the manifest.
     */
    id: string;
    /**
     * The name of the project.
     */
    name: string;
    /**
     * The version of the project from the manifest.
     */
    version: string | undefined;
    /**
     * The failover path, if one exists.
     */
    failoverPath?: string;
}

/**
 * @internal
 */
export declare interface _IExternalProjectMap {
    [name: string]: _IExternalProject;
}

/**
 * @internal
 */
export declare interface _IFieldCustomizerConfiguration {
    /**
     * The ID of the field customizer component.
     */
    id: string;
    properties?: any;
}

/**
 * @internal
 */
export declare interface _ILegacyExternal {
    moduleConfigurations: {
        [externalName: string]: IModuleConfiguration;
    };
    assets: {
        [name: string]: string;
    };
}

/**
 * @alpha
 */
export declare interface ILocalization {
    getProjectLocalizedStringsAsync(): Promise<ILocalizedStrings>;
    getLocalizationConfigurationAsync(selectedLocales: string[]): Promise<ILocalizationConfiguration>;
}

/**
 * @alpha
 */
export declare interface ILocalizationConfiguration {
    localizationPlugin: LocalizationPlugin;
    stringsLoaders: webpack.RuleSetRule[];
    entityMarker: EntityMarker;
}

/**
 * @internal
 */
export declare interface _IManifestPluginOptions {
    terminal: Terminal;
    bundleEntries: _IBundleEntry[];
    internalModuleBaseUrls: string[];
    debugInternalModuleBaseUrls: string[];
    linkedExternals: _IExternalProjectMap;
    referencedProjects: _IReferencedProjectMap;
    cumulativeManifestProcessor: _CumulativeManifestProcessor;
    sourceLocaleName: string;
    translatedStrings: ILocalizedStrings;
    selectedLocales: string[] | undefined;
    releaseDropPath: string;
    firstPassLocaleRemapping?: Map<string, string[]>;
    asyncOnlyDependencies?: _IAsyncOnlyDependenciesOptions;
    componentDependenciesAuditDropPath?: string;
    /**
     * @internal
     */
    tryGetLegacyExternalByNameAsync?: (name: string) => Promise<_ILegacyExternal>;
}

/**
 * @internal
 */
export declare interface _IManifestsFileBuilderOptions {
    terminal: Terminal;
    manifestsFilePath?: string;
}

/**
 * @internal
 */
export declare function _includeNonStandardExternal(name: string, external: _IDynamicExternalProject): void;

/**
 * Configuration for a non-AMD external module
 *
 * @public
 */
export declare interface INonAMDExternalModuleConfig {
    /**
     * The path or URL to the bundled external non-AMD file
     */
    path: string;
    /**
     * The name of the global variable where an non-AMD dependency drops its exports
     */
    globalName: string;
    /**
     * The names of the non-AMD dependencies for this project
     */
    globalDependencies?: string[];
}

/**
 * @internal
 */
export declare interface _IReferencedProject {
    /**
     * The creation time of the newest version of this manifest we've found
     */
    manifestCreationTime: number;
    /**
     * The ID of the manifest.
     */
    id: string;
    /**
     * The version of the manifest.
     */
    version: string;
    /**
     * The project's manifest data
     */
    manifestData: IClientSideComponentManifest;
    /**
     * The path to the manifest.
     */
    manifestPath: string;
    /**
     * The name of the package, if it can be inferred. The name can only be inferred if it's in a project with only
     *  one manifest.
     */
    packageName: string;
    /**
     * If set to true, this is an assembly manifest
     */
    isAssembly: boolean;
}

/**
 * @internal
 */
export declare type _IReferencedProjectMap = _IVersionedIdMap<_IReferencedProject>;

/**
 * @public
 */
export declare interface IRequireFolderOptions {
    sources: IRequireFolderSource[];
    outputFolder: string;
}

/**
 * @public
 */
export declare interface IRequireFolderSource {
    globsBase: string;
    globPaths: string[];
}

/**
 * @internal
 *
 * @remarks
 * If this schema is updated, dependant schemas MUST also be updated, including the spfx-serve.schema.json.
 * The spfx-serve.schema.json is the serve.schema.json file with the spfx-specific properties included. The
 * merge is simple, but must be done manually whenever the serve.schema.json file is changed.
 */
export declare interface _IServeTaskConfig {
    /**
     * API server configuration
     */
    api?: {
        /**
         * The port on which to run the API server
         */
        port: number;
        /**
         * The path to the script to run as the API server
         */
        entryPath: string;
    };
    /**
     * The path to the page which should open automatically after this task completes. If you prefer no page to be
     * launched, run the build with the "--nobrowser" flag
     */
    initialPage?: string;
    /**
     * The port on which to host the file server.
     */
    port?: number;
    /**
     * The name of the host on which serve is running. Defaults to 'localhost'
     */
    hostname?: string;
    /**
     * If true, the server should run on HTTPS
     */
    https?: boolean;
    /**
     * Path to the HTTPS key
     */
    keyPath?: string;
    /**
     * Path to the HTTPS cert
     */
    certPath?: string;
    /**
     * Path to the HTTPS PFX cert
     */
    pfxPath?: string;
    /**
     * Path relative to the server root to base the server in.
     */
    rootFolder?: string;
    /**
     * If true, when serve is initialized and a dev certificate doesn't already exist and hasn't been
     *  specified, attempt to generate one and trust it automatically.
     *
     * defaults to false
     */
    tryCreateDevCertificate?: boolean;
}

/**
 * Options for sp-client dev-deploy
 * @public
 */
export declare interface ISpDevDeployOptions extends IDevDeployOptions {
    /**
     * @internal
     */
    _projectDiscoveryMode?: _DependencyDiscoveryMode;
}

/**
 * @public
 */
export declare interface ISpfxHeftPluginAccessor {
    devDeploy: IDevDeployPluginAccessor;
    spfxWebpackConfiguration: IWebpackConfigurationPluginAccessor;
}

/**
 * Describes the interface for serve.json config files in SPFx projects.
 *
 * @internal
 */
export declare interface _ISpfxServe extends _ISpfxServeTaskConfig {
    $schema: string;
}

/**
 * @internal
 */
export declare interface _ISpfxServeSessionConfiguration {
    /**
     * The fully-qualified URL of the page to launch
     */
    pageUrl: string;
    /**
     * An optional list of custom actions to provide as query parameters to the page. The key of this
     *  object must be the ID of the custom action component.
     */
    customActions?: {
        [id: string]: _ICustomActionConfiguration;
    };
    /**
     * An optional list of field customizers to provide as query parameters to the page. The key of this
     *  object must be the field ID the customizer applies to.
     */
    fieldCustomizers?: {
        [fieldName: string]: _IFieldCustomizerConfiguration;
    };
}

/**
 * @remarks
 * If the GCB-serve schema is updated, this schema MUST also be updated. The spfx-serve.schema.json is
 * the serve.schema.json file with the spfx-specific properties included. The merge is simple, but
 * must be done manually whenever the serve.schema.json file in GCB is changed.
 *
 * @internal
 */
export declare interface _ISpfxServeTaskConfig extends _IServeTaskConfig {
    serveConfigurations?: {
        default: _ISpfxServeSessionConfiguration;
        [id: string]: _ISpfxServeSessionConfiguration;
    };
}

/**
 * Represents a file's local path and container-root-relative path in Azure Storage destination
 * @internal
 */
export declare interface _IUploadableFile {
    /**
     * A container-root-relative path to the file's Azure Storage destination
     *
     * For example, if the account name is "example" the container's name is "files",
     * and this property is "foo/bar/baz.json", the fully-qualified URL of the uploaded
     * file will be:
     * https://example.blob.core.windows.net/files/foo/bar/baz.json
     */
    azurePath: string;
    /**
     * A fully-qualified filesystem path to a file.
     */
    localPath: string;
}

/**
 * @internal
 */
export declare interface _IVersionedIdMap<TMember> {
    [id: string]: _IVersionMap<TMember>;
}

/**
 * @internal
 */
export declare interface _IVersionMap<TMember> {
    [version: string]: TMember;
}

/**
 * @public
 */
export declare interface IWebpackConfigurationFolders {
    buildFolder: string;
    tempFolder: string;
    outputFolder: string;
    releaseFolder: string;
}

/**
 * @public
 */
export declare interface IWebpackConfigurationGeneratorOptions {
    configJson: IConfigJson;
    folders: IWebpackConfigurationFolders;
    terminal: Terminal;
    production: boolean;
    serveMode: boolean;
    projectPackageJson: IPackageJson;
    /**
     * @alpha
     */
    localization?: ILocalization;
    singleLocale?: string;
    linkedExternalsToBundle?: string[];
    libraryName?: string;
    libraryTarget?: WebpackLibraryTarget;
    disableAsyncComponentLoading?: boolean;
    assetsAreVersioned?: boolean;
    includeScssLoaders?: boolean;
    generateCssClassName?: GenerateCssClassNameFunction;
    loadThemedStylesImportPath?: string;
}

/**
 * @public
 */
export declare interface IWebpackConfigurationPluginAccessor {
    properties: {
        linkedExternalsToBundle?: string[];
        libraryName?: string;
        libraryTarget?: WebpackLibraryTarget;
        disableAsyncComponentLoading?: boolean;
        assetsAreVersioned?: boolean;
        generateCssClassName?: GenerateCssClassNameFunction;
        loadThemedStylesImportPath?: string;
        /**
         * @alpha
         */
        localization?: ILocalization;
    };
}

/**
 * @internal
 */
export declare interface _IWebpackEntrypoint {
    readonly runtimeChunk: ILocalizedWebpackChunk;
}

/**
 * @internal
 */
export declare interface _IWebpackStatsPluginOptions {
    dropPath: string;
}

/**
 * @internal
 */
export declare function _loadServeSchemaJson(): Object;

/**
 * @internal
 */
export declare class _LocalizedManifestModuleProcessor {
    static readonly LOCALE_MAPPING: Map<string, string[]>;
    static generateLocalizedManifestModule(bundleName: string, localizedPaths: {
        [locale: string]: string;
    }, firstPassLocaleRemapping: Map<string, string[]> | undefined): ILocalizedPathModuleConfiguration;
    static findDefaultString(localizedPaths: ILocalizedString): string | undefined;
    static applyLocaleRemapping(manifestLocalizedPaths: ILocalizedString, localeRemapping: Map<string, string[]>): void;
}

/**
 * @internal
 */
export declare class _ManifestPlugin implements webpack.Plugin {
    /**
     * @internal
     */
    _options: _IManifestPluginOptions;
    private _locFileCache;
    static isManifestAsset(asset: webpack.compilation.Asset): boolean;
    constructor(options: _IManifestPluginOptions);
    apply(compiler: webpack.Compiler): void;
    /**
     * @virtual
     */
    protected _generateLoaderConfigurationAsync(terminal: Terminal, bundleName: string, compilation: webpack.compilation.Compilation, asyncOnlyDependencies: Set<string>, asyncOnlyDependenciesViolationsAsErrors: boolean, dependenciesForAudit: Map<string, _IComponentDependenciesAuditFileDependency>, emitAsset: (assetName: string, assetContents: string) => void): Promise<IClientSideComponentLoaderConfiguration>;
    protected _getRuntimeChunk(bundleName: string, entrypoint: _IWebpackEntrypoint): ILocalizedWebpackChunk;
    protected _getExternalsScriptResourcesAsync(terminal: Terminal, bundleName: string, runtimeChunk: webpack.compilation.Chunk, asyncOnlyDependencies: Set<string>, asyncOnlyDependenciesViolationsAsErrors: boolean, dependenciesForAudit: Map<string, _IComponentDependenciesAuditFileDependency>, emitAsset: (assetName: string, assetContents: string) => void): Promise<{
        [name: string]: IModuleConfiguration;
    }>;
    protected _getRuntimeChunkFilename(bundleName: string, runtimeChunk: webpack.compilation.Chunk): string;
    private _generateComponentManifest;
    private _processWebpartManifest;
    private _processApplicationManifest;
    /**
     * Does extension-specific manifest processing.
     */
    private _processExtensionsManifest;
    /**
     * Localizes a string with an ID in the form of $<path-to-loc-file>:<string-name>;
     * If the string to localize is not based on an id, it returns the input param untouched.
     */
    private _localizeString;
    private _getEntryManifestModule;
    private _populateLinkedExternalComponentInDependencyMap;
}

/**
 * @internal
 */
export declare class _ManifestsFileBuilder {
    private readonly _terminal;
    private readonly _manifestsFilePath;
    constructor(options: _IManifestsFileBuilderOptions);
    buildManifestsJs(manifestsArray: IClientSideComponentManifest[], outputFilePath: string): Promise<void>;
    private _getManifestsFileWebpackConfig;
}

/**
 * @internal
 */
export declare function _migrateToLatestVersion(logWarning: (message: string) => void, configJson: IConfigJson): void;

/**
 * Normalizes a locale name. So "en-us" becomes "en-US" and "sr-cyrl-rs" becomes "sr-Cyrl-RS". There are two special
 *  cases. For pseudo-locales like "qps-ploc", everything stays lowecase. For language-script locales like "uz-Cyrl",
 *  only the script name's first character should be uppercased.
 *
 * @internal
 */
export declare function _normalizeLocaleName(localeName: string): string;

/**
 * @public
 */
export declare const enum PluginNames {
    DevDeployPlugin = "spfx-dev-deploy-plugin",
    LocalizationTypingsPlugin = "localization-typings-plugin",
    SpfxHeftPlugin = "spfx-heft-plugin",
    SpfxWebpackConfigurationPlugin = "spfx-webpack-configuration-plugin",
    SpfxWebpackServePlugin = "spfx-webpack-serve-plugin",
    CustomizeWebpackConfigPlugin = "customize-spfx-webpack-configuration-plugin"
}

/**
 * @public
 * Prints out a link to a page where you can test your changes. Note that loaderUrl and debugManifestFile
 * should both be fully qualified URLs. If the dev_deploy_url environment variable is not set,
 * advice is given on how to set it and the query parameters & hash are printed separately.
 */
export declare function printDevDeployLink(log: (text: string) => void, metadata: IDevDeployMetadata): void;

/**
 * @internal
 */
export declare function _readConfigFile(logVerbose: (message: string) => void, filename: string): _IConfigJsonResult;

/**
 * Executes promises and optionally retries them if they fail
 * @internal
 */
export declare class _RetryUtilities {
    private static _setTimeout;
    static setTimeoutMock(setTimeout: (cb: () => void, timeout: number) => void): void;
    static runWithRetriesAsync<TResult>(fn: () => Promise<TResult>, maxRetries: number, retryDelayInMs?: number): Promise<TResult>;
}

/**
 * @public
 */
export declare class SpDevDeploy {
    private static readonly debugManifestPath;
    private static __gitRepoInfo;
    private _rushConfig;
    private _packageJsonLookup;
    private _options;
    private _devDeployManifestFileUrl;
    private _devDeployModuleLoaderUrl;
    private _devDeployMetadata;
    private readonly _collisionDetectionMap;
    static getDevDeployContainerDirectoryName(): string;
    private static get _gitRepoInfo();
    private static get _userName();
    /**
     * Escapes non-(alphanumeric/hyphens) with underscores
     */
    private static _escapeNonAlphaNumericChars;
    constructor(options: ISpDevDeployOptions);
    preProcess(): void;
    getFiles(): Promise<IDevDeployData>;
    postProcess(): void;
    private _printCollisionWarnings;
    private _saveDevDeployMetadata;
    private _printDevDeployLink;
    private _getDeployBaseUrl;
    private _getContainerUrl;
    private _getAzureStorageUrl;
    private _processAllPathsInManifest;
    private _disambiguatePath;
    private _getFilesInDirectory;
    /**
     * This function returns a directory name to be used in a directory in the destination, ensuring that the name does
     * not collide with another directory's name. It also ensures that if the specified filesystem path has already
     * been mapped to a destination directory, the same name is used in the destination.
     */
    private _getDestinationDirName;
    private _getManifests;
    private _mergeReferencedProjectLists;
    private _doComponentTypeSpecificFixup;
    private _fixupIconPath;
    private _getRushConfig;
    private _getMetadataDropPath;
    private _doesFilenameAppearToContainHash;
}

/**
 * @public
 */
declare class SpfxHeftPlugin implements IHeftPlugin {
    readonly pluginName: string;
    private _accessor;
    get accessor(): ISpfxHeftPluginAccessor;
    apply(heftSession: HeftSession, heftConfiguration: HeftConfiguration): void;
}

/**
 * @internal
 */
export declare class _UploadToAzure {
    static readonly DEFAULT_AZURE_MAX_PARALLELISM: number;
    static readonly DEFAULT_AZURE_RETRY_DELAY_MILLISECONDS: number;
    static readonly DEFAULT_AZURE_MAX_NUMBER_OF_RETRIES: number;
    /**
     * Upload file to Azure
     */
    static uploadFileToAzureAsync(terminal: Terminal, blobService: BlobService, containerName: string, localFilename: string, serverFilename?: string): Promise<BlobService>;
    /**
     * Upload files to Azure
     */
    static uploadFilesToAzureAsync(terminal: Terminal, blobService: BlobService, containerName: string, files: _IUploadableFile[], maxParallelism: number, maxRetries: number, retryDelayInMs: number): Promise<BlobService>;
}

/**
 * @public
 */
export declare class WebpackConfigurationGenerator {
    static generateWebpackConfigurationAsync(options: IWebpackConfigurationGeneratorOptions): Promise<webpack.Configuration | undefined>;
    static getComponentsBundleId(manifests: IClientSideComponentManifest[]): string;
    private static _getBundleId;
    /**
     * Writes the entrypoint file to the temp directory and returns the path to the file.
     */
    private static _generateBundleEntrypointFile;
    private static _requireResolveWithCorrectCase;
    private static _validateEntries;
}

/**
 * @public
 */
export declare type WebpackLibraryTarget = 'amd' | 'var' | 'this' | 'commonjs' | 'commonjs2' | 'umd' | 'window' | 'assign' | 'jsonp';

/**
 * This plugin drops the webpack stats object to the specified filesystem path
 *
 * @internal
 */
export declare class _WebpackStatsPlugin implements webpack.Plugin {
    private _options;
    constructor(options: _IWebpackStatsPluginOptions);
    apply(compiler: webpack.Compiler): void;
}

export { }
