"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebpackConfigurationGenerator = exports.FILE_LOADER_EXTENSIONS = void 0;
const path = __importStar(require("path"));
const webpack = __importStar(require("webpack"));
const lodash_1 = __importDefault(require("lodash"));
const terser_webpack_plugin_1 = __importDefault(require("terser-webpack-plugin"));
const node_core_library_1 = require("@rushstack/node-core-library");
const set_webpack_public_path_plugin_1 = require("@rushstack/set-webpack-public-path-plugin");
const true_case_path_1 = require("true-case-path");
const sass = __importStar(require("node-sass"));
const crypto = __importStar(require("crypto"));
const CopyReleaseAssetsPlugin_1 = require("./webpackPlugins/CopyReleaseAssetsPlugin");
const ComponentNamePlugin_1 = require("./webpackPlugins/ComponentNamePlugin");
const HashedFolderCopyPlugin_1 = require("./webpackPlugins/HashedFolderCopyPlugin");
const AsyncComponentPlugin_1 = require("./webpackPlugins/AsyncComponentPlugin");
const CumulativeManifestProcessor_1 = require("../../spfxManifests/cumulativeManifestProcessor/CumulativeManifestProcessor");
const ExternalsProcessor_1 = require("../../spfxManifests/utilities/ExternalsProcessor");
const getFullHash_1 = require("../../spfxManifests/utilities/getFullHash");
const constants_1 = require("../../utilities/constants");
const ManifestPlugin_1 = require("../../spfxManifests/webpack/ManifestPlugin");
/**
 * @public
 */
exports.FILE_LOADER_EXTENSIONS = ['jpg', 'png', 'woff', 'eot', 'ttf', 'svg', 'gif', 'dds'];
const ASSETS_FOLDER_NAME = 'assets';
const VERSIONED_ASSETS_FOLDER_NAME = 'assets-versioned';
const cssHashCache = new Map();
const DEFAULT_GENERATE_CSS_CLASS_NAME = (existingClassName, cssFilename, cssContent) => {
    let hash = cssHashCache.get(cssFilename);
    if (!hash) {
        hash = crypto.createHmac('sha1', cssFilename).update(cssContent).digest('hex').substring(0, 8);
        cssHashCache.set(cssFilename, hash);
    }
    return `${existingClassName}_${hash}`;
};
/**
 * @public
 */
class WebpackConfigurationGenerator {
    static async generateWebpackConfigurationAsync(options) {
        var _a;
        WebpackConfigurationGenerator._validateEntries(options.configJson, options.folders.buildFolder);
        const terminal = options.terminal;
        const configBundleEntries = options.configJson.bundles || {};
        //#region EXTERNAL COMPONENTS
        // Discover packages that should be externalized because they have manifests
        const cumulativeManifestProcessor = new CumulativeManifestProcessor_1.CumulativeManifestProcessor({
            terminal: options.terminal,
            rootPath: options.folders.buildFolder,
            tempFolderName: path.basename(options.folders.tempFolder),
            distFolderName: path.basename(options.folders.outputFolder),
            includeAssemblies: true
        });
        const referencedProjects = cumulativeManifestProcessor.discoverManifests(options.folders.buildFolder, CumulativeManifestProcessor_1.DependencyDiscoveryMode.deepSparseIgnoreFirstProject);
        const linkedExternals = {};
        // Add these projects to externalized packages
        for (const [manifestId, versionMap] of Object.entries(referencedProjects)) {
            for (const [, referencedProject] of Object.entries(versionMap)) {
                if (referencedProject.packageName && !referencedProject.isAssembly) {
                    linkedExternals[referencedProject.packageName] = {
                        id: manifestId,
                        name: referencedProject.packageName,
                        version: referencedProject.manifestData.version
                    };
                }
            }
        }
        const nonStandardExternals = ExternalsProcessor_1.getNonStandardExternals(options.folders.buildFolder, referencedProjects);
        for (const [externalName, external] of Object.entries(nonStandardExternals)) {
            linkedExternals[externalName] = external;
        }
        const externalsKeys = new Set(Object.keys(linkedExternals));
        if (options.configJson.externals) {
            for (const externalKey of Object.keys(options.configJson.externals)) {
                externalsKeys.add(externalKey);
            }
        }
        // Remove the specified linked externals to ensure they're bundled
        if ((_a = options.linkedExternalsToBundle) === null || _a === void 0 ? void 0 : _a.length) {
            for (const linkedExternalToBundle of options.linkedExternalsToBundle) {
                externalsKeys.delete(linkedExternalToBundle);
            }
        }
        // Don't list the project being built as an external
        externalsKeys.delete(options.projectPackageJson.name);
        //#endregion
        const configBundleEntriesCount = Object.keys(configBundleEntries).length;
        if (configBundleEntriesCount === 0) {
            terminal.writeWarningLine('No entries are defined, so no bundles will be produced.');
            return undefined;
        }
        terminal.writeVerboseLine(`${configBundleEntriesCount} entries specified.`);
        terminal.writeVerboseLine(`${externalsKeys.size} externals specified.`);
        const bundleEntries = [];
        const webpackEntries = {};
        const libraryNameMap = new Map();
        for (const [bundleName, configEntry] of Object.entries(configBundleEntries)) {
            const bundleEntry = {
                bundleName,
                components: {}
            };
            for (const componentEntry of configEntry.components) {
                const manifestData = node_core_library_1.JsonFile.load(path.resolve(options.folders.buildFolder, componentEntry.manifest));
                // If the manifest version is "*", replace it with the package version. Do this here to make sure the
                //  bundle's name doesn't contain the "*" version
                if (manifestData.version === '*') {
                    const packageJson = node_core_library_1.PackageJsonLookup.instance.tryLoadPackageJsonFor(options.folders.buildFolder);
                    if (!packageJson) {
                        throw new Error(`Unable to find package.json for "${options.folders.buildFolder}"`);
                    }
                    // Remove pre-release name if any, because pre-release is not handled by SPFx yet.
                    const indexOfDelimiter = packageJson.version.indexOf('-');
                    const manifestVersion = indexOfDelimiter > 0 ? packageJson.version.substr(0, indexOfDelimiter) : packageJson.version;
                    manifestData.version = manifestVersion;
                }
                // Keep a counter of the manifests inside the bundle so we can set the exportName property in the produced
                //  manifest(s) and generate a JS file to bundle both components' entrypoints
                bundleEntry.components[manifestData.id] = Object.assign(Object.assign({}, componentEntry), { manifestData, manifestPath: path.join(options.folders.buildFolder, componentEntry.manifest), exportName: undefined });
            }
            const componentKeys = Object.keys(bundleEntry.components);
            if (componentKeys.length === 1) {
                // Single component, just point to its entrypoint in the webpack config
                webpackEntries[bundleName] = node_core_library_1.Import.resolveModule({
                    modulePath: bundleEntry.components[componentKeys[0]].entrypoint,
                    baseFolderPath: options.folders.buildFolder
                });
                libraryNameMap.set(bundleName, WebpackConfigurationGenerator._getBundleId(bundleEntry));
            }
            else {
                // Multiple components, we need to generate an entry to point the webpack config in the temp folder
                webpackEntries[bundleName] = this._generateBundleEntrypointFile({
                    bundleEntry,
                    buildFolder: options.folders.buildFolder,
                    tempFolder: options.folders.tempFolder
                });
            }
            bundleEntries.push(bundleEntry);
        }
        let webpackLibraryName;
        if (options.libraryName) {
            webpackLibraryName = options.libraryName;
        }
        else {
            if (bundleEntries.length === 1) {
                // We're producing one bundle, so we can generate a simple name
                webpackLibraryName = libraryNameMap.get(bundleEntries[0].bundleName);
            }
            else {
                // There are multiple bundles. Because we need something unique for the webpack JSONP function, we'll just
                // concatenate the IDs and then hash them. In a plugin, we'll replace the "define(<name>, ..."
                // names with the real IDs.
                webpackLibraryName = getFullHash_1.getFullHash(bundleEntries.map((bundle) => libraryNameMap.get(bundle.bundleName)).join(''));
            }
        }
        const generateCssClassName = options.generateCssClassName || DEFAULT_GENERATE_CSS_CLASS_NAME;
        const cssLoaders = [
            {
                loader: WebpackConfigurationGenerator._requireResolveWithCorrectCase('@microsoft/loader-load-themed-styles'),
                options: {
                    async: true
                }
            },
            {
                loader: WebpackConfigurationGenerator._requireResolveWithCorrectCase('css-loader')
            },
            {
                loader: WebpackConfigurationGenerator._requireResolveWithCorrectCase('postcss-loader'),
                options: {
                    ident: 'postcss',
                    minimize: true,
                    plugins: [require('cssnano')({ preset: 'default' })]
                }
            }
        ];
        const scssLoader = {
            loader: require.resolve('sass-loader'),
            options: {
                implementation: sass,
                sassOptions: {
                    includePaths: [
                        path.resolve(options.folders.buildFolder, 'node_modules'),
                        path.resolve('./node_modules')
                    ]
                }
            }
        };
        const simpleCssLoaderPath = WebpackConfigurationGenerator._requireResolveWithCorrectCase('@microsoft/sp-css-loader');
        const simpleCssLoaderOptions = {
            async: true,
            loadThemedStylesImportPath: options.loadThemedStylesImportPath
        };
        const scssLoaders = [
            {
                loader: simpleCssLoaderPath,
                options: simpleCssLoaderOptions
            },
            scssLoader
        ];
        const moduleScssLoaders = [
            {
                loader: simpleCssLoaderPath,
                options: Object.assign(Object.assign({}, simpleCssLoaderOptions), { generateCssClassName: generateCssClassName })
            },
            scssLoader
        ];
        const outputFilenameParts = ['[name]'];
        if (options.localization) {
            outputFilenameParts.push('_[locale]');
        }
        if (!options.serveMode && options.production) {
            // For future reference, serve mode does not support "contenthash". If the hash
            // is included in serve mode, it should be "hash", not "contenthash"
            outputFilenameParts.push('_[contenthash]');
        }
        outputFilenameParts.push('.js');
        const outputFilename = outputFilenameParts.join('');
        const config = {
            module: {
                rules: [
                    {
                        test: /\.js$/,
                        enforce: 'pre',
                        use: WebpackConfigurationGenerator._requireResolveWithCorrectCase('source-map-loader'),
                        exclude: [/node_modules/]
                    },
                    {
                        use: cssLoaders,
                        test: /\.css$/
                    },
                    ...(options.includeScssLoaders
                        ? [
                            {
                                use: moduleScssLoaders,
                                test: /\.module\.scss$/
                            },
                            {
                                use: scssLoaders,
                                test: /(?<!\.module)\.scss$/
                            }
                        ]
                        : []),
                    {
                        use: [
                            {
                                loader: WebpackConfigurationGenerator._requireResolveWithCorrectCase('file-loader'),
                                options: {
                                    name: '[name]_[hash].[ext]'
                                }
                            }
                        ],
                        test: {
                            or: exports.FILE_LOADER_EXTENSIONS.map((ext) => new RegExp(`\\.${lodash_1.default.escapeRegExp(ext)}((\\?|\\#).+)?$`))
                        }
                    },
                    {
                        use: [
                            {
                                loader: WebpackConfigurationGenerator._requireResolveWithCorrectCase('html-loader')
                            }
                        ],
                        test: /\.html$/
                    }
                ],
                noParse: [/\.map$/]
            },
            resolve: {
                alias: {},
                modules: ['node_modules', 'lib']
            },
            context: options.folders.buildFolder,
            devtool: options.production ? undefined : 'source-map',
            mode: options.production ? 'production' : 'development',
            entry: webpackEntries,
            externals: Array.from(externalsKeys),
            output: {
                hashFunction: 'md5',
                chunkFilename: `chunk.${outputFilename}`,
                filename: outputFilename,
                library: webpackLibraryName,
                libraryTarget: options.libraryTarget || 'amd',
                path: options.folders.outputFolder,
                devtoolModuleFilenameTemplate: 'webpack:///../[resource-path]',
                devtoolFallbackModuleFilenameTemplate: 'webpack:///../[resource-path]?[hash]'
            },
            optimization: {
                moduleIds: 'hashed',
                splitChunks: {
                    automaticNameMaxLength: 50
                } // SplitChunksOptions in the webpack typings is missing the automaticNameMaxLength option
            },
            performance: {
                hints: false
            },
            plugins: [
                new set_webpack_public_path_plugin_1.SetPublicPathPlugin({
                    scriptName: {
                        useAssetName: true
                    }
                }),
                new webpack.DefinePlugin({
                    'process.env.NODE_ENV': JSON.stringify(options.production ? 'production' : 'dev'),
                    DEBUG: !options.production,
                    DEPRECATED_UNIT_TEST: false
                }),
                new ComponentNamePlugin_1.ComponentNamePlugin({
                    getLibraryNameForChunk: (chunk) => libraryNameMap.get(chunk.name)
                }),
                new HashedFolderCopyPlugin_1.HashedFolderCopyPlugin()
            ]
        };
        if (!options.disableAsyncComponentLoading) {
            const asyncComponentPluginExternalComponents = [];
            for (const [, linkedExternal] of Object.entries(linkedExternals)) {
                asyncComponentPluginExternalComponents.push({
                    componentId: linkedExternal.id,
                    componentName: linkedExternal.name,
                    componentVersion: linkedExternal.version
                });
            }
            config.plugins.push(new AsyncComponentPlugin_1.AsyncComponentPlugin({
                externalComponents: asyncComponentPluginExternalComponents
            }));
        }
        let localizedData = {};
        let selectedLocales = [];
        if (options.localization) {
            localizedData = await options.localization.getProjectLocalizedStringsAsync();
            if (options.singleLocale) {
                if (localizedData[options.singleLocale]) {
                    selectedLocales = [options.singleLocale];
                }
                else {
                    console.log(`The selected locale (${options.singleLocale}) is not present in the localized data.`);
                }
            }
            else if (options.production) {
                selectedLocales = Object.keys(localizedData);
            }
            else {
                selectedLocales = [constants_1.DEFAULT_LOCALE];
            }
            const { localizationPlugin, stringsLoaders } = await options.localization.getLocalizationConfigurationAsync(selectedLocales);
            config.module.rules.push(...stringsLoaders);
            config.plugins.push(localizationPlugin);
        }
        let serveConfig = {};
        try {
            serveConfig = await node_core_library_1.JsonFile.loadAsync(path.join(options.folders.buildFolder, 'config', 'serve.json'));
        }
        catch (e) {
            // Do nothing.
        }
        const debugBaseUrl = `${serveConfig.https ? 'https' : 'http'}://${serveConfig.hostname || 'localhost'}:${serveConfig.port || 4321}/dist/`;
        let cdnBaseUrl;
        try {
            const writeManifestsConfig = await node_core_library_1.JsonFile.loadAsync(path.join(options.folders.buildFolder, 'config', 'write-manifests.json'));
            cdnBaseUrl = writeManifestsConfig.cdnBasePath;
        }
        catch (e) {
            // Do nothing.
        }
        config.plugins.push(new ManifestPlugin_1.ManifestPlugin({
            terminal,
            selectedLocales,
            sourceLocaleName: constants_1.DEFAULT_LOCALE,
            bundleEntries: bundleEntries,
            internalModuleBaseUrls: cdnBaseUrl ? [cdnBaseUrl] : [],
            debugInternalModuleBaseUrls: [debugBaseUrl],
            linkedExternals: linkedExternals,
            referencedProjects: referencedProjects,
            cumulativeManifestProcessor: cumulativeManifestProcessor,
            translatedStrings: localizedData,
            releaseDropPath: options.folders.releaseFolder,
            asyncOnlyDependencies: {
                asyncOnlyDependencyNames: options.configJson.asyncComponents || [],
                violationsAsErrors: options.production
            },
            componentDependenciesAuditDropPath: path.join(options.folders.releaseFolder, 'component-dependency-audit', `${path.basename(options.folders.buildFolder)}.json`)
        }));
        if (options.production) {
            config.optimization.minimize = true;
            config.optimization.minimizer = [
                new terser_webpack_plugin_1.default({
                    terserOptions: {
                        compress: {
                            passes: 3,
                            warnings: false
                        },
                        mangle: true,
                        output: {
                            comments: false,
                            wrap_func_args: false
                        }
                    }
                    // @todo: VSO#822086 - Remove `as Object` once typings are updated.
                })
            ];
            config.plugins.push(new CopyReleaseAssetsPlugin_1.CopyReleaseAssetsPlugin({
                releasePath: options.folders.releaseFolder,
                assetsFolderName: options.assetsAreVersioned ? VERSIONED_ASSETS_FOLDER_NAME : ASSETS_FOLDER_NAME
            }));
        }
        return config;
    }
    static getComponentsBundleId(manifests) {
        return manifests.map((manifest) => `${manifest.id}_${manifest.version}`).join('+');
    }
    static _getBundleId(bundle) {
        const manifests = [];
        Object.keys(bundle.components).forEach((id) => manifests.push(bundle.components[id].manifestData));
        return WebpackConfigurationGenerator.getComponentsBundleId(manifests);
    }
    /**
     * Writes the entrypoint file to the temp directory and returns the path to the file.
     */
    static _generateBundleEntrypointFile(options) {
        const filePath = path.join(options.tempFolder, 'bundle-entries', `${options.bundleEntry.bundleName}.js`);
        const fileLines = ['Object.defineProperty(exports, "__esModule", { value: true });', ''];
        for (const [componentId, bundleComponent] of Object.entries(options.bundleEntry.components)) {
            const fullEntrypointPath = node_core_library_1.Import.resolveModule({
                modulePath: bundleComponent.entrypoint,
                baseFolderPath: options.buildFolder
            });
            bundleComponent.exportName = componentId;
            fileLines.push(`exports['${componentId}'] = require('${fullEntrypointPath.replace(/\\/g, '/')}');`);
        }
        const fileContents = fileLines.join('\n');
        node_core_library_1.FileSystem.writeFile(filePath, fileContents, { ensureFolderExists: true });
        return filePath;
    }
    static _requireResolveWithCorrectCase(packageName) {
        const resolveResult = node_core_library_1.Import.resolvePackage({ packageName, baseFolderPath: __dirname });
        return true_case_path_1.trueCasePathSync(resolveResult);
    }
    static _validateEntries(configJson, rootPath) {
        if (configJson.bundles) {
            const entrypointPaths = new Set();
            const manifestPaths = new Set();
            for (const [, bundleEntry] of Object.entries(configJson.bundles)) {
                for (const component of bundleEntry.components) {
                    const entrypointPath = node_core_library_1.Import.resolveModule({
                        modulePath: component.entrypoint,
                        baseFolderPath: rootPath
                    }).toUpperCase();
                    if (entrypointPaths.has(entrypointPath)) {
                        throw new Error(`Entry path "${entrypointPath}" occurs in multiple config.json components. This is not supported.`);
                    }
                    else {
                        entrypointPaths.add(entrypointPath);
                    }
                    const manifestPath = path.resolve(path.join(rootPath, component.manifest)).toUpperCase();
                    if (manifestPaths.has(manifestPath)) {
                        throw new Error(`Manifest path "${manifestPath}" occurs in multiple config.json components. This is not ` +
                            'supported.');
                    }
                    else {
                        manifestPaths.add(manifestPath);
                    }
                }
            }
        }
    }
}
exports.WebpackConfigurationGenerator = WebpackConfigurationGenerator;
//# sourceMappingURL=WebpackConfigurationGenerator.js.map