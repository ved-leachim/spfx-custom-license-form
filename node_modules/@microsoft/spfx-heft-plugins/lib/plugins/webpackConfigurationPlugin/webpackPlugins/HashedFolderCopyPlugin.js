"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HashedFolderCopyPlugin = void 0;
const path = __importStar(require("path"));
const glob = __importStar(require("glob"));
const crypto_1 = __importDefault(require("crypto"));
const node_core_library_1 = require("@rushstack/node-core-library");
// tslint:disable-next-line:variable-name
const ParserHelpers = require('webpack/lib/ParserHelpers');
// tslint:disable-next-line:variable-name
const ConstDependency = require('webpack/lib/dependencies/ConstDependency');
const PLUGIN_NAME = 'hashed-folder-copy-plugin';
const EXPRESSION_NAME = 'requireFolder';
/**
 * This plugin copies all files in a to the output folder
 */
class HashedFolderCopyPlugin {
    apply(compiler) {
        compiler.hooks.normalModuleFactory.tap(PLUGIN_NAME, (normalModuleFactory) => {
            const handler = (baseParser) => {
                const parser = baseParser;
                parser.hooks.call.for(EXPRESSION_NAME).tap(PLUGIN_NAME, (expression) => {
                    let errorMessage;
                    let requireFolderOptions = undefined;
                    if (expression.arguments.length !== 1) {
                        errorMessage = `Exactly one argument is required to be passed to "${EXPRESSION_NAME}"`;
                    }
                    else {
                        const argument = expression.arguments[0];
                        try {
                            requireFolderOptions = this._evaluateAcornNode(argument);
                        }
                        catch (e) {
                            errorMessage = e.message;
                        }
                        if (requireFolderOptions) {
                            if (!requireFolderOptions.outputFolder ||
                                typeof requireFolderOptions.outputFolder !== 'string') {
                                errorMessage = 'The options object must have a "outputFolder" property that is a string';
                            }
                            else if (!requireFolderOptions.sources || !Array.isArray(requireFolderOptions.sources)) {
                                errorMessage = 'The options object must have a "sources" property that is an array';
                            }
                            else {
                                for (const source of requireFolderOptions.sources) {
                                    if (!source.globsBase || typeof source.globsBase !== 'string') {
                                        errorMessage = 'Each "sources" element must have a string "globsBase" property';
                                    }
                                    else if (!source.globPaths ||
                                        !Array.isArray(source.globPaths) ||
                                        source.globPaths.some((globPath) => !globPath || typeof globPath !== 'string')) {
                                        errorMessage =
                                            'Each "sources" element must have a "globPaths" property that is an array of glob strings';
                                    }
                                }
                            }
                        }
                    }
                    const currentModule = parser.state.current;
                    const compilation = parser.state.compilation;
                    let dependencyText;
                    if (!requireFolderOptions) {
                        dependencyText = this._renderError(errorMessage);
                        compilation.errors.push(new Error(errorMessage));
                    }
                    else {
                        dependencyText = this._collectAssets({
                            module: currentModule,
                            compilation,
                            requireFolderOptions
                        });
                    }
                    const errorDependency = new ConstDependency(`/* ${EXPRESSION_NAME} */ ${dependencyText}`, expression.range, false);
                    errorDependency.loc = expression.loc;
                    currentModule.addDependency(errorDependency);
                });
                parser.hooks.evaluateTypeof
                    .for(EXPRESSION_NAME)
                    .tap(PLUGIN_NAME, ParserHelpers.evaluateToString('function'));
                parser.hooks.typeof
                    .for(EXPRESSION_NAME)
                    .tap(PLUGIN_NAME, ParserHelpers.toConstantDependency(parser, JSON.stringify('function')));
            };
            normalModuleFactory.hooks.parser.for('javascript/auto').tap(PLUGIN_NAME, handler);
            normalModuleFactory.hooks.parser.for('javascript/dynamic').tap(PLUGIN_NAME, handler);
        });
    }
    _collectAssets(options) {
        const { module, compilation, requireFolderOptions } = options;
        // Map of asset names (to be prepended by the outputFolder) to asset objects
        const assetsToAdd = new Map();
        for (const source of requireFolderOptions.sources) {
            const { globsBase, globPaths } = source;
            let resolvedGlobsBase;
            if (globsBase.startsWith('.')) {
                // Does this look like a relative path?
                resolvedGlobsBase = path.resolve(module.context, globsBase);
            }
            else if (path.isAbsolute(globsBase)) {
                // This is an absolute path
                resolvedGlobsBase = globsBase;
            }
            else {
                // This looks like a NodeJS module path
                let slashAfterPackageNameIndex;
                if (globsBase.startsWith('@')) {
                    // The package name has a scope
                    slashAfterPackageNameIndex = globsBase.indexOf('/', globsBase.indexOf('/') + 1);
                }
                else {
                    slashAfterPackageNameIndex = globsBase.indexOf('/');
                }
                let packageName;
                let pathInsidePackage;
                if (slashAfterPackageNameIndex === -1) {
                    packageName = globsBase;
                    pathInsidePackage = '';
                }
                else {
                    packageName = globsBase.substr(0, slashAfterPackageNameIndex);
                    pathInsidePackage = globsBase.substr(slashAfterPackageNameIndex + 1);
                }
                let packagePath;
                try {
                    packagePath = node_core_library_1.Import.resolvePackage({
                        packageName: packageName,
                        baseFolderPath: module.context
                    });
                }
                catch (e) {
                    const errorMessage = `Unable to resolve package "${packageName}"`;
                    compilation.errors.push(new Error(errorMessage));
                    return this._renderError(errorMessage);
                }
                resolvedGlobsBase = path.join(packagePath, pathInsidePackage);
            }
            for (const globPath of globPaths) {
                const globResults = glob.sync(globPath, { cwd: resolvedGlobsBase });
                for (const globResult of globResults) {
                    const globResultFullPath = path.resolve(resolvedGlobsBase, globResult);
                    if (assetsToAdd.has(globResult)) {
                        const errorMessage = `Two files resolve to the same output path "${globResult}"`;
                        compilation.errors.push(new Error(errorMessage));
                        return this._renderError(errorMessage);
                    }
                    const assetContents = node_core_library_1.FileSystem.readFileToBuffer(globResultFullPath);
                    assetsToAdd.set(globResult, { size: () => assetContents.byteLength, source: () => assetContents });
                    module.buildInfo.fileDependencies.add(globResultFullPath);
                }
            }
        }
        const hash = crypto_1.default.createHash('md5');
        // Sort the paths to maximize hash stability
        for (const assetPath of Array.from(assetsToAdd.keys()).sort()) {
            hash.update(assetPath);
            hash.update(assetsToAdd.get(assetPath).source());
        }
        const hashTokenRegex = /\[hash:?(\d+)?\]/g;
        const hashDigest = hash.digest('hex');
        let pathPrefix = requireFolderOptions.outputFolder.replace(hashTokenRegex, (match, length) => {
            const hashLength = length ? Number.parseInt(length, 10) : undefined;
            if (hashLength) {
                return hashDigest.substr(0, hashLength);
            }
            else {
                return hashDigest;
            }
        });
        pathPrefix = path.posix.join(pathPrefix, '/'); // Ensure trailing slash
        if (!module.buildInfo.assets) {
            module.buildInfo.assets = {};
        }
        const existingAssetNames = new Set(Object.keys(compilation.assets));
        for (const [assetPath, asset] of assetsToAdd.entries()) {
            const fullAssetPath = path.posix.join(pathPrefix, assetPath);
            if (existingAssetNames.has(fullAssetPath)) {
                const errorMessage = `An asset with path "${fullAssetPath}" already exists`;
                compilation.errors.push(new Error(errorMessage));
                return this._renderError(errorMessage);
            }
            compilation.assets[fullAssetPath] = asset;
            module.buildInfo.assets[fullAssetPath] = asset;
        }
        return `__webpack_require__.p + ${JSON.stringify(pathPrefix)}`;
    }
    _renderError(errorMessage) {
        return `(function () { throw new Error(${JSON.stringify(errorMessage)}); })()`;
    }
    // tslint:disable-next-line:no-any
    _evaluateAcornNode(node) {
        switch (node.type) {
            case 'Literal': {
                return node.value;
            }
            case 'ObjectExpression': {
                // tslint:disable-next-line:no-any
                const result = {};
                for (const property of node.properties) {
                    const keyNode = property.key;
                    if (keyNode.type !== 'Identifier' || keyNode.computed) {
                        throw new Error('Property keys must be non-computed identifiers');
                    }
                    const key = keyNode.name;
                    // tslint:disable-next-line:no-any
                    const value = this._evaluateAcornNode(property.value);
                    result[key] = value;
                }
                return result;
            }
            case 'ArrayExpression': {
                return node.elements.map((element) => this._evaluateAcornNode(element));
            }
            default: {
                throw new Error(`Unsupported node type: "${node.type}"`);
            }
        }
    }
}
exports.HashedFolderCopyPlugin = HashedFolderCopyPlugin;
//# sourceMappingURL=HashedFolderCopyPlugin.js.map