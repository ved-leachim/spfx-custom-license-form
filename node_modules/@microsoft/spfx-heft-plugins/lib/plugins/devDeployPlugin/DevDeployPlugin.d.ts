import { HeftConfiguration, HeftSession, IHeftPlugin } from '@rushstack/heft';
import { SyncHook, AsyncSeriesWaterfallHook, SyncWaterfallHook, AsyncSeriesHook } from 'tapable';
import { IDevDeployOptions, IDevDeployData } from './DevDeployInterfaces';
/**
 * @public
 */
export declare class DevDeployHooks {
    /**
     * Initialize
     */
    readonly init: SyncHook<IDevDeployOptions>;
    /**
     * Perform any pre processing such as delete any existing deployment info json, clean up dist folder, etc.
     */
    readonly preProcess: SyncHook<void>;
    /**
     * Gets the files to be deployed to the CDN
     */
    readonly getFiles: AsyncSeriesWaterfallHook<IDevDeployData>;
    /**
     * Gets the name of the folder in the container into which files should be uploaded
     */
    readonly getContainerFolderName: SyncWaterfallHook<string>;
    /**
     * Gets the name of the Azure storage account
     */
    readonly getStorageAccountName: SyncWaterfallHook<string>;
    /**
     * Gets the name of the Azure storage account
     */
    readonly getStorageAccessKey: SyncWaterfallHook<string>;
    /**
     * Returns true if the deployment is in a prod environment
     */
    readonly isProd: SyncWaterfallHook<boolean>;
    /**
     * Perform any post processing, usually print the deploy link, save deployment info json, collect library files, etc.
     */
    readonly postProcess: AsyncSeriesHook<void>;
}
/**
 * @public
 */
export interface IDevDeployPluginAccessor {
    hooks: DevDeployHooks;
}
/**
 * @internal
 */
declare class DevDeployPlugin implements IHeftPlugin {
    readonly pluginName: string;
    private _accessor;
    get accessor(): IDevDeployPluginAccessor;
    apply(heftSession: HeftSession, heftConfiguration: HeftConfiguration): void;
    private _installDefaultHooks;
    private _deployAsync;
}
declare const _default: DevDeployPlugin;
export default _default;
//# sourceMappingURL=DevDeployPlugin.d.ts.map