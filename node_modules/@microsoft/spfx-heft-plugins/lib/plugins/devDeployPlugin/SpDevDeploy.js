"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SpDevDeploy = void 0;
const Url = __importStar(require("url"));
const path = __importStar(require("path"));
const glob_1 = __importDefault(require("glob"));
const lodash = __importStar(require("lodash"));
const os_1 = require("os");
const rush_lib_1 = require("@microsoft/rush-lib");
const node_core_library_1 = require("@rushstack/node-core-library");
const gitRepoInfo = require("git-repo-info");
const DevDeployLinkPrinter_1 = require("./DevDeployLinkPrinter");
const UrlUtilities_1 = require("../../utilities/UrlUtilities");
const ManifestsFileBuilder_1 = require("../../spfxManifests/manifestFileBuilder/ManifestsFileBuilder");
const CumulativeManifestProcessor_1 = require("../../spfxManifests/cumulativeManifestProcessor/CumulativeManifestProcessor");
const constants_1 = require("../../utilities/constants");
const IconHandler_1 = require("../../spfxManifests/utilities/IconHandler");
const MANIFESTS_JS_FILENAME = 'manifests.js';
const SP_LOADER_ASSEMBLY_ID = '44bae1a2-d2eb-4e10-8c21-a1dbdce1036f';
/**
 * The type of icon URL defined in a user-created manifest.
 */
var IconPathType;
(function (IconPathType) {
    /**
     * Something that doesn't fit into another category. A warning will be printed.
     */
    IconPathType[IconPathType["Malformed"] = 0] = "Malformed";
    /**
     * An absolute URL. Something that begins with a protocol (i.e. - http://...).
     */
    IconPathType[IconPathType["AbsoluteUrl"] = 1] = "AbsoluteUrl";
    /**
     * A relative URL. Something that begins with an alphanumeric character, but doesn't look like a protocol.
     */
    IconPathType[IconPathType["RelativeUrl"] = 2] = "RelativeUrl";
    /**
     * A relative filesystem path. Something that begins with "./" or "../"
     */
    IconPathType[IconPathType["RelativePath"] = 3] = "RelativePath";
    /**
     * A data:image;... url
     */
    IconPathType[IconPathType["DataUrl"] = 4] = "DataUrl";
})(IconPathType || (IconPathType = {}));
/**
 * @public
 */
class SpDevDeploy {
    constructor(options) {
        this._collisionDetectionMap = new Map();
        this._options = Object.assign({ useRush: false, isolateProjects: true, ignoreCollisions: false, _additionalDirectoriesToInclude: [], _projectDiscoveryMode: CumulativeManifestProcessor_1.DependencyDiscoveryMode.deepSparse }, options);
        if (!this._options._additionalDirectoriesToInclude) {
            this._options._additionalDirectoriesToInclude = [];
        }
        if (!this._options.rootPath) {
            throw new Error('rootPath must be provided.');
        }
        if (!this._options.terminal) {
            throw new Error('Terminal must be provided.');
        }
        this._packageJsonLookup = new node_core_library_1.PackageJsonLookup();
    }
    static getDevDeployContainerDirectoryName() {
        const repoInfo = this._gitRepoInfo;
        const baseContainerName = `dev-${this._userName}-${os_1.hostname()}`;
        if (repoInfo && repoInfo.root && repoInfo.branch) {
            // We're in a git repo
            return (`${baseContainerName}-${this._escapeNonAlphaNumericChars(repoInfo.root)}-` +
                `${this._escapeNonAlphaNumericChars(repoInfo.branch)}`);
        }
        else {
            return `${baseContainerName}-${this._escapeNonAlphaNumericChars(process.cwd())}`;
        }
    }
    static get _gitRepoInfo() {
        if (this.__gitRepoInfo === undefined) {
            try {
                this.__gitRepoInfo = gitRepoInfo();
            }
            catch (error) {
                // There were errors getting gitRepoInfo
                this.__gitRepoInfo = null; // tslint:disable-line:no-null-keyword
            }
        }
        return this.__gitRepoInfo || undefined;
    }
    static get _userName() {
        return (process.env.USERNAME || process.env.LOGNAME || process.env.USER || process.env.LNAME || 'unknown_user');
    }
    /**
     * Escapes non-(alphanumeric/hyphens) with underscores
     */
    static _escapeNonAlphaNumericChars(str) {
        return str.replace(/[^A-Za-z0-9\-]+/g, '_');
    }
    preProcess() {
        const metadataFilePath = this._getMetadataDropPath();
        // Proactively delete the metadata file so we aren't left with invalid metadata from a previous deploy if
        // this deploy fails
        node_core_library_1.FileSystem.deleteFile(metadataFilePath);
    }
    async getFiles() {
        const manifestsFileBuilderOptions = {
            terminal: this._options.terminal
        };
        const cumulativeManifestProcessor = new CumulativeManifestProcessor_1.CumulativeManifestProcessor(Object.assign({ explicitInclude: [SP_LOADER_ASSEMBLY_ID], rootPath: this._options.rootPath, tempFolderName: 'temp', distFolderName: 'dist', includeAssemblies: true }, manifestsFileBuilderOptions));
        let manifests;
        manifests = this._getManifests(cumulativeManifestProcessor);
        const manifestsArray = [];
        this._options.terminal.writeVerboseLine(`Discovered ${Object.keys(manifests).length} projects.`);
        const filesToUpload = [];
        const foldersToUpload = new Map();
        const projectContainerNames = new Map(); // Ensure we don't reuse a name
        let spLoaderFolderPath = '';
        let debugSPLoader = '';
        // Loop through the manifests and collect files and directories to be uploaded, and fix up manifest fields
        for (const id in manifests) {
            if (manifests.hasOwnProperty(id)) {
                for (const version in manifests[id]) {
                    if (manifests[id].hasOwnProperty(version)) {
                        const referencedProject = manifests[id][version];
                        const manifest = referencedProject.manifestData;
                        const loaderConfig = manifest.loaderConfig;
                        this._options.terminal.writeVerboseLine(`Processing ${id}@${version} (${manifest.alias}) in "${referencedProject.manifestPath}"...`);
                        manifestsArray.push(manifest);
                        const projectContainerName = this._options.isolateProjects
                            ? this._getDestinationDirName(projectContainerNames, referencedProject.manifestPath)
                            : '.';
                        // A relative base URL applies when the paths are based on the tenant URL.
                        // This applies, for example, in the JSOM library, that takes the JS files from a known place
                        // available on every tenant.
                        const isBaseUrlRelative = loaderConfig.internalModuleBaseUrls.length > 0 &&
                            !Url.parse(loaderConfig.internalModuleBaseUrls[0]).protocol;
                        // If the Base URL is a relative path, keep the relative path
                        if (!isBaseUrlRelative) {
                            loaderConfig.internalModuleBaseUrls = [];
                        }
                        const manifestFolderPath = path.dirname(referencedProject.manifestPath);
                        const processPath = (resourcePath) => {
                            // If the base URL was relative, a relative path for a resource doesn't need to be fixed up
                            if (UrlUtilities_1.UrlUtilities.isUrl(resourcePath) || isBaseUrlRelative) {
                                return resourcePath; // Do not deal with fully-qualified URL.
                            }
                            else {
                                this._options.terminal.writeVerboseLine(`    Processing resource path ${resourcePath}`);
                                const filesystemPath = path.join(manifestFolderPath, resourcePath);
                                const filename = path.basename(resourcePath);
                                // Path resources are in the 'dist' folder by default and usually have some secondary
                                // references, so let's just upload the whole folder.
                                const filesystemFolder = path.dirname(filesystemPath);
                                this._options.terminal.writeVerboseLine(`    Added ${filesystemFolder} to folders to upload`);
                                foldersToUpload.set(filesystemFolder, projectContainerName);
                                if (!spLoaderFolderPath && id === SP_LOADER_ASSEMBLY_ID) {
                                    spLoaderFolderPath = projectContainerName;
                                    debugSPLoader = filename;
                                }
                                return UrlUtilities_1.UrlUtilities.joinUrlSegments(projectContainerName, filename);
                            }
                        };
                        this._doComponentTypeSpecificFixup(manifest, processPath);
                        this._processAllPathsInManifest(manifest, processPath);
                        if (this._options._additionalDirectoriesToInclude) {
                            for (const additionalDirectoryToInclude of this._options._additionalDirectoriesToInclude) {
                                const resolvedFolder = path.resolve(manifestFolderPath, additionalDirectoryToInclude);
                                this._options.terminal.writeVerboseLine(`    Added ${resolvedFolder} to folders to upload`);
                                foldersToUpload.set(resolvedFolder, projectContainerName);
                            }
                            this._options.terminal.writeVerboseLine(`Processing ${id}@${version} (${manifest.alias})...DONE`);
                        }
                    }
                }
            }
        }
        // Expand directories to individual files
        const directoryExpandPromises = [];
        for (const [localDirName, deployDirName] of foldersToUpload) {
            directoryExpandPromises.push(this._getFilesInDirectory(localDirName).then((files) => {
                this._options.terminal.writeVerboseLine(`Found ${files.length} items in ${localDirName}`);
                for (const file of files) {
                    const deployPath = UrlUtilities_1.UrlUtilities.joinUrlSegments(deployDirName, file.replace(/\\/g, '/'));
                    const localPath = path.join(localDirName, file);
                    if (node_core_library_1.FileSystem.getStatistics(localPath).isDirectory()) {
                        this._options.terminal.writeVerboseLine(`    Skipping folder ${localPath}`);
                        continue; // Continue on directories
                    }
                    if (!this._options.isolateProjects) {
                        if (this._collisionDetectionMap.has(deployPath)) {
                            this._collisionDetectionMap.get(deployPath).push(localPath);
                        }
                        else {
                            this._collisionDetectionMap.set(deployPath, [localPath]);
                        }
                    }
                    filesToUpload.push({
                        localPath,
                        deployPath
                    });
                }
            }));
        }
        await Promise.all(directoryExpandPromises);
        const manifestsFileBuilder = new ManifestsFileBuilder_1.ManifestsFileBuilder(manifestsFileBuilderOptions);
        const manifestsFileFullPath = path.join(this._options.rootPath, 'temp', 'dev-deploy', MANIFESTS_JS_FILENAME);
        await manifestsFileBuilder.buildManifestsJs(manifestsArray, manifestsFileFullPath);
        filesToUpload.push({
            localPath: manifestsFileFullPath,
            deployPath: MANIFESTS_JS_FILENAME
        });
        const deployBaseUrl = this._getDeployBaseUrl();
        this._devDeployManifestFileUrl = UrlUtilities_1.UrlUtilities.joinUrlSegments(deployBaseUrl, SpDevDeploy.debugManifestPath);
        this._devDeployModuleLoaderUrl = UrlUtilities_1.UrlUtilities.joinUrlSegments(deployBaseUrl, spLoaderFolderPath, debugSPLoader);
        return {
            filesToUpload,
            loaderPath: this._devDeployModuleLoaderUrl,
            debugManifestPath: SpDevDeploy.debugManifestPath
        };
    }
    postProcess() {
        if (!this._options.ignoreCollisions) {
            this._printCollisionWarnings();
        }
        this._options.terminal.writeLine();
        this._printDevDeployLink();
        this._options.terminal.writeLine();
        this._saveDevDeployMetadata();
    }
    _printCollisionWarnings() {
        // Warn about collisions
        this._collisionDetectionMap.forEach((localPaths, url) => {
            if (localPaths.length > 1 && !this._doesFilenameAppearToContainHash(localPaths[0])) {
                this._options.terminal.writeWarningLine(`COLLISION DETECTED: [${localPaths.join(',')}] all deployed to the same URL (${url}). ` +
                    `It is very probable that the dev-deploy will not work as expected. This may indicate a ` +
                    `serious issue for production environments as well.`);
            }
        });
    }
    _saveDevDeployMetadata() {
        const dropPath = this._getMetadataDropPath();
        node_core_library_1.JsonFile.save(this._devDeployMetadata, dropPath, { ensureFolderExists: true });
    }
    _printDevDeployLink() {
        const deployBaseUrl = this._getDeployBaseUrl();
        if (!this._devDeployModuleLoaderUrl || !this._devDeployManifestFileUrl) {
            throw new Error('"_devDeployModuleLoaderUrl" and "_devDeployManifestFileUrl" must be defined');
        }
        this._devDeployMetadata = {
            loaderUrl: this._devDeployModuleLoaderUrl,
            debugManifestUrl: this._devDeployManifestFileUrl,
            deployUrl: deployBaseUrl
        };
        DevDeployLinkPrinter_1.printDevDeployLink(this._options.terminal.writeLine.bind(this._options.terminal), this._devDeployMetadata);
    }
    _getDeployBaseUrl() {
        if (this._options.devDeployConfig.folderNameInContainer) {
            return UrlUtilities_1.UrlUtilities.joinUrlSegments(this._getContainerUrl(), this._options.devDeployConfig.folderNameInContainer);
        }
        else {
            return this._getContainerUrl();
        }
    }
    _getContainerUrl() {
        return this._getAzureStorageUrl(this._options.devDeployConfig.accountName, this._options.devDeployConfig.container);
    }
    _getAzureStorageUrl(accountName, containerName) {
        return UrlUtilities_1.UrlUtilities.joinUrlSegments(`https://${accountName}.blob.core.windows.net`, containerName || '');
    }
    _processAllPathsInManifest({ loaderConfig }, pathProcessFunction) {
        for (const scriptResourceId in loaderConfig.scriptResources) {
            if (loaderConfig.scriptResources.hasOwnProperty(scriptResourceId)) {
                const scriptResource = loaderConfig.scriptResources[scriptResourceId];
                switch (scriptResource.type) {
                    case 'path': {
                        // Path script resource, we need to fix up its path and upload it
                        const pathResource = scriptResource;
                        pathResource.path = pathProcessFunction(this._disambiguatePath(pathResource.path));
                        break;
                    }
                    case 'component': {
                        // We probably don't need to upload the fallback file, and it's nigh-impossible to tell if we'll
                        // miss secondary dependencies by only uploading the file at the failoverPath, so we'll just clear
                        // it out and hope this dependency is either satisfied by another dev-deploy manifest or by the OOB
                        // framework
                        const componentResource = scriptResource;
                        componentResource.failoverPath = undefined;
                        break;
                    }
                    case 'localizedPath': {
                        // Localized path script resource, we need to fix up the paths for each locale and upload each file
                        const localizedPathResource = scriptResource;
                        // Select en-us if it exists, otherwise pass through the default path.
                        const pathToProcess = (localizedPathResource.paths
                            ? localizedPathResource.paths[constants_1.DEFAULT_LOCALE]
                            : localizedPathResource.defaultPath) || localizedPathResource.defaultPath;
                        localizedPathResource.defaultPath = pathProcessFunction(this._disambiguatePath(pathToProcess));
                        if (localizedPathResource.paths) {
                            for (const locale in localizedPathResource.paths) {
                                if (localizedPathResource.paths.hasOwnProperty(locale)) {
                                    localizedPathResource.paths[locale] = pathProcessFunction(this._disambiguatePath(localizedPathResource.paths[locale]));
                                }
                            }
                        }
                        break;
                    }
                }
            }
        }
    }
    _disambiguatePath(pathToDisambiguate) {
        return typeof pathToDisambiguate === 'string'
            ? pathToDisambiguate
            : pathToDisambiguate.default;
    }
    _getFilesInDirectory(dirName) {
        return node_core_library_1.LegacyAdapters.convertCallbackToPromise(glob_1.default, path.join('**', '*.*'), { cwd: dirName });
    }
    /**
     * This function returns a directory name to be used in a directory in the destination, ensuring that the name does
     * not collide with another directory's name. It also ensures that if the specified filesystem path has already
     * been mapped to a destination directory, the same name is used in the destination.
     */
    _getDestinationDirName(directoryMap, filesystemPath) {
        const projectFolder = this._packageJsonLookup.tryGetPackageFolderFor(filesystemPath);
        if (!projectFolder) {
            throw new Error(`Unable to find a project folder for "${filesystemPath}"`);
        }
        let destinationDirName = path.basename(projectFolder).toLowerCase();
        if (directoryMap.has(destinationDirName)) {
            const existingPaths = directoryMap.get(destinationDirName);
            if (!existingPaths) {
                throw new Error("Couldn't get paths");
            }
            const currentPathId = existingPaths.indexOf(filesystemPath);
            if (currentPathId === -1) {
                destinationDirName = `${destinationDirName}_${existingPaths.length}`;
                existingPaths.push(filesystemPath);
            }
            else if (currentPathId > 0) {
                destinationDirName = `${destinationDirName}_${currentPathId}`;
            }
        }
        else {
            directoryMap.set(destinationDirName, [filesystemPath]);
        }
        return destinationDirName;
    }
    _getManifests(cumulativeManifestProcessor) {
        if (this._options.useRush) {
            const rushConfig = this._getRushConfig();
            if (!rushConfig) {
                throw 'Unable to find the rush configuration file.';
            }
            let manifests;
            const directories = rushConfig.projects.map((proj) => proj.projectFolder);
            manifests = cumulativeManifestProcessor.discoverManifests(directories[0], this._options._projectDiscoveryMode);
            for (let i = 1; i < directories.length; i++) {
                const projectManifests = cumulativeManifestProcessor.discoverManifests(directories[i], this._options._projectDiscoveryMode);
                manifests = this._mergeReferencedProjectLists(manifests, projectManifests);
            }
            return manifests;
        }
        else {
            return cumulativeManifestProcessor.discoverManifests(this._options.rootPath, this._options._projectDiscoveryMode);
        }
    }
    _mergeReferencedProjectLists(list1, list2) {
        const ids = new Set();
        Object.keys(list1)
            .concat(Object.keys(list2))
            .forEach((id) => ids.add(id));
        const result = {};
        ids.forEach((id) => {
            const list1Versions = list1[id];
            const list2Versions = list2[id];
            if (!list1Versions || !list2Versions) {
                // Element is only present in one list
                result[id] = list1Versions || list2Versions;
            }
            else {
                // Arrays are present in both lists, merge them together
                const versionMapping = {};
                function addVersionsToMapping(referencedVersions) {
                    for (const version in referencedVersions) {
                        if (!versionMapping[version] ||
                            referencedVersions[version].manifestCreationTime > versionMapping[version].manifestCreationTime) {
                            versionMapping[version] = referencedVersions[version];
                        }
                    }
                }
                addVersionsToMapping(list1Versions);
                addVersionsToMapping(list2Versions);
                result[id] = versionMapping;
            }
        });
        return result;
    }
    _doComponentTypeSpecificFixup(manifest, processPath) {
        switch (manifest.componentType) {
            case 'WebPart':
                // tslint:disable-next-line:no-any
                const webpartManifest = manifest;
                for (const preconfiguredEntry of webpartManifest.preconfiguredEntries) {
                    if (preconfiguredEntry.iconImageUrl) {
                        preconfiguredEntry.iconImageUrl = this._fixupIconPath(preconfiguredEntry.iconImageUrl, processPath);
                    }
                }
                break;
            case 'Extension':
                const extensionManifest = manifest;
                switch (extensionManifest.extensionType) {
                    case 'ListViewCommandSet':
                        const commandSetManifest = extensionManifest;
                        for (const itemId in commandSetManifest.items) {
                            if (commandSetManifest.items.hasOwnProperty(itemId)) {
                                const item = commandSetManifest.items[itemId];
                                if (item.iconImageUrl) {
                                    item.iconImageUrl = this._fixupIconPath(item.iconImageUrl, processPath);
                                }
                            }
                        }
                        break;
                    default:
                        // Nothing to do for the other extension types
                        break;
                }
                break;
            default:
                // Nothing to do for the other component types
                break;
        }
    }
    _fixupIconPath(iconPath, processPath) {
        if (IconHandler_1.IconHandler.getIconPathType(iconPath) === IconPathType.RelativeUrl) {
            const relativeIconPath = lodash.trimStart(iconPath, '/');
            return processPath(relativeIconPath);
        }
        else {
            return iconPath;
        }
    }
    _getRushConfig() {
        if (!this._rushConfig) {
            this._rushConfig = rush_lib_1.RushConfiguration.loadFromDefaultLocation();
        }
        return this._rushConfig;
    }
    _getMetadataDropPath() {
        const METADATA_FILENAME = 'dev-deploy-metadata.json';
        const rushConfig = this._getRushConfig();
        if (!rushConfig) {
            throw 'Unable to find the rush configuration file.';
        }
        const commonTempDirectory = rushConfig.commonTempFolder;
        return path.join(commonTempDirectory, METADATA_FILENAME);
    }
    _doesFilenameAppearToContainHash(filePath) {
        const filename = path.basename(filePath, path.extname(filePath));
        // Look for a hexadecimal string at the end of the filename that is at least 5 characters long and
        // starts with an underscore (_) or a hyphen (-).
        return !!filename.match(/[_-][a-f0-9]{5,}$/i);
    }
}
exports.SpDevDeploy = SpDevDeploy;
SpDevDeploy.debugManifestPath = MANIFESTS_JS_FILENAME;
//# sourceMappingURL=SpDevDeploy.js.map