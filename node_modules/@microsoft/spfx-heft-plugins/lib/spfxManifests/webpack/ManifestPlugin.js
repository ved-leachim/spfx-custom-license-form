"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ManifestPlugin = void 0;
const path = __importStar(require("path"));
const lodash = __importStar(require("lodash"));
const node_core_library_1 = require("@rushstack/node-core-library");
const localization_plugin_1 = require("@rushstack/localization-plugin");
const LocalizedManifestModuleProcessor_1 = require("./LocalizedManifestModuleProcessor");
const IconHandler_1 = require("../utilities/IconHandler");
const TerminalHelper_1 = require("../utilities/TerminalHelper");
const normalizeLocaleName_1 = require("../../utilities/normalizeLocaleName");
const PLUGIN_NAME = 'manifest';
const MANIFEST_ASSET_SYMBOL = Symbol('spfx-manifest');
const MANIFESTS_FOLDER_NAME = 'manifests';
/**
 * @internal
 */
class ManifestPlugin {
    constructor(options) {
        this._locFileCache = new Map();
        this._options = options;
    }
    static isManifestAsset(asset) {
        return !!asset[MANIFEST_ASSET_SYMBOL];
    }
    apply(compiler) {
        compiler.hooks.emit.tapPromise(PLUGIN_NAME, async (baseCompilation) => {
            var _a, _b;
            const compilation = baseCompilation;
            const producedManifests = [];
            const asyncOnlyDependencies = new Set(((_a = this._options.asyncOnlyDependencies) === null || _a === void 0 ? void 0 : _a.asyncOnlyDependencyNames) || []);
            const asyncOnlyDependenciesViolationsAsErrors = !!((_b = this._options.asyncOnlyDependencies) === null || _b === void 0 ? void 0 : _b.violationsAsErrors);
            const terminal = TerminalHelper_1.TerminalHelper.getTerminalForWebpackPlugin(compilation);
            const componentDependenciesAuditFile = {
                bundles: {}
            };
            for (const bundleEntry of this._options.bundleEntries) {
                try {
                    const dependenciesForAudit = new Map();
                    function emitAsset(assetName, assetContents) {
                        const asset = {
                            source: () => assetContents,
                            size: () => assetContents.length,
                            [MANIFEST_ASSET_SYMBOL]: undefined
                        };
                        compilation.assets[assetName] = asset;
                        return asset;
                    }
                    const baseLoaderConfiguration = await this._generateLoaderConfigurationAsync(terminal, bundleEntry.bundleName, compilation, asyncOnlyDependencies, asyncOnlyDependenciesViolationsAsErrors, dependenciesForAudit, emitAsset);
                    const componentDependenciesAuditFileBundle = {
                        dependencies: Array.from(dependenciesForAudit.values())
                    };
                    for (const [componentId, bundleComponent] of Object.entries(bundleEntry.components)) {
                        const manifest = this._generateComponentManifest(terminal, compilation, bundleComponent, baseLoaderConfiguration);
                        // Write debug component manifest
                        manifest.loaderConfig.internalModuleBaseUrls = this._options.debugInternalModuleBaseUrls;
                        const serializedManifest = JSON.stringify(manifest, undefined, 2);
                        const manifestAsset = emitAsset(`${componentId}.manifest.json`, serializedManifest);
                        manifestAsset[MANIFEST_ASSET_SYMBOL] = true;
                        producedManifests.push(manifest);
                        componentDependenciesAuditFile.bundles[bundleEntry.bundleName] = componentDependenciesAuditFileBundle;
                        // Write release component manifest
                        const releaseManifest = JSON.parse(JSON.stringify(manifest));
                        releaseManifest.loaderConfig.internalModuleBaseUrls = this._options.internalModuleBaseUrls;
                        const serializedReleaseManifest = JSON.stringify(releaseManifest, undefined, 2);
                        emitAsset(`../release/${MANIFESTS_FOLDER_NAME}/${componentId}.manifest.json`, // use releaseDropPath
                        serializedReleaseManifest);
                    }
                }
                catch (error) {
                    compilation.errors.push(error);
                    // Unable to generate manifest entrypoint - continue to the next bundle entry
                }
            }
            if (this._options.componentDependenciesAuditDropPath) {
                await node_core_library_1.JsonFile.saveAsync(componentDependenciesAuditFile, this._options.componentDependenciesAuditDropPath, {
                    ensureFolderExists: true
                });
            }
            await this._options.cumulativeManifestProcessor.generateCumulativeManifest(producedManifests);
        });
    }
    /**
     * @virtual
     */
    async _generateLoaderConfigurationAsync(terminal, bundleName, compilation, asyncOnlyDependencies, asyncOnlyDependenciesViolationsAsErrors, dependenciesForAudit, emitAsset) {
        const entrypoint = compilation.entrypoints.get(bundleName);
        if (!entrypoint) {
            throw new Error(`Expected to find an entrypoint with name "${bundleName}".`);
        }
        const runtimeChunk = this._getRuntimeChunk(bundleName, entrypoint);
        const scriptResources = await this._getExternalsScriptResourcesAsync(terminal, bundleName, runtimeChunk, asyncOnlyDependencies, asyncOnlyDependenciesViolationsAsErrors, dependenciesForAudit, emitAsset);
        const entrypointManifestModule = this._getEntryManifestModule(bundleName, runtimeChunk);
        const loaderConfiguration = {
            internalModuleBaseUrls: this._options.internalModuleBaseUrls,
            entryModuleId: bundleName,
            scriptResources: Object.assign({ [bundleName]: entrypointManifestModule }, scriptResources)
        };
        return loaderConfiguration;
    }
    _getRuntimeChunk(bundleName, entrypoint) {
        const { runtimeChunk } = entrypoint;
        if (!runtimeChunk) {
            throw new Error(`Expected to find an runtime chunk with name "${bundleName}".`);
        }
        else {
            return runtimeChunk;
        }
    }
    async _getExternalsScriptResourcesAsync(terminal, bundleName, runtimeChunk, asyncOnlyDependencies, asyncOnlyDependenciesViolationsAsErrors, dependenciesForAudit, emitAsset) {
        const scriptResources = {};
        for (const module of runtimeChunk.getModules()) {
            const externalModule = module;
            if (externalModule.external) {
                const externalName = externalModule.request;
                if (asyncOnlyDependencies.has(externalName)) {
                    const message = `Dependency "${externalName}" is marked as async-only, but is used ` +
                        `synchronously in bundle "${bundleName}"`;
                    if (asyncOnlyDependenciesViolationsAsErrors) {
                        terminal.writeError(message);
                    }
                    else {
                        terminal.writeWarning(message);
                    }
                }
                if (bundleName === externalName) {
                    throw new Error(`Bundle name "${bundleName}" collides with a dependent component name.`);
                }
                let externalManifestModules;
                const externalComponent = this._options.linkedExternals[externalName];
                if (externalComponent) {
                    if (!externalComponent.version) {
                        throw new Error(`External "${externalName}" has an unresolved version.`);
                    }
                    const externalComponentModule = {
                        type: 'component',
                        id: externalComponent.id,
                        version: externalComponent.version
                    };
                    this._populateLinkedExternalComponentInDependencyMap(externalComponent.name, externalComponent.id, externalComponent.version, true, dependenciesForAudit);
                    externalManifestModules = { [externalName]: externalComponentModule };
                }
                else {
                    const legacyExternal = this._options.tryGetLegacyExternalByNameAsync
                        ? await this._options.tryGetLegacyExternalByNameAsync(externalName)
                        : undefined;
                    if (legacyExternal) {
                        externalManifestModules = legacyExternal.moduleConfigurations;
                        for (const [assetName, assetContents] of Object.entries(legacyExternal.assets)) {
                            emitAsset(assetName, assetContents);
                        }
                    }
                    else {
                        throw new Error(`Did not find linked external "${externalName}" for bundle "${bundleName}".`);
                    }
                }
                for (const [name, external] of Object.entries(externalManifestModules)) {
                    scriptResources[name] = external;
                }
            }
        }
        return scriptResources;
    }
    _getRuntimeChunkFilename(bundleName, runtimeChunk) {
        const hotUpdateRegex = /\.hot-update\.js$/;
        const runtimeChunkFilenames = runtimeChunk.files.filter((file) => {
            return path.extname(file) === '.js' && !hotUpdateRegex.test(file);
        });
        if (runtimeChunkFilenames.length === 0) {
            throw new Error(`Did not find a .js file in the runtime chunk for the "${bundleName}" bundle.`);
        }
        else if (runtimeChunkFilenames.length > 1) {
            throw new Error(`Found more than one .js file in the runtime chunk for the "${bundleName}" bundle.`);
        }
        else {
            return runtimeChunkFilenames[0];
        }
    }
    _generateComponentManifest(terminal, compilation, bundleComponent, baseLoaderConfiguration) {
        const loaderConfig = Object.assign({}, baseLoaderConfiguration);
        if (bundleComponent.exportName) {
            loaderConfig.exportName = bundleComponent.exportName;
        }
        const inputManifest = lodash.cloneDeep(bundleComponent.manifestData);
        // tslint:disable-next-line:no-string-literal
        delete inputManifest['$schema'];
        switch (inputManifest.componentType) {
            case 'WebPart': {
                this._processWebpartManifest(terminal, compilation, bundleComponent.manifestPath, inputManifest);
                break;
            }
            case 'Application': {
                this._processApplicationManifest(terminal, compilation, bundleComponent.manifestPath, inputManifest);
                break;
            }
            case 'Extension': {
                this._processExtensionsManifest(terminal, compilation, bundleComponent.manifestPath, inputManifest);
                break;
            }
        }
        inputManifest.loaderConfig = loaderConfig;
        return inputManifest;
    }
    _processWebpartManifest(terminal, compilation, manifestPath, manifest) {
        for (const entry of manifest.preconfiguredEntries) {
            entry.title = this._localizeString(terminal, compilation, manifestPath, entry.title);
            entry.description = this._localizeString(terminal, compilation, manifestPath, entry.description);
            if (entry.group) {
                entry.group = this._localizeString(terminal, compilation, manifestPath, entry.group);
            }
            if (entry.tags) {
                // We don't allow more than 10 tags
                entry.tags = entry.tags
                    .slice(0, 10)
                    .map((tag) => this._localizeString(terminal, compilation, manifestPath, tag));
            }
            entry.iconImageUrl = IconHandler_1.IconHandler.processIconPath(this._options.terminal, compilation, manifestPath, entry.iconImageUrl);
        }
    }
    _processApplicationManifest(terminal, compilation, manifestPath, manifest) {
        manifest.title = this._localizeString(terminal, compilation, manifestPath, manifest.title);
        manifest.description = this._localizeString(terminal, compilation, manifestPath, manifest.description);
    }
    /**
     * Does extension-specific manifest processing.
     */
    _processExtensionsManifest(terminal, compilation, manifestPath, manifest) {
        switch (manifest.extensionType) {
            case 'ListViewCommandSet':
                const commandSetManifest = manifest;
                for (const itemId in commandSetManifest.items) {
                    if (commandSetManifest.items.hasOwnProperty(itemId)) {
                        const item = commandSetManifest.items[itemId];
                        item.title = this._localizeString(terminal, compilation, manifestPath, item.title);
                        if (item.ariaLabel) {
                            item.ariaLabel = this._localizeString(terminal, compilation, manifestPath, item.ariaLabel);
                        }
                        item.iconImageUrl = IconHandler_1.IconHandler.processIconPath(this._options.terminal, compilation, manifestPath, item.iconImageUrl);
                    }
                }
                break;
            case 'Unknown':
            case 'ApplicationCustomizer':
            case 'FieldCustomizer':
                // No fields that require modification
                break;
        }
    }
    /**
     * Localizes a string with an ID in the form of $<path-to-loc-file>:<string-name>;
     * If the string to localize is not based on an id, it returns the input param untouched.
     */
    _localizeString(terminal, compilation, manifestPath, stringToLocalize) {
        // If there is no id, assume the property is either not localized, or the localized values are
        // hardcoded.
        if (!stringToLocalize.id) {
            return stringToLocalize;
        }
        const EMPTY_LOCALIZED_STRING = {
            default: ''
        };
        const regex = /^(?:\$)([^:]+)(?:\:)(.+)(?:\;)$/; // Test $<path-to-loc-file>:<string-name>;
        const matches = stringToLocalize.id.match(regex) || [];
        if (matches.length === 3) {
            this._options.terminal.writeVerboseLine(`Localizing string '${matches[0]}'`);
            const locFilePath = matches[1];
            const stringName = matches[2];
            const locFileAbsolutePath = path.resolve(path.dirname(manifestPath), locFilePath);
            if (!node_core_library_1.FileSystem.exists(locFileAbsolutePath)) {
                compilation.errors.push(new Error(`Loc file missing from resolved path "${locFileAbsolutePath}". The manifest string will be missing.`));
                return EMPTY_LOCALIZED_STRING;
            }
            else {
                if (!this._locFileCache.has(locFileAbsolutePath)) {
                    this._locFileCache.set(locFileAbsolutePath, localization_plugin_1._LocFileParser.parseLocFile({
                        filePath: locFileAbsolutePath,
                        content: node_core_library_1.FileSystem.readFile(locFileAbsolutePath),
                        terminal,
                        resxNewlineNormalization: "\n" /* Lf */
                    }));
                }
                const locFile = this._locFileCache.get(locFileAbsolutePath);
                if (!locFile[stringName]) {
                    compilation.errors.push(new Error(`Loc file "${locFileAbsolutePath}" doesn't contain a string with name "${stringName}".`));
                    return EMPTY_LOCALIZED_STRING;
                }
                else {
                    const localizedStrings = {};
                    const normalizedSourceLocaleName = normalizeLocaleName_1.normalizeLocaleName(this._options.sourceLocaleName);
                    localizedStrings[normalizedSourceLocaleName] = locFile[stringName].value;
                    const contextRelativeLocFilePath = path
                        .relative(compilation.context || compilation.options.context || '', locFileAbsolutePath)
                        .replace(/\\/g, '/');
                    const selectedLocaleSet = this._options.selectedLocales
                        ? new Set(this._options.selectedLocales)
                        : undefined;
                    for (const [localeName, localizedData] of Object.entries(this._options.translatedStrings)) {
                        if (!selectedLocaleSet || selectedLocaleSet.has(localeName)) {
                            const translatedLocFile = (localizedData[contextRelativeLocFilePath] || localizedData[locFileAbsolutePath]);
                            const normalizedLocaleName = normalizeLocaleName_1.normalizeLocaleName(localeName);
                            if (!translatedLocFile || !translatedLocFile[stringName]) {
                                terminal.writeVerboseLine(`Loc file "${locFilePath}" for locale ${normalizedLocaleName} is either missing or is missing string ` +
                                    `"${stringName}". Falling back to the string from ${normalizedSourceLocaleName}`);
                                localizedStrings[normalizedLocaleName] = locFile[stringName].value;
                            }
                            else {
                                localizedStrings[normalizedLocaleName] = translatedLocFile[stringName];
                            }
                        }
                    }
                    if (this._options.firstPassLocaleRemapping) {
                        LocalizedManifestModuleProcessor_1.LocalizedManifestModuleProcessor.applyLocaleRemapping(localizedStrings, this._options.firstPassLocaleRemapping);
                    }
                    LocalizedManifestModuleProcessor_1.LocalizedManifestModuleProcessor.applyLocaleRemapping(localizedStrings, LocalizedManifestModuleProcessor_1.LocalizedManifestModuleProcessor.LOCALE_MAPPING);
                    // Do this twice because some locales (like en-gb) appear both as values and as keys
                    LocalizedManifestModuleProcessor_1.LocalizedManifestModuleProcessor.applyLocaleRemapping(localizedStrings, LocalizedManifestModuleProcessor_1.LocalizedManifestModuleProcessor.LOCALE_MAPPING);
                    const defaultString = LocalizedManifestModuleProcessor_1.LocalizedManifestModuleProcessor.findDefaultString(localizedStrings);
                    if (defaultString) {
                        localizedStrings.default = defaultString;
                    }
                    else {
                        compilation.errors.push(new Error(`Unable to select a default string for the localized string "${stringToLocalize.id}"`));
                        localizedStrings.default = '';
                    }
                    return localizedStrings;
                }
            }
        }
        else {
            compilation.errors.push(new Error(`String id '${stringToLocalize.id}' has wrong format. It is not $<moduleName>:<expression>;`));
            return EMPTY_LOCALIZED_STRING;
        }
    }
    _getEntryManifestModule(bundleName, runtimeChunk) {
        if (runtimeChunk.localizedFiles) {
            // We have localized files, so this is a localized component
            return LocalizedManifestModuleProcessor_1.LocalizedManifestModuleProcessor.generateLocalizedManifestModule(bundleName, runtimeChunk.localizedFiles, this._options.firstPassLocaleRemapping);
        }
        else {
            // No localized files, so this isn't a localized component
            const runtimeChunkFilename = this._getRuntimeChunkFilename(bundleName, runtimeChunk);
            const moduleConfiguration = {
                type: 'path',
                path: runtimeChunkFilename
            };
            return moduleConfiguration;
        }
    }
    _populateLinkedExternalComponentInDependencyMap(dependencyName, dependencyId, dependencyVersion, isDirectDependency, dependenciesForAudit) {
        const nameWithVersion = dependencyVersion
            ? `${dependencyName}@${dependencyVersion}`
            : dependencyName;
        if (dependenciesForAudit.has(nameWithVersion)) {
            // A dependency name with this version already exists, skip
            return;
        }
        const existingAuditDependency = dependenciesForAudit.get(dependencyName);
        let nameToRecord = dependencyName;
        if (existingAuditDependency) {
            if (existingAuditDependency.componentVersion !== dependencyVersion) {
                // Remove and re-add this dependency to include the version
                dependenciesForAudit.delete(dependencyName);
                dependenciesForAudit.set(`${existingAuditDependency.componentName}@${existingAuditDependency.componentVersion}`, existingAuditDependency);
                nameToRecord = nameWithVersion;
            }
            else {
                // We've already recorded this dependency with this version
                return;
            }
        }
        if (!dependenciesForAudit.has(dependencyName)) {
            dependenciesForAudit.set(nameToRecord, {
                componentId: dependencyId,
                componentName: dependencyName,
                componentVersion: dependencyVersion,
                isDirectDependency
            });
            const referencedDependencyVersions = this._options.referencedProjects[dependencyId];
            if (!referencedDependencyVersions) {
                // If there is no project in referencedProjects, this is probably a non-standard external, so
                // it doesn't have conventional SPFx dependencies
                return;
            }
            let referencedDependency;
            if (dependencyVersion) {
                referencedDependency = referencedDependencyVersions[dependencyVersion];
                if (!referencedDependency) {
                    throw new Error(`Unable to find version "${dependencyVersion}" of component "${dependencyName}"`);
                }
            }
            else {
                const versions = Object.entries(referencedDependencyVersions);
                if (versions.length === 1) {
                    referencedDependency = versions[0][1];
                }
                else if (versions.length === 0) {
                    throw new Error(`No versions exist for dependency "${dependencyName}". This is not expected.`);
                }
                else {
                    throw new Error(`No version specified for "${dependencyName}" and multiple dependency versions exist.`);
                }
            }
            for (const [depName, dep] of Object.entries(referencedDependency.manifestData.loaderConfig.scriptResources)) {
                if (dep.type === 'component') {
                    const componentDependency = dep;
                    this._populateLinkedExternalComponentInDependencyMap(depName, componentDependency.id, componentDependency.version, false, dependenciesForAudit);
                }
            }
        }
    }
}
exports.ManifestPlugin = ManifestPlugin;
//# sourceMappingURL=ManifestPlugin.js.map