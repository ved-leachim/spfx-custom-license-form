"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const nodeJsPath = require("path");
const jsonpath_plus_1 = require("jsonpath-plus");
const node_core_library_1 = require("@rushstack/node-core-library");
/**
 * @beta
 */
var InheritanceType;
(function (InheritanceType) {
    /**
     * Append additional elements after elements from the parent file's property
     */
    InheritanceType["append"] = "append";
    /**
     * Discard elements from the parent file's property
     */
    InheritanceType["replace"] = "replace";
})(InheritanceType = exports.InheritanceType || (exports.InheritanceType = {}));
/**
 * @beta
 */
var PathResolutionMethod;
(function (PathResolutionMethod) {
    /**
     * Resolve a path relative to the configuration file
     */
    PathResolutionMethod[PathResolutionMethod["resolvePathRelativeToConfigurationFile"] = 0] = "resolvePathRelativeToConfigurationFile";
    /**
     * Resolve a path relative to the root of the project containing the configuration file
     */
    PathResolutionMethod[PathResolutionMethod["resolvePathRelativeToProjectRoot"] = 1] = "resolvePathRelativeToProjectRoot";
    /**
     * Treat the property as a NodeJS-style require/import reference and resolve using standard
     * NodeJS filesystem resolution
     */
    PathResolutionMethod[PathResolutionMethod["NodeResolve"] = 2] = "NodeResolve";
})(PathResolutionMethod = exports.PathResolutionMethod || (exports.PathResolutionMethod = {}));
const CONFIGURATION_FILE_FIELD_ANNOTATION = Symbol('configuration-file-field-annotation');
/**
 * @beta
 */
class ConfigurationFile {
    constructor(jsonSchema, options) {
        var _a, _b;
        this._configurationFileCache = new Map();
        this._packageJsonLookup = new node_core_library_1.PackageJsonLookup();
        if (typeof jsonSchema === 'string') {
            jsonSchema = node_core_library_1.JsonSchema.fromFile(jsonSchema);
        }
        this._schema = jsonSchema;
        this._jsonPathMetadata = ((_a = options) === null || _a === void 0 ? void 0 : _a.jsonPathMetadata) || {};
        this._propertyInheritanceTypes = ((_b = options) === null || _b === void 0 ? void 0 : _b.propertyInheritanceTypes) || {};
    }
    async loadConfigurationFileAsync(configurationFilePath) {
        return await this._loadConfigurationFileInnerAsync(nodeJsPath.resolve(configurationFilePath), new Set());
    }
    /**
     * Get the path to the source file that the referenced property was originally
     * loaded from.
     */
    getObjectSourceFilePath(obj) {
        const annotation = obj[CONFIGURATION_FILE_FIELD_ANNOTATION];
        if (annotation) {
            return annotation.configurationFilePath;
        }
        return undefined;
    }
    /**
     * Get the value of the specified property on the specified object that was originally
     * loaded from a configuration file.
     */
    getPropertyOriginalValue(options) {
        const annotation = options.parentObject[CONFIGURATION_FILE_FIELD_ANNOTATION];
        if (annotation && annotation.originalValues.hasOwnProperty(options.propertyName)) {
            return annotation.originalValues[options.propertyName];
        }
        throw new Error(`No original value could be determined for property "${options.propertyName}"`);
    }
    async _loadConfigurationFileInnerAsync(resolvedConfigurationFilePath, visitedConfigurationFilePaths) {
        let cacheEntry = this._configurationFileCache.get(resolvedConfigurationFilePath);
        if (!cacheEntry) {
            try {
                const resolvedConfigurationFilePathForErrors = ConfigurationFile._formatPathForError(resolvedConfigurationFilePath);
                if (visitedConfigurationFilePaths.has(resolvedConfigurationFilePath)) {
                    throw new Error('A loop has been detected in the "extends" properties of configuration file at ' +
                        `"${resolvedConfigurationFilePathForErrors}".`);
                }
                visitedConfigurationFilePaths.add(resolvedConfigurationFilePath);
                let fileText;
                try {
                    fileText = await node_core_library_1.FileSystem.readFileAsync(resolvedConfigurationFilePath);
                }
                catch (e) {
                    if (node_core_library_1.FileSystem.isNotExistError(e)) {
                        e.message = `File does not exist: ${resolvedConfigurationFilePathForErrors}`;
                    }
                    throw e;
                }
                let configurationJson;
                try {
                    configurationJson = await node_core_library_1.JsonFile.parseString(fileText);
                }
                catch (e) {
                    throw new Error(`In config file "${resolvedConfigurationFilePathForErrors}": ${e}`);
                }
                this._schema.validateObject(configurationJson, resolvedConfigurationFilePathForErrors);
                this._annotateProperties(resolvedConfigurationFilePath, configurationJson);
                for (const [jsonPath, metadata] of Object.entries(this._jsonPathMetadata)) {
                    jsonpath_plus_1.JSONPath({
                        path: jsonPath,
                        json: configurationJson,
                        callback: (payload, payloadType, fullPayload) => {
                            if (metadata.pathResolutionMethod !== undefined) {
                                fullPayload.parent[fullPayload.parentProperty] = this._resolvePathProperty(resolvedConfigurationFilePath, fullPayload.value, metadata.pathResolutionMethod);
                            }
                        },
                        otherTypeCallback: () => {
                            throw new Error('@other() tags are not supported');
                        }
                    });
                }
                let parentConfiguration = {};
                if (configurationJson.extends) {
                    const resolvedParentConfigPath = nodeJsPath.resolve(nodeJsPath.dirname(resolvedConfigurationFilePath), configurationJson.extends);
                    parentConfiguration = await this._loadConfigurationFileInnerAsync(resolvedParentConfigPath, visitedConfigurationFilePaths);
                }
                const propertyNames = new Set([
                    ...Object.keys(parentConfiguration),
                    ...Object.keys(configurationJson)
                ]);
                const resultAnnotation = {
                    configurationFilePath: resolvedConfigurationFilePath,
                    originalValues: {}
                };
                const result = {
                    [CONFIGURATION_FILE_FIELD_ANNOTATION]: resultAnnotation
                };
                for (const propertyName of propertyNames) {
                    if (propertyName === '$schema' || propertyName === 'extends') {
                        continue;
                    }
                    const propertyValue = configurationJson[propertyName];
                    const parentPropertyValue = parentConfiguration[propertyName];
                    const bothAreArrays = Array.isArray(propertyValue) && Array.isArray(parentPropertyValue);
                    const defaultInheritanceType = bothAreArrays
                        ? InheritanceType.append
                        : InheritanceType.replace;
                    const inheritanceType = this._propertyInheritanceTypes[propertyName] !== undefined
                        ? this._propertyInheritanceTypes[propertyName]
                        : defaultInheritanceType;
                    let newValue;
                    const usePropertyValue = () => {
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        resultAnnotation.originalValues[propertyName] = this.getPropertyOriginalValue({
                            parentObject: configurationJson,
                            propertyName: propertyName
                        });
                        newValue = propertyValue;
                    };
                    const useParentPropertyValue = () => {
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        resultAnnotation.originalValues[propertyName] = this.getPropertyOriginalValue({
                            parentObject: parentConfiguration,
                            propertyName: propertyName
                        });
                        newValue = parentPropertyValue;
                    };
                    switch (inheritanceType) {
                        case InheritanceType.replace: {
                            if (propertyValue !== undefined) {
                                usePropertyValue();
                            }
                            else {
                                useParentPropertyValue();
                            }
                            break;
                        }
                        case InheritanceType.append: {
                            if (propertyValue !== undefined && parentPropertyValue === undefined) {
                                usePropertyValue();
                            }
                            else if (propertyValue === undefined && parentPropertyValue !== undefined) {
                                useParentPropertyValue();
                            }
                            else {
                                if (!Array.isArray(propertyValue) || !Array.isArray(parentPropertyValue)) {
                                    throw new Error(`Issue in processing configuration file property "${propertyName}". ` +
                                        `Property is not an array, but the inheritance type is set as "${InheritanceType.append}"`);
                                }
                                newValue = [...parentPropertyValue, ...propertyValue];
                                newValue[CONFIGURATION_FILE_FIELD_ANNOTATION] = {
                                    configurationFilePath: undefined,
                                    originalValues: Object.assign(Object.assign({}, parentPropertyValue[CONFIGURATION_FILE_FIELD_ANNOTATION].originalValues), propertyValue[CONFIGURATION_FILE_FIELD_ANNOTATION].originalValues)
                                };
                            }
                            break;
                        }
                        default: {
                            throw new Error(`Unknown inheritance type "${inheritanceType}"`);
                        }
                    }
                    result[propertyName] = newValue;
                }
                try {
                    this._schema.validateObject(result, resolvedConfigurationFilePathForErrors);
                }
                catch (e) {
                    throw new Error(`Resolved configuration object does not match schema: ${e}`);
                }
                cacheEntry = { configurationFile: result };
            }
            catch (e) {
                cacheEntry = { error: e };
            }
        }
        if (cacheEntry.error) {
            throw cacheEntry.error;
        }
        else {
            return cacheEntry.configurationFile;
        }
    }
    _annotateProperties(resolvedConfigurationFilePath, obj) {
        if (!obj) {
            return;
        }
        if (typeof obj === 'object') {
            this._annotateProperty(resolvedConfigurationFilePath, obj);
            for (const objValue of Object.values(obj)) {
                this._annotateProperties(resolvedConfigurationFilePath, objValue);
            }
        }
    }
    _annotateProperty(resolvedConfigurationFilePath, obj) {
        if (!obj) {
            return;
        }
        if (typeof obj === 'object') {
            obj[CONFIGURATION_FILE_FIELD_ANNOTATION] = {
                configurationFilePath: resolvedConfigurationFilePath,
                originalValues: Object.assign({}, obj)
            };
        }
    }
    _resolvePathProperty(configurationFilePath, propertyValue, resolutionMethod) {
        switch (resolutionMethod) {
            case PathResolutionMethod.resolvePathRelativeToConfigurationFile: {
                return nodeJsPath.resolve(nodeJsPath.dirname(configurationFilePath), propertyValue);
            }
            case PathResolutionMethod.resolvePathRelativeToProjectRoot: {
                const packageRoot = this._packageJsonLookup.tryGetPackageFolderFor(configurationFilePath);
                if (!packageRoot) {
                    throw new Error(`Could not find a package root for path "${ConfigurationFile._formatPathForError(configurationFilePath)}"`);
                }
                return nodeJsPath.resolve(packageRoot, propertyValue);
            }
            case PathResolutionMethod.NodeResolve: {
                return node_core_library_1.Import.resolveModule({
                    modulePath: propertyValue,
                    baseFolderPath: nodeJsPath.dirname(configurationFilePath)
                });
            }
            default: {
                return propertyValue;
            }
        }
    }
}
exports.ConfigurationFile = ConfigurationFile;
/**
 * @internal
 */
ConfigurationFile._formatPathForError = (path) => path;
//# sourceMappingURL=ConfigurationFile.js.map