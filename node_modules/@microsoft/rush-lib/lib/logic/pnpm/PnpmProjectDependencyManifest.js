"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PnpmProjectDependencyManifest = void 0;
const path = __importStar(require("path"));
const semver = __importStar(require("semver"));
const crypto_1 = __importDefault(require("crypto"));
const node_core_library_1 = require("@rushstack/node-core-library");
const PnpmShrinkwrapFile_1 = require("./PnpmShrinkwrapFile");
const RushConstants_1 = require("../RushConstants");
const DependencySpecifier_1 = require("../DependencySpecifier");
/**
 * This class handles creating the project/.rush/temp/shrinkwrap-deps.json file
 * which tracks the direct and indirect dependencies that a project consumes. This is used
 * to better determine which projects should be rebuilt when dependencies are updated.
 */
class PnpmProjectDependencyManifest {
    constructor(options) {
        this._pnpmShrinkwrapFile = options.pnpmShrinkwrapFile;
        this._project = options.project;
        this._projectDependencyManifestFilename = PnpmProjectDependencyManifest.getFilePathForProject(this._project);
        this._projectDependencyManifestFile = new Map();
    }
    /**
     * Get the fully-qualified path to the project/.rush/temp/shrinkwrap-deps.json
     * for the specified project.
     */
    static getFilePathForProject(project) {
        return path.join(project.projectRushTempFolder, RushConstants_1.RushConstants.projectDependencyManifestFilename);
    }
    addDependency(name, version, parentShrinkwrapEntry) {
        this._addDependencyInternal(name, version, parentShrinkwrapEntry);
    }
    /**
     * Save the current state of the object to project/.rush/temp/shrinkwrap-deps.json
     */
    async saveAsync() {
        const file = {};
        const keys = Array.from(this._projectDependencyManifestFile.keys()).sort();
        for (const key of keys) {
            file[key] = this._projectDependencyManifestFile.get(key);
        }
        await node_core_library_1.JsonFile.saveAsync(file, this._projectDependencyManifestFilename, { ensureFolderExists: true });
    }
    /**
     * If the project/.rush/temp/shrinkwrap-deps.json file exists, delete it. Otherwise, do nothing.
     */
    deleteIfExistsAsync() {
        return node_core_library_1.FileSystem.deleteFileAsync(this._projectDependencyManifestFilename, { throwIfNotExists: false });
    }
    _addDependencyInternal(name, version, parentShrinkwrapEntry, throwIfShrinkwrapEntryMissing = true) {
        const shrinkwrapEntry = this._pnpmShrinkwrapFile.getShrinkwrapEntry(name, version);
        if (!shrinkwrapEntry) {
            if (throwIfShrinkwrapEntryMissing) {
                throw new node_core_library_1.InternalError(`Unable to find dependency ${name} with version ${version} in shrinkwrap.`);
            }
            return;
        }
        const specifier = `${name}@${version}`;
        let integrity = shrinkwrapEntry.resolution.integrity;
        if (!integrity) {
            // git dependency specifiers do not have an integrity entry
            // Example ('integrity' doesn't exist in 'resolution'):
            //
            // github.com/chfritz/node-xmlrpc/948db2fbd0260e5d56ed5ba58df0f5b6599bbe38:
            //   dependencies:
            //     sax: 1.2.4
            //     xmlbuilder: 8.2.2
            //   dev: false
            //   engines:
            //     node: '>=0.8'
            //     npm: '>=1.0.0'
            //   name: xmlrpc
            //   resolution:
            //     tarball: 'https://codeload.github.com/chfritz/node-xmlrpc/tar.gz/948db2fbd0260e5d56ed5ba58df0f5b6599bbe38'
            //   version: 1.3.2
            const sha256Digest = crypto_1.default
                .createHash('sha256')
                .update(JSON.stringify(shrinkwrapEntry))
                .digest('hex');
            integrity = `${name}@${version}:${sha256Digest}:`;
        }
        if (this._projectDependencyManifestFile.has(specifier)) {
            if (this._projectDependencyManifestFile.get(specifier) !== integrity) {
                throw new Error(`Collision: ${specifier} already exists in with a different integrity`);
            }
            return;
        }
        // Add the current dependency
        this._projectDependencyManifestFile.set(specifier, integrity);
        // Add the dependencies of the dependency
        for (const dependencyName in shrinkwrapEntry.dependencies) {
            if (shrinkwrapEntry.dependencies.hasOwnProperty(dependencyName)) {
                const dependencyVersion = shrinkwrapEntry.dependencies[dependencyName];
                this._addDependencyInternal(dependencyName, dependencyVersion, shrinkwrapEntry);
            }
        }
        // Add the optional dependencies of the dependency
        for (const optionalDependencyName in shrinkwrapEntry.optionalDependencies) {
            if (shrinkwrapEntry.optionalDependencies.hasOwnProperty(optionalDependencyName)) {
                // Optional dependencies may not exist. Don't blow up if it can't be found
                const dependencyVersion = shrinkwrapEntry.optionalDependencies[optionalDependencyName];
                this._addDependencyInternal(optionalDependencyName, dependencyVersion, shrinkwrapEntry, (throwIfShrinkwrapEntryMissing = false));
            }
        }
        if (this._project.rushConfiguration.pnpmOptions &&
            this._project.rushConfiguration.pnpmOptions.useWorkspaces) {
            // When using workspaces, hoisting of dependencies is not possible. Therefore, all packages that are consumed
            // should be specified as direct dependencies in the shrinkwrap. Given this, there is no need to look for peer
            // dependencies, since it is simply a constraint to be validated by the package manager.
            return;
        }
        for (const [peerDependencyName, peerDependencyVersion] of Object.entries(shrinkwrapEntry.peerDependencies || {})) {
            // Check to see if the peer dependency is satisfied with the current shrinkwrap
            // entry and if not, check the parent shrinkwrap entry
            if (this._validatePeerDependencyVersion(shrinkwrapEntry, peerDependencyName, peerDependencyVersion) ||
                this._validatePeerDependencyVersion(parentShrinkwrapEntry, peerDependencyName, peerDependencyVersion)) {
                continue;
            }
            // The parent doesn't have a version that satisfies the range. As a last attempt, check
            // if it's been hoisted up as a top-level dependency
            const topLevelDependencySpecifier = this._pnpmShrinkwrapFile.getTopLevelDependencyVersion(peerDependencyName);
            // Sometimes peer dependencies are hoisted but are not represented in the shrinkwrap file
            // (such as when implicitlyPreferredVersions is false) so we need to find the correct key
            // and add it ourselves
            if (!topLevelDependencySpecifier) {
                const peerDependencyKeys = this._parsePeerDependencyKeysFromSpecifier(specifier);
                if (peerDependencyKeys.hasOwnProperty(peerDependencyName)) {
                    this._addDependencyInternal(peerDependencyName, peerDependencyKeys[peerDependencyName], shrinkwrapEntry);
                    continue;
                }
            }
            if (!topLevelDependencySpecifier || !semver.valid(topLevelDependencySpecifier.versionSpecifier)) {
                if (!this._project.rushConfiguration.pnpmOptions ||
                    !this._project.rushConfiguration.pnpmOptions.strictPeerDependencies ||
                    (shrinkwrapEntry.peerDependenciesMeta &&
                        shrinkwrapEntry.peerDependenciesMeta.hasOwnProperty(peerDependencyName) &&
                        shrinkwrapEntry.peerDependenciesMeta[peerDependencyName].optional)) {
                    // We couldn't find the peer dependency, but we determined it's by design, skip this dependency...
                    continue;
                }
                throw new node_core_library_1.InternalError(`Could not find peer dependency '${peerDependencyName}' that satisfies version '${peerDependencyVersion}'`);
            }
            this._addDependencyInternal(peerDependencyName, this._pnpmShrinkwrapFile.getTopLevelDependencyKey(peerDependencyName), shrinkwrapEntry);
        }
    }
    _validatePeerDependencyVersion(shrinkwrapEntry, peerDependencyName, peerDependencyVersion) {
        // Check the current package to see if the dependency is already satisfied
        if (shrinkwrapEntry.dependencies && shrinkwrapEntry.dependencies.hasOwnProperty(peerDependencyName)) {
            let dependencySpecifier = PnpmShrinkwrapFile_1.parsePnpmDependencyKey(peerDependencyName, shrinkwrapEntry.dependencies[peerDependencyName]);
            if (dependencySpecifier) {
                if (dependencySpecifier.specifierType === DependencySpecifier_1.DependencySpecifierType.Alias &&
                    dependencySpecifier.aliasTarget) {
                    dependencySpecifier = dependencySpecifier.aliasTarget;
                }
                if (!semver.valid(dependencySpecifier.versionSpecifier)) {
                    throw new node_core_library_1.InternalError(`The version '${peerDependencyVersion}' of peer dependency '${peerDependencyName}' is invalid`);
                }
                return true;
            }
        }
        return false;
    }
    /**
     * The version specifier for a dependency can sometimes come in the form of
     * '{semVer}_peerDep1@1.2.3+peerDep2@4.5.6'. This is parsed and returned as a dictionary mapping
     * the peer dependency to it's appropriate PNPM dependency key.
     */
    _parsePeerDependencyKeysFromSpecifier(specifier) {
        const parsedPeerDependencyKeys = {};
        const specifierMatches = /^[^_]+_(.+)$/.exec(specifier);
        if (specifierMatches) {
            const combinedPeerDependencies = specifierMatches[1];
            // "eslint@6.6.0+typescript@3.6.4+@types+webpack@4.1.9" --> ["eslint@6.6.0", "typescript@3.6.4", "@types", "webpack@4.1.9"]
            const peerDependencies = combinedPeerDependencies.split('+');
            for (let i = 0; i < peerDependencies.length; i++) {
                // Scopes are also separated by '+', so reduce the proceeding value into it
                if (peerDependencies[i].indexOf('@') === 0) {
                    peerDependencies[i] = `${peerDependencies[i]}/${peerDependencies[i + 1]}`;
                    peerDependencies.splice(i + 1, 1);
                }
                // Parse "eslint@6.6.0" --> "eslint", "6.6.0"
                const peerMatches = /^(@?[^+@]+)@(.+)$/.exec(peerDependencies[i]);
                if (peerMatches) {
                    const peerDependencyName = peerMatches[1];
                    const peerDependencyVersion = peerMatches[2];
                    const peerDependencyKey = `/${peerDependencyName}/${peerDependencyVersion}`;
                    parsedPeerDependencyKeys[peerDependencyName] = peerDependencyKey;
                }
            }
        }
        return parsedPeerDependencyKeys;
    }
}
exports.PnpmProjectDependencyManifest = PnpmProjectDependencyManifest;
//# sourceMappingURL=PnpmProjectDependencyManifest.js.map