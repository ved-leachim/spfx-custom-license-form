{"version":3,"file":"PnpmProjectDependencyManifest.js","sourceRoot":"","sources":["../../../src/logic/pnpm/PnpmProjectDependencyManifest.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as path from 'path';\r\nimport * as semver from 'semver';\r\nimport crypto from 'crypto';\r\nimport { JsonFile, InternalError, FileSystem } from '@rushstack/node-core-library';\r\n\r\nimport {\r\n  PnpmShrinkwrapFile,\r\n  IPnpmShrinkwrapDependencyYaml,\r\n  parsePnpmDependencyKey\r\n} from './PnpmShrinkwrapFile';\r\nimport { RushConfigurationProject } from '../../api/RushConfigurationProject';\r\nimport { RushConstants } from '../RushConstants';\r\nimport { DependencySpecifier, DependencySpecifierType } from '../DependencySpecifier';\r\n\r\nexport interface IPnpmProjectDependencyManifestOptions {\r\n  pnpmShrinkwrapFile: PnpmShrinkwrapFile;\r\n  project: RushConfigurationProject;\r\n}\r\n\r\n/**\r\n * This class handles creating the project/.rush/temp/shrinkwrap-deps.json file\r\n * which tracks the direct and indirect dependencies that a project consumes. This is used\r\n * to better determine which projects should be rebuilt when dependencies are updated.\r\n */\r\nexport class PnpmProjectDependencyManifest {\r\n  /**\r\n   * This mapping is used to map all project dependencies and all their dependencies\r\n   * to their respective dependency integrity hash. For example, if the project contains\r\n   * a dependency A which itself has a dependency on B, the mapping would look like:\r\n   * 'A@1.2.3': '{Integrity of A}',\r\n   * 'B@4.5.6': '{Integrity of B}',\r\n   * ...\r\n   */\r\n  private _projectDependencyManifestFile: Map<string, string>;\r\n\r\n  private readonly _projectDependencyManifestFilename: string;\r\n  private readonly _pnpmShrinkwrapFile: PnpmShrinkwrapFile;\r\n  private readonly _project: RushConfigurationProject;\r\n\r\n  public constructor(options: IPnpmProjectDependencyManifestOptions) {\r\n    this._pnpmShrinkwrapFile = options.pnpmShrinkwrapFile;\r\n    this._project = options.project;\r\n    this._projectDependencyManifestFilename = PnpmProjectDependencyManifest.getFilePathForProject(\r\n      this._project\r\n    );\r\n\r\n    this._projectDependencyManifestFile = new Map<string, string>();\r\n  }\r\n\r\n  /**\r\n   * Get the fully-qualified path to the project/.rush/temp/shrinkwrap-deps.json\r\n   * for the specified project.\r\n   */\r\n  public static getFilePathForProject(project: RushConfigurationProject): string {\r\n    return path.join(project.projectRushTempFolder, RushConstants.projectDependencyManifestFilename);\r\n  }\r\n\r\n  public addDependency(\r\n    name: string,\r\n    version: string,\r\n    parentShrinkwrapEntry: Pick<\r\n      IPnpmShrinkwrapDependencyYaml,\r\n      'dependencies' | 'optionalDependencies' | 'peerDependencies'\r\n    >\r\n  ): void {\r\n    this._addDependencyInternal(name, version, parentShrinkwrapEntry);\r\n  }\r\n\r\n  /**\r\n   * Save the current state of the object to project/.rush/temp/shrinkwrap-deps.json\r\n   */\r\n  public async saveAsync(): Promise<void> {\r\n    const file: { [specifier: string]: string } = {};\r\n    const keys: string[] = Array.from(this._projectDependencyManifestFile.keys()).sort();\r\n    for (const key of keys) {\r\n      file[key] = this._projectDependencyManifestFile.get(key)!;\r\n    }\r\n    await JsonFile.saveAsync(file, this._projectDependencyManifestFilename, { ensureFolderExists: true });\r\n  }\r\n\r\n  /**\r\n   * If the project/.rush/temp/shrinkwrap-deps.json file exists, delete it. Otherwise, do nothing.\r\n   */\r\n  public deleteIfExistsAsync(): Promise<void> {\r\n    return FileSystem.deleteFileAsync(this._projectDependencyManifestFilename, { throwIfNotExists: false });\r\n  }\r\n\r\n  private _addDependencyInternal(\r\n    name: string,\r\n    version: string,\r\n    parentShrinkwrapEntry: Pick<\r\n      IPnpmShrinkwrapDependencyYaml,\r\n      'dependencies' | 'optionalDependencies' | 'peerDependencies'\r\n    >,\r\n    throwIfShrinkwrapEntryMissing: boolean = true\r\n  ): void {\r\n    const shrinkwrapEntry:\r\n      | IPnpmShrinkwrapDependencyYaml\r\n      | undefined = this._pnpmShrinkwrapFile.getShrinkwrapEntry(name, version);\r\n\r\n    if (!shrinkwrapEntry) {\r\n      if (throwIfShrinkwrapEntryMissing) {\r\n        throw new InternalError(`Unable to find dependency ${name} with version ${version} in shrinkwrap.`);\r\n      }\r\n      return;\r\n    }\r\n\r\n    const specifier: string = `${name}@${version}`;\r\n    let integrity: string = shrinkwrapEntry.resolution.integrity;\r\n\r\n    if (!integrity) {\r\n      // git dependency specifiers do not have an integrity entry\r\n\r\n      // Example ('integrity' doesn't exist in 'resolution'):\r\n      //\r\n      // github.com/chfritz/node-xmlrpc/948db2fbd0260e5d56ed5ba58df0f5b6599bbe38:\r\n      //   dependencies:\r\n      //     sax: 1.2.4\r\n      //     xmlbuilder: 8.2.2\r\n      //   dev: false\r\n      //   engines:\r\n      //     node: '>=0.8'\r\n      //     npm: '>=1.0.0'\r\n      //   name: xmlrpc\r\n      //   resolution:\r\n      //     tarball: 'https://codeload.github.com/chfritz/node-xmlrpc/tar.gz/948db2fbd0260e5d56ed5ba58df0f5b6599bbe38'\r\n      //   version: 1.3.2\r\n\r\n      const sha256Digest: string = crypto\r\n        .createHash('sha256')\r\n        .update(JSON.stringify(shrinkwrapEntry))\r\n        .digest('hex');\r\n      integrity = `${name}@${version}:${sha256Digest}:`;\r\n    }\r\n\r\n    if (this._projectDependencyManifestFile.has(specifier)) {\r\n      if (this._projectDependencyManifestFile.get(specifier) !== integrity) {\r\n        throw new Error(`Collision: ${specifier} already exists in with a different integrity`);\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Add the current dependency\r\n    this._projectDependencyManifestFile.set(specifier, integrity);\r\n\r\n    // Add the dependencies of the dependency\r\n    for (const dependencyName in shrinkwrapEntry.dependencies) {\r\n      if (shrinkwrapEntry.dependencies.hasOwnProperty(dependencyName)) {\r\n        const dependencyVersion: string = shrinkwrapEntry.dependencies[dependencyName];\r\n        this._addDependencyInternal(dependencyName, dependencyVersion, shrinkwrapEntry);\r\n      }\r\n    }\r\n\r\n    // Add the optional dependencies of the dependency\r\n    for (const optionalDependencyName in shrinkwrapEntry.optionalDependencies) {\r\n      if (shrinkwrapEntry.optionalDependencies.hasOwnProperty(optionalDependencyName)) {\r\n        // Optional dependencies may not exist. Don't blow up if it can't be found\r\n        const dependencyVersion: string = shrinkwrapEntry.optionalDependencies[optionalDependencyName];\r\n        this._addDependencyInternal(\r\n          optionalDependencyName,\r\n          dependencyVersion,\r\n          shrinkwrapEntry,\r\n          (throwIfShrinkwrapEntryMissing = false)\r\n        );\r\n      }\r\n    }\r\n\r\n    if (\r\n      this._project.rushConfiguration.pnpmOptions &&\r\n      this._project.rushConfiguration.pnpmOptions.useWorkspaces\r\n    ) {\r\n      // When using workspaces, hoisting of dependencies is not possible. Therefore, all packages that are consumed\r\n      // should be specified as direct dependencies in the shrinkwrap. Given this, there is no need to look for peer\r\n      // dependencies, since it is simply a constraint to be validated by the package manager.\r\n      return;\r\n    }\r\n\r\n    for (const [peerDependencyName, peerDependencyVersion] of Object.entries(\r\n      shrinkwrapEntry.peerDependencies || {}\r\n    )) {\r\n      // Check to see if the peer dependency is satisfied with the current shrinkwrap\r\n      // entry and if not, check the parent shrinkwrap entry\r\n      if (\r\n        this._validatePeerDependencyVersion(shrinkwrapEntry, peerDependencyName, peerDependencyVersion) ||\r\n        this._validatePeerDependencyVersion(parentShrinkwrapEntry, peerDependencyName, peerDependencyVersion)\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      // The parent doesn't have a version that satisfies the range. As a last attempt, check\r\n      // if it's been hoisted up as a top-level dependency\r\n      const topLevelDependencySpecifier:\r\n        | DependencySpecifier\r\n        | undefined = this._pnpmShrinkwrapFile.getTopLevelDependencyVersion(peerDependencyName);\r\n\r\n      // Sometimes peer dependencies are hoisted but are not represented in the shrinkwrap file\r\n      // (such as when implicitlyPreferredVersions is false) so we need to find the correct key\r\n      // and add it ourselves\r\n      if (!topLevelDependencySpecifier) {\r\n        const peerDependencyKeys: {\r\n          [peerDependencyName: string]: string;\r\n        } = this._parsePeerDependencyKeysFromSpecifier(specifier);\r\n        if (peerDependencyKeys.hasOwnProperty(peerDependencyName)) {\r\n          this._addDependencyInternal(\r\n            peerDependencyName,\r\n            peerDependencyKeys[peerDependencyName],\r\n            shrinkwrapEntry\r\n          );\r\n          continue;\r\n        }\r\n      }\r\n\r\n      if (!topLevelDependencySpecifier || !semver.valid(topLevelDependencySpecifier.versionSpecifier)) {\r\n        if (\r\n          !this._project.rushConfiguration.pnpmOptions ||\r\n          !this._project.rushConfiguration.pnpmOptions.strictPeerDependencies ||\r\n          (shrinkwrapEntry.peerDependenciesMeta &&\r\n            shrinkwrapEntry.peerDependenciesMeta.hasOwnProperty(peerDependencyName) &&\r\n            shrinkwrapEntry.peerDependenciesMeta[peerDependencyName].optional)\r\n        ) {\r\n          // We couldn't find the peer dependency, but we determined it's by design, skip this dependency...\r\n          continue;\r\n        }\r\n        throw new InternalError(\r\n          `Could not find peer dependency '${peerDependencyName}' that satisfies version '${peerDependencyVersion}'`\r\n        );\r\n      }\r\n\r\n      this._addDependencyInternal(\r\n        peerDependencyName,\r\n        this._pnpmShrinkwrapFile.getTopLevelDependencyKey(peerDependencyName)!,\r\n        shrinkwrapEntry\r\n      );\r\n    }\r\n  }\r\n\r\n  private _validatePeerDependencyVersion(\r\n    shrinkwrapEntry: Pick<\r\n      IPnpmShrinkwrapDependencyYaml,\r\n      'dependencies' | 'optionalDependencies' | 'peerDependencies'\r\n    >,\r\n    peerDependencyName: string,\r\n    peerDependencyVersion: string\r\n  ): boolean {\r\n    // Check the current package to see if the dependency is already satisfied\r\n    if (shrinkwrapEntry.dependencies && shrinkwrapEntry.dependencies.hasOwnProperty(peerDependencyName)) {\r\n      let dependencySpecifier: DependencySpecifier | undefined = parsePnpmDependencyKey(\r\n        peerDependencyName,\r\n        shrinkwrapEntry.dependencies[peerDependencyName]\r\n      );\r\n      if (dependencySpecifier) {\r\n        if (\r\n          dependencySpecifier.specifierType === DependencySpecifierType.Alias &&\r\n          dependencySpecifier.aliasTarget\r\n        ) {\r\n          dependencySpecifier = dependencySpecifier.aliasTarget;\r\n        }\r\n\r\n        if (!semver.valid(dependencySpecifier.versionSpecifier)) {\r\n          throw new InternalError(\r\n            `The version '${peerDependencyVersion}' of peer dependency '${peerDependencyName}' is invalid`\r\n          );\r\n        }\r\n\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * The version specifier for a dependency can sometimes come in the form of\r\n   * '{semVer}_peerDep1@1.2.3+peerDep2@4.5.6'. This is parsed and returned as a dictionary mapping\r\n   * the peer dependency to it's appropriate PNPM dependency key.\r\n   */\r\n  private _parsePeerDependencyKeysFromSpecifier(specifier: string): { [peerDependencyName: string]: string } {\r\n    const parsedPeerDependencyKeys: { [peerDependencyName: string]: string } = {};\r\n\r\n    const specifierMatches: RegExpExecArray | null = /^[^_]+_(.+)$/.exec(specifier);\r\n    if (specifierMatches) {\r\n      const combinedPeerDependencies: string = specifierMatches[1];\r\n      // \"eslint@6.6.0+typescript@3.6.4+@types+webpack@4.1.9\" --> [\"eslint@6.6.0\", \"typescript@3.6.4\", \"@types\", \"webpack@4.1.9\"]\r\n      const peerDependencies: string[] = combinedPeerDependencies.split('+');\r\n      for (let i: number = 0; i < peerDependencies.length; i++) {\r\n        // Scopes are also separated by '+', so reduce the proceeding value into it\r\n        if (peerDependencies[i].indexOf('@') === 0) {\r\n          peerDependencies[i] = `${peerDependencies[i]}/${peerDependencies[i + 1]}`;\r\n          peerDependencies.splice(i + 1, 1);\r\n        }\r\n\r\n        // Parse \"eslint@6.6.0\" --> \"eslint\", \"6.6.0\"\r\n        const peerMatches: RegExpExecArray | null = /^(@?[^+@]+)@(.+)$/.exec(peerDependencies[i]);\r\n        if (peerMatches) {\r\n          const peerDependencyName: string = peerMatches[1];\r\n          const peerDependencyVersion: string = peerMatches[2];\r\n          const peerDependencyKey: string = `/${peerDependencyName}/${peerDependencyVersion}`;\r\n          parsedPeerDependencyKeys[peerDependencyName] = peerDependencyKey;\r\n        }\r\n      }\r\n    }\r\n\r\n    return parsedPeerDependencyKeys;\r\n  }\r\n}\r\n"]}