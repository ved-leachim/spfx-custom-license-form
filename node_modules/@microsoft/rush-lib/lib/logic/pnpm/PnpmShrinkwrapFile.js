"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PnpmShrinkwrapFile = exports.parsePnpmDependencyKey = void 0;
const os = __importStar(require("os"));
const path = __importStar(require("path"));
const semver = __importStar(require("semver"));
const crypto_1 = __importDefault(require("crypto"));
const colors_1 = __importDefault(require("colors"));
const node_core_library_1 = require("@rushstack/node-core-library");
const BaseShrinkwrapFile_1 = require("../base/BaseShrinkwrapFile");
const DependencySpecifier_1 = require("../DependencySpecifier");
const RushConfiguration_1 = require("../../api/RushConfiguration");
const PnpmYamlCommon_1 = require("./PnpmYamlCommon");
const yamlModule = node_core_library_1.Import.lazy('js-yaml', require);
/**
 * Given an encoded "dependency key" from the PNPM shrinkwrap file, this parses it into an equivalent
 * DependencySpecifier.
 *
 * @returns a SemVer string, or undefined if the version specifier cannot be parsed
 */
function parsePnpmDependencyKey(dependencyName, dependencyKey) {
    if (!dependencyKey) {
        return undefined;
    }
    if (/^\w+:/.test(dependencyKey)) {
        // If it starts with an NPM scheme such as "file:projects/my-app.tgz", we don't support that
        return undefined;
    }
    // The package name parsed from the dependency key, or dependencyName if it was omitted.
    // Example: "@scope/depame"
    let parsedPackageName;
    // The trailing portion of the dependency key that includes the version and optional peer dependency path.
    // Example: "2.8.0/chai@3.5.0+sinon@1.17.7"
    let parsedInstallPath;
    // Example: "path.pkgs.visualstudio.com/@scope/depame/1.4.0"  --> 0="@scope/depame" 1="1.4.0"
    // Example: "/isarray/2.0.1"                                  --> 0="isarray"       1="2.0.1"
    // Example: "/sinon-chai/2.8.0/chai@3.5.0+sinon@1.17.7"       --> 0="sinon-chai"    1="2.8.0/chai@3.5.0+sinon@1.17.7"
    const packageNameMatch = /^[^\/]*\/((?:@[^\/]+\/)?[^\/]+)\/(.*)$/.exec(dependencyKey);
    if (packageNameMatch) {
        parsedPackageName = packageNameMatch[1];
        parsedInstallPath = packageNameMatch[2];
    }
    else {
        parsedPackageName = dependencyName;
        // Example: "23.6.0_babel-core@6.26.3"
        // Example: "23.6.0"
        parsedInstallPath = dependencyKey;
    }
    // The SemVer value
    // Example: "2.8.0"
    let parsedVersionPart;
    // Example: "23.6.0_babel-core@6.26.3" --> "23.6.0"
    // Example: "2.8.0/chai@3.5.0+sinon@1.17.7" --> "2.8.0"
    const versionMatch = /^([^\/_]+)[\/_]/.exec(parsedInstallPath);
    if (versionMatch) {
        parsedVersionPart = versionMatch[1];
    }
    else {
        // Example: "2.8.0"
        parsedVersionPart = parsedInstallPath;
    }
    // By this point, we expect parsedVersionPart to be a valid SemVer range
    if (!parsedVersionPart) {
        return undefined;
    }
    if (!semver.valid(parsedVersionPart)) {
        const urlRegex = /^(@?)([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}\/([^\/\\]+\/?)*([^\/\\]+)$/i;
        // Test for urls:
        // Examples:
        //     @github.com/abc/def/188ed64efd5218beda276e02f2277bf3a6b745b2
        //     github.com/abc/def/188ed64efd5218beda276e02f2277bf3a6b745b2
        //     github.com.au/abc/def/188ed64efd5218beda276e02f2277bf3a6b745b2
        //     bitbucket.com/abc/def/188ed64efd5218beda276e02f2277bf3a6b745b2
        //     bitbucket.co.in/abc/def/188ed64efd5218beda276e02f2277bf3a6b745b2
        if (urlRegex.test(dependencyKey)) {
            const dependencySpecifier = new DependencySpecifier_1.DependencySpecifier(dependencyName, dependencyKey);
            return dependencySpecifier;
        }
        else {
            return undefined;
        }
    }
    // Is it an alias for a different package?
    if (parsedPackageName === dependencyName) {
        // No, it's a regular dependency
        return new DependencySpecifier_1.DependencySpecifier(parsedPackageName, parsedVersionPart);
    }
    else {
        // If the parsed package name is different from the dependencyName, then this is an NPM package alias
        return new DependencySpecifier_1.DependencySpecifier(dependencyName, `npm:${parsedPackageName}@${parsedVersionPart}`);
    }
}
exports.parsePnpmDependencyKey = parsePnpmDependencyKey;
class PnpmShrinkwrapFile extends BaseShrinkwrapFile_1.BaseShrinkwrapFile {
    constructor(shrinkwrapJson, shrinkwrapFilename) {
        super();
        this._shrinkwrapJson = shrinkwrapJson;
        this.shrinkwrapFilename = shrinkwrapFilename;
        // Normalize the data
        if (!this._shrinkwrapJson.registry) {
            this._shrinkwrapJson.registry = '';
        }
        if (!this._shrinkwrapJson.dependencies) {
            this._shrinkwrapJson.dependencies = {};
        }
        if (!this._shrinkwrapJson.importers) {
            this._shrinkwrapJson.importers = {};
        }
        if (!this._shrinkwrapJson.specifiers) {
            this._shrinkwrapJson.specifiers = {};
        }
        if (!this._shrinkwrapJson.packages) {
            this._shrinkwrapJson.packages = {};
        }
    }
    static loadFromFile(shrinkwrapYamlFilename, pnpmOptions) {
        try {
            if (!node_core_library_1.FileSystem.exists(shrinkwrapYamlFilename)) {
                return undefined; // file does not exist
            }
            const shrinkwrapContent = node_core_library_1.FileSystem.readFile(shrinkwrapYamlFilename);
            const parsedData = yamlModule.safeLoad(shrinkwrapContent);
            return new PnpmShrinkwrapFile(parsedData, shrinkwrapYamlFilename);
        }
        catch (error) {
            throw new Error(`Error reading "${shrinkwrapYamlFilename}":${os.EOL}  ${error.message}`);
        }
    }
    getShrinkwrapHash() {
        const shrinkwrapContent = this.serialize();
        return crypto_1.default.createHash('sha1').update(shrinkwrapContent).digest('hex');
    }
    /** @override */
    validate(packageManagerOptionsConfig, policyOptions) {
        super.validate(packageManagerOptionsConfig, policyOptions);
        if (!(packageManagerOptionsConfig instanceof RushConfiguration_1.PnpmOptionsConfiguration)) {
            throw new Error('The provided package manager options are not valid for PNPM shrinkwrap files.');
        }
        // Only check the hash if allowShrinkwrapUpdates is false. If true, the shrinkwrap file
        // may have changed and the hash could be invalid.
        if (packageManagerOptionsConfig.preventManualShrinkwrapChanges && !policyOptions.allowShrinkwrapUpdates) {
            if (!policyOptions.repoState.pnpmShrinkwrapHash) {
                console.log(colors_1.default.red('The existing shrinkwrap file hash could not be found. You may need to run "rush update" to ' +
                    'populate the hash. See the "preventManualShrinkwrapChanges" setting documentation for details.') + os.EOL);
                throw new node_core_library_1.AlreadyReportedError();
            }
            if (this.getShrinkwrapHash() !== policyOptions.repoState.pnpmShrinkwrapHash) {
                console.log(colors_1.default.red('The shrinkwrap file hash does not match the expected hash. Please run "rush update" to ensure the ' +
                    'shrinkwrap file is up to date. See the "preventManualShrinkwrapChanges" setting documentation for ' +
                    'details.') + os.EOL);
                throw new node_core_library_1.AlreadyReportedError();
            }
        }
    }
    /** @override */
    getTempProjectNames() {
        return this._getTempProjectNames(this._shrinkwrapJson.dependencies);
    }
    /**
     * Gets the path to the tarball file if the package is a tarball.
     * Returns undefined if the package entry doesn't exist or the package isn't a tarball.
     * Example of return value: file:projects/build-tools.tgz
     */
    getTarballPath(packageName) {
        const dependency = this._shrinkwrapJson.packages[packageName];
        if (!dependency) {
            return undefined;
        }
        return dependency.resolution.tarball;
    }
    getTopLevelDependencyKey(dependencyName) {
        return BaseShrinkwrapFile_1.BaseShrinkwrapFile.tryGetValue(this._shrinkwrapJson.dependencies, dependencyName);
    }
    /**
     * Gets the version number from the list of top-level dependencies in the "dependencies" section
     * of the shrinkwrap file. Sample return values:
     *   '2.1.113'
     *   '1.9.0-dev.27'
     *   'file:projects/empty-webpart-project.tgz'
     *   undefined
     *
     * @override
     */
    getTopLevelDependencyVersion(dependencyName) {
        let value = BaseShrinkwrapFile_1.BaseShrinkwrapFile.tryGetValue(this._shrinkwrapJson.dependencies, dependencyName);
        if (value) {
            // Getting the top level dependency version from a PNPM lockfile version 5.1
            // --------------------------------------------------------------------------
            //
            // 1) Top-level tarball dependency entries in pnpm-lock.yaml look like:
            //    '@rush-temp/sp-filepicker': 'file:projects/sp-filepicker.tgz_0ec79d3b08edd81ebf49cd19ca50b3f5'
            //    Then, it would be defined below:
            //    'file:projects/sp-filepicker.tgz_0ec79d3b08edd81ebf49cd19ca50b3f5':
            //      dependencies:
            //       '@microsoft/load-themed-styles': 1.10.7
            //       ...
            //      resolution:
            //       integrity: sha512-guuoFIc**==
            //       tarball: 'file:projects/sp-filepicker.tgz'
            //    Here, we are interested in the part 'file:projects/sp-filepicker.tgz'. Splitting by underscores is not the
            //    best way to get this because file names could have underscores in them. Instead, we could use the tarball
            //    field in the resolution section.
            // 2) Top-level non-tarball dependency entries in pnpm-lock.yaml would look like:
            //    '@rushstack/set-webpack-public-path-plugin': 2.1.133
            //    @microsoft/sp-build-node': 1.9.0-dev.27_typescript@2.9.2
            //    Here, we could just split by underscores and take the first part.
            // The below code is also compatible with lockfile versions < 5.1
            const dependency = this._shrinkwrapJson.packages[value];
            if (dependency &&
                dependency.resolution &&
                dependency.resolution.tarball &&
                value.startsWith(dependency.resolution.tarball)) {
                return new DependencySpecifier_1.DependencySpecifier(dependencyName, dependency.resolution.tarball);
            }
            else {
                const underscoreIndex = value.indexOf('_');
                if (underscoreIndex >= 0) {
                    value = value.substr(0, underscoreIndex);
                }
            }
            return new DependencySpecifier_1.DependencySpecifier(dependencyName, value);
        }
        return undefined;
    }
    /**
     * The PNPM shrinkwrap file has top-level dependencies on the temp projects like this:
     *
     * ```
     * dependencies:
     *   '@rush-temp/my-app': 'file:projects/my-app.tgz_25c559a5921686293a001a397be4dce0'
     * packages:
     *   /@types/node/10.14.15:
     *     dev: false
     *   'file:projects/my-app.tgz_25c559a5921686293a001a397be4dce0':
     *     dev: false
     *     name: '@rush-temp/my-app'
     *     version: 0.0.0
     * ```
     *
     * We refer to 'file:projects/my-app.tgz_25c559a5921686293a001a397be4dce0' as the temp project dependency key
     * of the temp project '@rush-temp/my-app'.
     */
    getTempProjectDependencyKey(tempProjectName) {
        const tempProjectDependencyKey = BaseShrinkwrapFile_1.BaseShrinkwrapFile.tryGetValue(this._shrinkwrapJson.dependencies, tempProjectName);
        if (tempProjectDependencyKey) {
            return tempProjectDependencyKey;
        }
        return undefined;
    }
    getShrinkwrapEntryFromTempProjectDependencyKey(tempProjectDependencyKey) {
        return this._shrinkwrapJson.packages[tempProjectDependencyKey];
    }
    getShrinkwrapEntry(name, version) {
        // Version can sometimes be in the form of a path that's already in the /name/version format.
        const packageId = version.indexOf('/') !== -1 ? version : `/${name}/${version}`;
        return this._shrinkwrapJson.packages[packageId];
    }
    /**
     * Serializes the PNPM Shrinkwrap file
     *
     * @override
     */
    serialize() {
        // Ensure that if any of the top-level properties are provided but empty are removed. We populate the object
        // properties when we read the shrinkwrap but PNPM does not set these top-level properties unless they are present.
        const shrinkwrapToSerialize = Object.assign({}, this._shrinkwrapJson);
        for (const [key, value] of Object.entries(shrinkwrapToSerialize)) {
            if (typeof value === 'object' && Object.entries(value || {}).length === 0) {
                delete shrinkwrapToSerialize[key];
            }
        }
        return yamlModule.safeDump(shrinkwrapToSerialize, PnpmYamlCommon_1.PNPM_SHRINKWRAP_YAML_FORMAT);
    }
    /**
     * Gets the resolved version number of a dependency for a specific temp project.
     * For PNPM, we can reuse the version that another project is using.
     * Note that this function modifies the shrinkwrap data if tryReusingPackageVersionsFromShrinkwrap is set to true.
     *
     * @override
     */
    tryEnsureDependencyVersion(dependencySpecifier, tempProjectName, tryReusingPackageVersionsFromShrinkwrap) {
        // PNPM doesn't have the same advantage of NPM, where we can skip generate as long as the
        // shrinkwrap file puts our dependency in either the top of the node_modules folder
        // or underneath the package we are looking at.
        // This is because the PNPM shrinkwrap file describes the exact links that need to be created
        // to recreate the graph..
        // Because of this, we actually need to check for a version that this package is directly
        // linked to.
        const packageName = dependencySpecifier.packageName;
        const tempProjectDependencyKey = this.getTempProjectDependencyKey(tempProjectName);
        if (!tempProjectDependencyKey) {
            return undefined;
        }
        const packageDescription = this._getPackageDescription(tempProjectDependencyKey);
        if (!packageDescription || !packageDescription.dependencies) {
            return undefined;
        }
        if (!packageDescription.dependencies.hasOwnProperty(packageName)) {
            if (tryReusingPackageVersionsFromShrinkwrap && dependencySpecifier.versionSpecifier) {
                // this means the current temp project doesn't provide this dependency,
                // however, we may be able to use a different version. we prefer the latest version
                let latestVersion = undefined;
                for (const otherTempProject of this.getTempProjectNames()) {
                    const otherVersionSpecifier = this._getDependencyVersion(dependencySpecifier.packageName, otherTempProject);
                    if (otherVersionSpecifier) {
                        const otherVersion = otherVersionSpecifier.versionSpecifier;
                        if (semver.satisfies(otherVersion, dependencySpecifier.versionSpecifier)) {
                            if (!latestVersion || semver.gt(otherVersion, latestVersion)) {
                                latestVersion = otherVersion;
                            }
                        }
                    }
                }
                if (latestVersion) {
                    // go ahead and fixup the shrinkwrap file to point at this
                    const dependencies = this._shrinkwrapJson.packages[tempProjectDependencyKey].dependencies || {};
                    dependencies[packageName] = latestVersion;
                    this._shrinkwrapJson.packages[tempProjectDependencyKey].dependencies = dependencies;
                    return new DependencySpecifier_1.DependencySpecifier(dependencySpecifier.packageName, latestVersion);
                }
            }
            return undefined;
        }
        const dependencyKey = packageDescription.dependencies[packageName];
        return this._parsePnpmDependencyKey(packageName, dependencyKey);
    }
    /** @override */
    getWorkspaceKeys() {
        const result = [];
        for (const key of Object.keys(this._shrinkwrapJson.importers)) {
            // Avoid including the common workspace
            if (key !== '.') {
                result.push(key);
            }
        }
        result.sort(); // make the result deterministic
        return result;
    }
    /** @override */
    getWorkspaceKeyByPath(workspaceRoot, projectFolder) {
        return path.relative(workspaceRoot, projectFolder).replace(new RegExp(`\\${path.sep}`, 'g'), '/');
    }
    getWorkspaceImporter(importerPath) {
        return BaseShrinkwrapFile_1.BaseShrinkwrapFile.tryGetValue(this._shrinkwrapJson.importers, importerPath);
    }
    /**
     * Gets the resolved version number of a dependency for a specific temp project.
     * For PNPM, we can reuse the version that another project is using.
     * Note that this function modifies the shrinkwrap data.
     *
     * @override
     */
    getWorkspaceDependencyVersion(dependencySpecifier, workspaceKey) {
        // PNPM doesn't have the same advantage of NPM, where we can skip generate as long as the
        // shrinkwrap file puts our dependency in either the top of the node_modules folder
        // or underneath the package we are looking at.
        // This is because the PNPM shrinkwrap file describes the exact links that need to be created
        // to recreate the graph..
        // Because of this, we actually need to check for a version that this package is directly
        // linked to.
        const packageName = dependencySpecifier.packageName;
        const projectImporter = this.getWorkspaceImporter(workspaceKey);
        if (!projectImporter) {
            return undefined;
        }
        const allDependencies = Object.assign(Object.assign(Object.assign({}, (projectImporter.optionalDependencies || {})), (projectImporter.dependencies || {})), (projectImporter.devDependencies || {}));
        if (!allDependencies.hasOwnProperty(packageName)) {
            return undefined;
        }
        const dependencyKey = allDependencies[packageName];
        return this._parsePnpmDependencyKey(packageName, dependencyKey);
    }
    /**
     * Returns the version of a dependency being used by a given project
     */
    _getDependencyVersion(dependencyName, tempProjectName) {
        const tempProjectDependencyKey = this.getTempProjectDependencyKey(tempProjectName);
        if (!tempProjectDependencyKey) {
            throw new Error(`Cannot get dependency key for temp project: ${tempProjectName}`);
        }
        const packageDescription = this._getPackageDescription(tempProjectDependencyKey);
        if (!packageDescription || !packageDescription.dependencies) {
            return undefined;
        }
        if (!packageDescription.dependencies.hasOwnProperty(dependencyName)) {
            return undefined;
        }
        return this._parsePnpmDependencyKey(dependencyName, packageDescription.dependencies[dependencyName]);
    }
    /**
     * Gets the package description for a tempProject from the shrinkwrap file.
     */
    _getPackageDescription(tempProjectDependencyKey) {
        const packageDescription = BaseShrinkwrapFile_1.BaseShrinkwrapFile.tryGetValue(this._shrinkwrapJson.packages, tempProjectDependencyKey);
        if (!packageDescription || !packageDescription.dependencies) {
            return undefined;
        }
        return packageDescription;
    }
    _parsePnpmDependencyKey(dependencyName, pnpmDependencyKey) {
        if (pnpmDependencyKey) {
            const result = parsePnpmDependencyKey(dependencyName, pnpmDependencyKey);
            if (!result) {
                throw new Error(`Cannot parse PNPM shrinkwrap version specifier: "${pnpmDependencyKey}"` +
                    ` for "${dependencyName}"`);
            }
            return result;
        }
        else {
            return undefined;
        }
    }
}
exports.PnpmShrinkwrapFile = PnpmShrinkwrapFile;
//# sourceMappingURL=PnpmShrinkwrapFile.js.map