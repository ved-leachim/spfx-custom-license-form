"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProjectBuildCache = void 0;
const crypto = __importStar(require("crypto"));
const path = __importStar(require("path"));
const tar = __importStar(require("tar"));
const fs = __importStar(require("fs"));
const node_core_library_1 = require("@rushstack/node-core-library");
const RushConstants_1 = require("../RushConstants");
class ProjectBuildCache {
    constructor(options) {
        this._project = options.projectConfiguration.project;
        this._localBuildCacheProvider = options.buildCacheConfiguration.localCacheProvider;
        this._cloudBuildCacheProvider = options.buildCacheConfiguration.cloudCacheProvider;
        this._projectOutputFolderNames = options.projectConfiguration.projectOutputFolderNames;
        this._cacheId = ProjectBuildCache._getCacheId(options);
    }
    static tryGetProjectBuildCache(options) {
        const { terminal, projectConfiguration, trackedProjectFiles } = options;
        if (!trackedProjectFiles) {
            return undefined;
        }
        if (!ProjectBuildCache._validateProject(terminal, projectConfiguration, trackedProjectFiles)) {
            return undefined;
        }
        return new ProjectBuildCache(options);
    }
    static _validateProject(terminal, projectConfiguration, trackedProjectFiles) {
        const normalizedProjectRelativeFolder = node_core_library_1.Path.convertToSlashes(projectConfiguration.project.projectRelativeFolder);
        const outputFolders = [];
        for (const outputFolderName of projectConfiguration.projectOutputFolderNames) {
            outputFolders.push(`${path.posix.join(normalizedProjectRelativeFolder, outputFolderName)}/`);
        }
        const inputOutputFiles = [];
        for (const file of Object.keys(trackedProjectFiles)) {
            for (const outputFolder of outputFolders) {
                if (file.startsWith(outputFolder)) {
                    inputOutputFiles.push(file);
                }
            }
        }
        if (inputOutputFiles.length > 0) {
            terminal.writeWarningLine('Unable to use build cache. The following files are used to calculate project state ' +
                `and are considered project output: ${inputOutputFiles.join(', ')}`);
            return false;
        }
        else {
            return true;
        }
    }
    async tryRestoreFromCacheAsync(terminal) {
        const cacheId = this._cacheId;
        if (!cacheId) {
            terminal.writeWarningLine('Unable to get cache ID. Ensure Git is installed.');
            return false;
        }
        let cacheEntryBuffer = await this._localBuildCacheProvider.tryGetCacheEntryBufferByIdAsync(cacheId);
        const foundInLocalCache = !!cacheEntryBuffer;
        if (!foundInLocalCache && this._cloudBuildCacheProvider) {
            terminal.writeVerboseLine('This project was not found in the local build cache. Querying the cloud build cache.');
            // No idea why ESLint is complaining about this:
            // eslint-disable-next-line require-atomic-updates
            cacheEntryBuffer = await this._cloudBuildCacheProvider.tryGetCacheEntryBufferByIdAsync(terminal, cacheId);
        }
        let setLocalCacheEntryPromise;
        if (!cacheEntryBuffer) {
            terminal.writeVerboseLine('This project was not found in the build cache.');
            return false;
        }
        else if (!foundInLocalCache) {
            setLocalCacheEntryPromise = this._localBuildCacheProvider.trySetCacheEntryBufferAsync(cacheId, cacheEntryBuffer);
        }
        terminal.writeLine('Build cache hit.');
        const projectFolderPath = this._project.projectFolder;
        // Purge output folders
        terminal.writeVerboseLine(`Clearing cached folders: ${this._projectOutputFolderNames.join(', ')}`);
        await Promise.all(this._projectOutputFolderNames.map((outputFolderName) => node_core_library_1.FileSystem.deleteFolderAsync(path.join(projectFolderPath, outputFolderName))));
        const tarStream = tar.extract({ cwd: projectFolderPath });
        const extractTarPromise = new Promise((resolve, reject) => {
            try {
                tarStream.on('error', (error) => reject(error));
                tarStream.on('close', () => resolve(true));
                tarStream.on('drain', () => resolve(true));
                tarStream.write(cacheEntryBuffer);
            }
            catch (e) {
                reject(e);
            }
        });
        let restoreSuccess;
        let updateLocalCacheSuccess;
        if (setLocalCacheEntryPromise) {
            [restoreSuccess, updateLocalCacheSuccess] = await Promise.all([
                extractTarPromise,
                setLocalCacheEntryPromise
            ]);
        }
        else {
            restoreSuccess = await extractTarPromise;
            updateLocalCacheSuccess = true;
        }
        if (restoreSuccess) {
            terminal.writeLine('Successfully restored build output from cache.');
        }
        else {
            terminal.writeWarningLine('Unable to restore build output from cache.');
        }
        if (!updateLocalCacheSuccess) {
            terminal.writeWarningLine('An error occurred updating the local cache with the cloud cache data.');
        }
        return restoreSuccess;
    }
    async trySetCacheEntryAsync(terminal) {
        var _a;
        const cacheId = this._cacheId;
        if (!cacheId) {
            terminal.writeWarningLine('Unable to get cache ID. Ensure Git is installed.');
            return false;
        }
        const projectFolderPath = this._project.projectFolder;
        const outputFoldersThatExist = await Promise.all(this._projectOutputFolderNames.map((outputFolderName) => node_core_library_1.FileSystem.existsAsync(path.join(projectFolderPath, outputFolderName))));
        const filteredOutputFolders = [];
        for (let i = 0; i < outputFoldersThatExist.length; i++) {
            if (outputFoldersThatExist[i]) {
                filteredOutputFolders.push(this._projectOutputFolderNames[i]);
            }
        }
        terminal.writeVerboseLine(`Caching build output folders: ${filteredOutputFolders.join(', ')}`);
        let encounteredTarErrors = false;
        const tarStream = tar.create({
            gzip: true,
            portable: true,
            strict: true,
            cwd: projectFolderPath,
            filter: (tarPath, stat) => {
                const tempStats = new fs.Stats();
                tempStats.mode = stat.mode;
                if (tempStats.isSymbolicLink()) {
                    terminal.writeError(`Unable to include "${tarPath}" in build cache. It is a symbolic link.`);
                    encounteredTarErrors = true;
                    return false;
                }
                else {
                    return true;
                }
            }
        }, filteredOutputFolders);
        const cacheEntryBuffer = await this._readStreamToBufferAsync(tarStream);
        if (encounteredTarErrors) {
            return false;
        }
        const setLocalCacheEntryPromise = this._localBuildCacheProvider.trySetCacheEntryBufferAsync(cacheId, cacheEntryBuffer);
        const setCloudCacheEntryPromise = ((_a = this._cloudBuildCacheProvider) === null || _a === void 0 ? void 0 : _a.isCacheWriteAllowed) === true
            ? this._cloudBuildCacheProvider.trySetCacheEntryBufferAsync(terminal, cacheId, cacheEntryBuffer)
            : undefined;
        let updateLocalCacheSuccess;
        let updateCloudCacheSuccess;
        if (setCloudCacheEntryPromise) {
            [updateCloudCacheSuccess, updateLocalCacheSuccess] = await Promise.all([
                setCloudCacheEntryPromise,
                setLocalCacheEntryPromise
            ]);
        }
        else {
            updateCloudCacheSuccess = true;
            updateLocalCacheSuccess = await setLocalCacheEntryPromise;
        }
        const success = updateCloudCacheSuccess && updateLocalCacheSuccess;
        if (success) {
            terminal.writeLine('Successfully set cache entry.');
        }
        else if (!updateLocalCacheSuccess && updateCloudCacheSuccess) {
            terminal.writeWarningLine('Unable to set local cache entry.');
        }
        else if (updateLocalCacheSuccess && !updateCloudCacheSuccess) {
            terminal.writeWarningLine('Unable to set cloud cache entry.');
        }
        else {
            terminal.writeWarningLine('Unable to set both cloud and local cache entries.');
        }
        return success;
    }
    async _readStreamToBufferAsync(stream) {
        return await new Promise((resolve, reject) => {
            const parts = [];
            stream.on('data', (chunk) => parts.push(chunk));
            stream.on('error', (error) => reject(error));
            stream.on('end', () => {
                const result = Buffer.concat(parts);
                resolve(result);
            });
        });
    }
    static _getCacheId(options) {
        // The project state hash is calculated in the following method:
        // - The current project's hash (see PackageChangeAnalyzer.getProjectStateHash) is
        //   calculated and appended to an array
        // - The current project's recursive dependency projects' hashes are calculated
        //   and appended to the array
        // - A SHA1 hash is created and the following data is fed into it, in order:
        //   1. The JSON-serialized list of output folder names for this
        //      project (see ProjectBuildCache._projectOutputFolderNames)
        //   2. The command that will be run in the project
        //   3. Each dependency project hash (from the array constructed in previous steps),
        //      in sorted alphanumerical-sorted order
        // - A hex digest of the hash is returned
        const packageChangeAnalyzer = options.packageChangeAnalyzer;
        const projectStates = [];
        const projectsThatHaveBeenProcessed = new Set();
        let projectsToProcess = new Set();
        projectsToProcess.add(options.projectConfiguration.project);
        while (projectsToProcess.size > 0) {
            const newProjectsToProcess = new Set();
            for (const projectToProcess of projectsToProcess) {
                projectsThatHaveBeenProcessed.add(projectToProcess);
                const projectState = packageChangeAnalyzer.getProjectStateHash(projectToProcess.packageName);
                if (!projectState) {
                    // If we hit any projects with unknown state, return unknown cache ID
                    return undefined;
                }
                else {
                    projectStates.push(projectState);
                    for (const dependency of projectToProcess.localDependencyProjects) {
                        if (!projectsThatHaveBeenProcessed.has(dependency)) {
                            newProjectsToProcess.add(dependency);
                        }
                    }
                }
            }
            projectsToProcess = newProjectsToProcess;
        }
        const sortedProjectStates = projectStates.sort();
        const hash = crypto.createHash('sha1');
        const serializedOutputFolders = JSON.stringify(options.projectConfiguration.projectOutputFolderNames);
        hash.update(serializedOutputFolders);
        hash.update(RushConstants_1.RushConstants.hashDelimiter);
        hash.update(options.command);
        hash.update(RushConstants_1.RushConstants.hashDelimiter);
        for (const projectHash of sortedProjectStates) {
            hash.update(projectHash);
            hash.update(RushConstants_1.RushConstants.hashDelimiter);
        }
        const projectStateHash = hash.digest('hex');
        return options.buildCacheConfiguration.getCacheEntryId({
            projectName: options.projectConfiguration.project.packageName,
            projectStateHash
        });
    }
}
exports.ProjectBuildCache = ProjectBuildCache;
//# sourceMappingURL=ProjectBuildCache.js.map