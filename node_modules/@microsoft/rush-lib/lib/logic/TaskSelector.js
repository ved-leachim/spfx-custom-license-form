"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.TaskSelector = void 0;
const ProjectBuilder_1 = require("../logic/taskRunner/ProjectBuilder");
const PackageChangeAnalyzer_1 = require("./PackageChangeAnalyzer");
const TaskCollection_1 = require("./taskRunner/TaskCollection");
/**
 * This class is responsible for:
 *  - based on to/from flags, solving the dependency graph and figuring out which projects need to be run
 *  - creating a ProjectBuilder for each project that needs to be built
 *  - registering the necessary ProjectBuilders with the TaskRunner, which actually orchestrates execution
 */
class TaskSelector {
    constructor(options) {
        this._options = options;
        this._packageChangeAnalyzer = new PackageChangeAnalyzer_1.PackageChangeAnalyzer(options.rushConfiguration);
        this._taskCollection = new TaskCollection_1.TaskCollection();
    }
    static getScriptToRun(rushProject, commandToRun, customParameterValues) {
        const script = TaskSelector._getScriptCommand(rushProject, commandToRun);
        if (script === undefined) {
            return undefined;
        }
        if (!script) {
            return '';
        }
        else {
            const taskCommand = `${script} ${customParameterValues.join(' ')}`;
            return process.platform === 'win32' ? ProjectBuilder_1.convertSlashesForWindows(taskCommand) : taskCommand;
        }
    }
    registerTasks() {
        if (this._options.toProjects.length > 0) {
            this._registerToProjects(this._options.toProjects);
        }
        if (this._options.fromProjects.length > 0) {
            this._registerFromProjects(this._options.fromProjects);
        }
        if (this._options.toProjects.length === 0 && this._options.fromProjects.length === 0) {
            this._registerAll();
        }
        return this._taskCollection;
    }
    _registerToProjects(toProjects) {
        const dependencies = new Map();
        for (const toProject of toProjects) {
            this._collectAllDependencies(toProject, dependencies);
        }
        // Register any dependencies it may have
        for (const dependencyProject of dependencies.values()) {
            this._registerTask(dependencyProject);
        }
        if (!this._options.ignoreDependencyOrder) {
            // Add ordering relationships for each dependency
            for (const dependencyProject of dependencies.values()) {
                this._taskCollection.addDependencies(ProjectBuilder_1.ProjectBuilder.getTaskName(dependencyProject), dependencyProject.localDependencyProjects.map((x) => ProjectBuilder_1.ProjectBuilder.getTaskName(x)));
            }
        }
    }
    _registerFromProjects(fromProjects) {
        const dependentList = this._getDependentGraph();
        const dependents = new Map();
        for (const fromProject of fromProjects) {
            this._collectAllDependents(dependentList, fromProject, dependents);
        }
        // Register all downstream dependents
        for (const dependentProject of dependents.values()) {
            this._registerTask(dependentProject);
        }
        if (!this._options.ignoreDependencyOrder) {
            // Only add ordering relationships for projects which have been registered
            // e.g. package C may depend on A & B, but if we are only building A's downstream, we will ignore B
            for (const dependentProject of dependents.values()) {
                this._taskCollection.addDependencies(ProjectBuilder_1.ProjectBuilder.getTaskName(dependentProject), dependentProject.localDependencyProjects
                    .filter((dep) => dependents.has(dep.packageName))
                    .map((x) => ProjectBuilder_1.ProjectBuilder.getTaskName(x)));
            }
        }
    }
    _registerAll() {
        // Register all tasks
        for (const rushProject of this._options.rushConfiguration.projects) {
            this._registerTask(rushProject);
        }
        if (!this._options.ignoreDependencyOrder) {
            // Add ordering relationships for each dependency
            for (const project of this._options.rushConfiguration.projects) {
                this._taskCollection.addDependencies(ProjectBuilder_1.ProjectBuilder.getTaskName(project), project.localDependencyProjects.map((x) => ProjectBuilder_1.ProjectBuilder.getTaskName(x)));
            }
        }
    }
    /**
     * Collects all upstream dependencies for a certain project
     */
    _collectAllDependencies(project, result) {
        if (!result.has(project.packageName)) {
            result.set(project.packageName, project);
            for (const dependencyProject of project.localDependencyProjects) {
                this._collectAllDependencies(dependencyProject, result);
            }
        }
    }
    /**
     * Collects all downstream dependents of a certain project
     */
    _collectAllDependents(dependentList, project, result) {
        if (!result.has(project.packageName)) {
            result.set(project.packageName, project);
            for (const dependent of dependentList.get(project.packageName) || []) {
                this._collectAllDependents(dependentList, dependent, result);
            }
        }
    }
    /**
     * Inverts the localLinks to arrive at the dependent graph. This helps when using the --from flag
     */
    _getDependentGraph() {
        const dependentList = new Map();
        for (const project of this._options.rushConfiguration.projects) {
            for (const { packageName } of project.localDependencyProjects) {
                if (!dependentList.has(packageName)) {
                    dependentList.set(packageName, new Set());
                }
                dependentList.get(packageName).add(project);
            }
        }
        return dependentList;
    }
    _registerTask(project) {
        if (!project || this._taskCollection.hasTask(ProjectBuilder_1.ProjectBuilder.getTaskName(project))) {
            return;
        }
        const commandToRun = TaskSelector.getScriptToRun(project, this._options.commandToRun, this._options.customParameterValues);
        if (commandToRun === undefined && !this._options.ignoreMissingScript) {
            throw new Error(`The project [${project.packageName}] does not define a '${this._options.commandToRun}' command in the 'scripts' section of its package.json`);
        }
        this._taskCollection.addTask(new ProjectBuilder_1.ProjectBuilder({
            rushProject: project,
            rushConfiguration: this._options.rushConfiguration,
            buildCacheConfiguration: this._options.buildCacheConfiguration,
            commandToRun: commandToRun || '',
            isIncrementalBuildAllowed: this._options.isIncrementalBuildAllowed,
            packageChangeAnalyzer: this._packageChangeAnalyzer,
            packageDepsFilename: this._options.packageDepsFilename
        }));
    }
    static _getScriptCommand(rushProject, script) {
        if (!rushProject.packageJson.scripts) {
            return undefined;
        }
        const rawCommand = rushProject.packageJson.scripts[script];
        if (rawCommand === undefined || rawCommand === null) {
            return undefined;
        }
        return rawCommand;
    }
}
exports.TaskSelector = TaskSelector;
//# sourceMappingURL=TaskSelector.js.map