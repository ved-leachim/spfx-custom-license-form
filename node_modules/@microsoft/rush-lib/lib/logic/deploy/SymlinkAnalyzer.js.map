{"version":3,"file":"SymlinkAnalyzer.js","sourceRoot":"","sources":["../../../src/logic/deploy/SymlinkAnalyzer.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;;;;;;;;;;;;;;;;;;;;AAE3D,oEAAgG;AAEhG,2CAA6B;AAkD7B,MAAa,eAAe;IAA5B;QACE,uCAAuC;QACtB,iBAAY,GAA0B,IAAI,GAAG,EAAoB,CAAC;QAEnF,qEAAqE;QACpD,qBAAgB,GAA2B,IAAI,GAAG,EAAqB,CAAC;IA4F3F,CAAC;IA1FQ,WAAW,CAAC,SAAiB,EAAE,gBAAyB,KAAK;QAClE,IAAI,YAAY,GAAa,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACrE,IAAI,iBAAiB,GAAW,CAAC,CAAC;QAElC,SAAS;YACP,MAAM,WAAW,GAAW,YAAY,CAAC,KAAK,CAAC,CAAC,EAAE,iBAAiB,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;YAExF,IAAI,WAAW,KAAK,EAAE,EAAE;gBACtB,6EAA6E;gBAC7E,EAAE,iBAAiB,CAAC;gBACpB,SAAS;aACV;YAED,IAAI,WAAW,GAAyB,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;YAC3E,IAAI,WAAW,KAAK,SAAS,EAAE;gBAC7B,MAAM,SAAS,GAAoB,8BAAU,CAAC,iBAAiB,CAAC,WAAW,CAAC,CAAC;gBAE7E,IAAI,SAAS,CAAC,cAAc,EAAE,EAAE;oBAC9B,MAAM,cAAc,GAAW,8BAAU,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC;oBAChE,MAAM,YAAY,GAAW,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC;oBAC1D,MAAM,sBAAsB,GAAW,IAAI,CAAC,OAAO,CAAC,YAAY,EAAE,cAAc,CAAC,CAAC;oBAClF,WAAW,GAAG;wBACZ,IAAI,EAAE,MAAM;wBACZ,QAAQ,EAAE,WAAW;wBACrB,UAAU,EAAE,sBAAsB;qBACnC,CAAC;iBACH;qBAAM,IAAI,SAAS,CAAC,WAAW,EAAE,EAAE;oBAClC,WAAW,GAAG;wBACZ,IAAI,EAAE,QAAQ;wBACd,QAAQ,EAAE,WAAW;qBACtB,CAAC;iBACH;qBAAM,IAAI,SAAS,CAAC,MAAM,EAAE,EAAE;oBAC7B,WAAW,GAAG;wBACZ,IAAI,EAAE,MAAM;wBACZ,QAAQ,EAAE,WAAW;qBACtB,CAAC;iBACH;qBAAM;oBACL,MAAM,IAAI,KAAK,CAAC,uBAAuB,GAAG,WAAW,CAAC,CAAC;iBACxD;gBAED,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;aACjD;YAED,EAAE,iBAAiB,CAAC;YAEpB,IAAI,CAAC,aAAa,EAAE;gBAClB,OAAO,WAAW,CAAC,IAAI,KAAK,MAAM,EAAE;oBAClC,MAAM,UAAU,GAAa,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;oBAE5E,kDAAkD;oBAClD,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,WAAW,CAAC,QAAQ,CAAC,EAAE;wBACpD,iFAAiF;wBACjF,MAAM,iBAAiB,GAAY,8BAAU,CAAC,aAAa,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,WAAW,EAAE,CAAC;wBAC/F,MAAM,QAAQ,GAAc;4BAC1B,IAAI,EAAE,iBAAiB,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,UAAU;4BACnD,QAAQ,EAAE,WAAW,CAAC,QAAQ;4BAC9B,UAAU,EAAE,UAAU,CAAC,QAAQ;yBAChC,CAAC;wBACF,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,WAAW,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;qBAC3D;oBAED,MAAM,cAAc,GAAa,UAAU,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;oBACrE,MAAM,iBAAiB,GAAa,YAAY,CAAC,KAAK,CAAC,iBAAiB,CAAC,CAAC;oBAC1E,YAAY,GAAG,CAAC,GAAG,cAAc,EAAE,GAAG,iBAAiB,CAAC,CAAC;oBACzD,iBAAiB,GAAG,cAAc,CAAC,MAAM,CAAC;oBAC1C,WAAW,GAAG,UAAU,CAAC;iBAC1B;aACF;YAED,IAAI,iBAAiB,IAAI,YAAY,CAAC,MAAM,EAAE;gBAC5C,qBAAqB;gBACrB,OAAO,WAAW,CAAC;aACpB;YAED,IAAI,WAAW,CAAC,IAAI,KAAK,QAAQ,EAAE;gBACjC,+FAA+F;gBAC/F,8BAA8B;gBAC9B,MAAM,IAAI,iCAAa,CAAC,gCAAgC,GAAG,SAAS,CAAC,CAAC;aACvE;SACF;IACH,CAAC;IAED;;OAEG;IACI,cAAc;QACnB,MAAM,IAAI,GAAgB,CAAC,GAAG,IAAI,CAAC,gBAAgB,CAAC,MAAM,EAAE,CAAC,CAAC;QAC9D,wBAAI,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC;QACrC,OAAO,IAAI,CAAC;IACd,CAAC;CACF;AAjGD,0CAiGC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport { FileSystem, FileSystemStats, Sort, InternalError } from '@rushstack/node-core-library';\r\n\r\nimport * as path from 'path';\r\n\r\n/**\r\n * Represents a file object analyzed by {@link SymlinkAnalyzer}.\r\n */\r\nexport interface IFileNode {\r\n  kind: 'file';\r\n  nodePath: string;\r\n}\r\n\r\n/**\r\n * Represents a folder object analyzed by {@link SymlinkAnalyzer}.\r\n */\r\nexport interface IFolderNode {\r\n  kind: 'folder';\r\n  nodePath: string;\r\n}\r\n\r\n/**\r\n * Represents a symbolic link analyzed by {@link SymlinkAnalyzer}.\r\n */\r\nexport interface ILinkNode {\r\n  kind: 'link';\r\n  nodePath: string;\r\n\r\n  /**\r\n   * The immediate target that the symlink resolves to.\r\n   */\r\n  linkTarget: string;\r\n}\r\n\r\nexport type PathNode = IFileNode | IFolderNode | ILinkNode;\r\n\r\n/**\r\n * Represents a symbolic link reported by {@link SymlinkAnalyzer.reportSymlinks()}.\r\n */\r\nexport interface ILinkInfo {\r\n  kind: 'fileLink' | 'folderLink';\r\n\r\n  /**\r\n   * The path of the symbolic link.\r\n   */\r\n  linkPath: string;\r\n\r\n  /**\r\n   * The target that the link points to.\r\n   */\r\n  targetPath: string;\r\n}\r\n\r\nexport class SymlinkAnalyzer {\r\n  // The directory tree discovered so far\r\n  private readonly _nodesByPath: Map<string, PathNode> = new Map<string, PathNode>();\r\n\r\n  // The symlinks that we encountered while building the directory tree\r\n  private readonly _linkInfosByPath: Map<string, ILinkInfo> = new Map<string, ILinkInfo>();\r\n\r\n  public analyzePath(inputPath: string, preserveLinks: boolean = false): PathNode {\r\n    let pathSegments: string[] = path.resolve(inputPath).split(path.sep);\r\n    let pathSegmentsIndex: number = 0;\r\n\r\n    for (;;) {\r\n      const currentPath: string = pathSegments.slice(0, pathSegmentsIndex + 1).join(path.sep);\r\n\r\n      if (currentPath === '') {\r\n        // Edge case for a Unix path like \"/folder/file\" --> [ \"\", \"folder\", \"file\" ]\r\n        ++pathSegmentsIndex;\r\n        continue;\r\n      }\r\n\r\n      let currentNode: PathNode | undefined = this._nodesByPath.get(currentPath);\r\n      if (currentNode === undefined) {\r\n        const linkStats: FileSystemStats = FileSystem.getLinkStatistics(currentPath);\r\n\r\n        if (linkStats.isSymbolicLink()) {\r\n          const linkTargetPath: string = FileSystem.readLink(currentPath);\r\n          const parentFolder: string = path.join(currentPath, '..');\r\n          const resolvedLinkTargetPath: string = path.resolve(parentFolder, linkTargetPath);\r\n          currentNode = {\r\n            kind: 'link',\r\n            nodePath: currentPath,\r\n            linkTarget: resolvedLinkTargetPath\r\n          };\r\n        } else if (linkStats.isDirectory()) {\r\n          currentNode = {\r\n            kind: 'folder',\r\n            nodePath: currentPath\r\n          };\r\n        } else if (linkStats.isFile()) {\r\n          currentNode = {\r\n            kind: 'file',\r\n            nodePath: currentPath\r\n          };\r\n        } else {\r\n          throw new Error('Unknown object type: ' + currentPath);\r\n        }\r\n\r\n        this._nodesByPath.set(currentPath, currentNode);\r\n      }\r\n\r\n      ++pathSegmentsIndex;\r\n\r\n      if (!preserveLinks) {\r\n        while (currentNode.kind === 'link') {\r\n          const targetNode: PathNode = this.analyzePath(currentNode.linkTarget, true);\r\n\r\n          // Have we created an ILinkInfo for this link yet?\r\n          if (!this._linkInfosByPath.has(currentNode.nodePath)) {\r\n            // Follow any symbolic links to determine whether the final target is a directory\r\n            const targetIsDirectory: boolean = FileSystem.getStatistics(targetNode.nodePath).isDirectory();\r\n            const linkInfo: ILinkInfo = {\r\n              kind: targetIsDirectory ? 'folderLink' : 'fileLink',\r\n              linkPath: currentNode.nodePath,\r\n              targetPath: targetNode.nodePath\r\n            };\r\n            this._linkInfosByPath.set(currentNode.nodePath, linkInfo);\r\n          }\r\n\r\n          const targetSegments: string[] = targetNode.nodePath.split(path.sep);\r\n          const remainingSegments: string[] = pathSegments.slice(pathSegmentsIndex);\r\n          pathSegments = [...targetSegments, ...remainingSegments];\r\n          pathSegmentsIndex = targetSegments.length;\r\n          currentNode = targetNode;\r\n        }\r\n      }\r\n\r\n      if (pathSegmentsIndex >= pathSegments.length) {\r\n        // We reached the end\r\n        return currentNode;\r\n      }\r\n\r\n      if (currentNode.kind !== 'folder') {\r\n        // This should never happen, because analyzePath() is always supposed to receive complete paths\r\n        // to real filesystem objects.\r\n        throw new InternalError('The path ends prematurely at: ' + inputPath);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a summary of all the symbolic links encountered by {@link SymlinkAnalyzer.analyzePath}.\r\n   */\r\n  public reportSymlinks(): ILinkInfo[] {\r\n    const list: ILinkInfo[] = [...this._linkInfosByPath.values()];\r\n    Sort.sortBy(list, (x) => x.linkPath);\r\n    return list;\r\n  }\r\n}\r\n"]}