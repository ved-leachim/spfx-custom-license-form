{"version":3,"file":"Task.js","sourceRoot":"","sources":["../../../src/logic/taskRunner/Task.ts"],"names":[],"mappings":";AAAC,4FAA4F;AAC7F,2DAA2D;;;AAU3D;;;;GAIG;AACH,MAAa,IAAI;IA2Ef,YAAmB,OAAoB,EAAE,aAAyB;QA5DlE;;;WAGG;QACI,iBAAY,GAAc,IAAI,GAAG,EAAQ,CAAC;QAEjD;;WAEG;QACI,eAAU,GAAc,IAAI,GAAG,EAAQ,CAAC;QAoD7C,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,MAAM,GAAG,aAAa,CAAC;IAC9B,CAAC;IAED,IAAW,IAAI;QACb,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC;IAC3B,CAAC;CACF;AAnFD,oBAmFC","sourcesContent":["ï»¿// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport { StdioSummarizer } from '@rushstack/terminal';\r\nimport { CollatedWriter } from '@rushstack/stream-collator';\r\n\r\nimport { Stopwatch } from '../../utilities/Stopwatch';\r\nimport { TaskStatus } from './TaskStatus';\r\nimport { TaskError } from './TaskError';\r\nimport { BaseBuilder } from './BaseBuilder';\r\n\r\n/**\r\n * The `Task` class is a node in the dependency graph of work that needs to be scheduled by the `TaskRunner`.\r\n * Each `Task` has a `BaseBuilder` member, whose subclass manages the actual operations for building a single\r\n * project.\r\n */\r\nexport class Task {\r\n  /**\r\n   * When the scheduler is ready to process this `Task`, the `builder` implements the actual work of\r\n   * building the project.\r\n   */\r\n  public builder: BaseBuilder;\r\n\r\n  /**\r\n   * The current execution status of a task. Tasks start in the 'ready' state,\r\n   * but can be 'blocked' if an upstream task failed. It is 'executing' when\r\n   * the task is executing. Once execution is complete, it is either 'success' or\r\n   * 'failure'.\r\n   */\r\n  public status: TaskStatus;\r\n\r\n  /**\r\n   * A set of all dependencies which must be executed before this task is complete.\r\n   * When dependencies finish execution, they are removed from this list.\r\n   */\r\n  public dependencies: Set<Task> = new Set<Task>();\r\n\r\n  /**\r\n   * The inverse of dependencies, lists all projects which are directly dependent on this one.\r\n   */\r\n  public dependents: Set<Task> = new Set<Task>();\r\n\r\n  /**\r\n   * This number represents how far away this Task is from the furthest \"root\" project (i.e.\r\n   * a project with no dependents). This helps us to calculate the critical path (i.e. the\r\n   * longest chain of projects which must be executed in order, thereby limiting execution speed\r\n   * of the entire task tree.\r\n   *\r\n   * This number is calculated via a memoized recursive function, and when choosing the next\r\n   * task to execute, the task with the highest criticalPathLength is chosen.\r\n   *\r\n   * Example:\r\n   *        (0) A\r\n   *             \\\r\n   *          (1) B     C (0)         (applications)\r\n   *               \\   /|\\\r\n   *                \\ / | \\\r\n   *             (2) D  |  X (1)      (utilities)\r\n   *                    | / \\\r\n   *                    |/   \\\r\n   *                (2) Y     Z (2)   (other utilities)\r\n   *\r\n   * All roots (A & C) have a criticalPathLength of 0.\r\n   * B has a score of 1, since A depends on it.\r\n   * D has a score of 2, since we look at the longest chain (e.g D->B->A is longer than D->C)\r\n   * X has a score of 1, since the only package which depends on it is A\r\n   * Z has a score of 2, since only X depends on it, and X has a score of 1\r\n   * Y has a score of 2, since the chain Y->X->C is longer than Y->C\r\n   *\r\n   * The algorithm is implemented in TaskRunner as _calculateCriticalPaths()\r\n   */\r\n  public criticalPathLength: number | undefined;\r\n\r\n  /**\r\n   * The error which occurred while executing this task, this is stored in case we need\r\n   * it later (for example to re-print errors at end of execution).\r\n   */\r\n  public error: TaskError | undefined;\r\n\r\n  /**\r\n   * The task writer which contains information from the output streams of this task\r\n   */\r\n  public collatedWriter!: CollatedWriter;\r\n\r\n  public stdioSummarizer!: StdioSummarizer;\r\n\r\n  /**\r\n   * The stopwatch which measures how long it takes the task to execute\r\n   */\r\n  public stopwatch!: Stopwatch;\r\n\r\n  public constructor(builder: BaseBuilder, initialStatus: TaskStatus) {\r\n    this.builder = builder;\r\n    this.status = initialStatus;\r\n  }\r\n\r\n  public get name(): string {\r\n    return this.builder.name;\r\n  }\r\n}\r\n"]}