import { BuildCacheConfiguration } from '../api/BuildCacheConfiguration';
import { RushConfiguration } from '../api/RushConfiguration';
import { RushConfigurationProject } from '../api/RushConfigurationProject';
import { TaskCollection } from './taskRunner/TaskCollection';
export interface ITaskSelectorConstructor {
    rushConfiguration: RushConfiguration;
    buildCacheConfiguration: BuildCacheConfiguration | undefined;
    toProjects: ReadonlyArray<RushConfigurationProject>;
    fromProjects: ReadonlyArray<RushConfigurationProject>;
    commandToRun: string;
    customParameterValues: string[];
    isQuietMode: boolean;
    isIncrementalBuildAllowed: boolean;
    ignoreMissingScript: boolean;
    ignoreDependencyOrder: boolean;
    packageDepsFilename: string;
}
/**
 * This class is responsible for:
 *  - based on to/from flags, solving the dependency graph and figuring out which projects need to be run
 *  - creating a ProjectBuilder for each project that needs to be built
 *  - registering the necessary ProjectBuilders with the TaskRunner, which actually orchestrates execution
 */
export declare class TaskSelector {
    private _taskCollection;
    private _options;
    private _packageChangeAnalyzer;
    constructor(options: ITaskSelectorConstructor);
    static getScriptToRun(rushProject: RushConfigurationProject, commandToRun: string, customParameterValues: string[]): string | undefined;
    registerTasks(): TaskCollection;
    private _registerToProjects;
    private _registerFromProjects;
    private _registerAll;
    /**
     * Collects all upstream dependencies for a certain project
     */
    private _collectAllDependencies;
    /**
     * Collects all downstream dependents of a certain project
     */
    private _collectAllDependents;
    /**
     * Inverts the localLinks to arrive at the dependent graph. This helps when using the --from flag
     */
    private _getDependentGraph;
    private _registerTask;
    private static _getScriptCommand;
}
//# sourceMappingURL=TaskSelector.d.ts.map