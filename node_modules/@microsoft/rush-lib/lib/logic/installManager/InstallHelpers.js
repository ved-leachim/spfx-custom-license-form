"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InstallHelpers = void 0;
const colors_1 = __importDefault(require("colors"));
const os = __importStar(require("os"));
const path = __importStar(require("path"));
const semver = __importStar(require("semver"));
const node_core_library_1 = require("@rushstack/node-core-library");
const LastInstallFlag_1 = require("../../api/LastInstallFlag");
const Utilities_1 = require("../../utilities/Utilities");
class InstallHelpers {
    /**
     * Returns a map containing all preferred versions for a Rush project.
     * Returns a map: dependency name --> version specifier
     */
    static collectPreferredVersions(rushConfiguration, options = {}) {
        // dependency name --> version specifier
        const allExplicitPreferredVersions = options.explicitPreferredVersions
            ? options.explicitPreferredVersions
            : rushConfiguration.getCommonVersions(options.variant).getAllPreferredVersions();
        // dependency name --> version specifier
        const allPreferredVersions = new Map();
        // Should we add implicitly preferred versions?
        let useImplicitlyPinnedVersions;
        if (rushConfiguration.commonVersions.implicitlyPreferredVersions !== undefined) {
            // Use the manually configured setting
            useImplicitlyPinnedVersions = rushConfiguration.commonVersions.implicitlyPreferredVersions;
        }
        else {
            // Default to true.
            useImplicitlyPinnedVersions = true;
        }
        if (useImplicitlyPinnedVersions) {
            // Add in the implicitly preferred versions.
            // These are any first-level dependencies for which we only consume a single version range
            // (e.g. every package that depends on react uses an identical specifier)
            const implicitlyPreferredVersions = InstallHelpers.collectImplicitlyPreferredVersions(rushConfiguration, options);
            node_core_library_1.MapExtensions.mergeFromMap(allPreferredVersions, implicitlyPreferredVersions);
        }
        // Add in the explicitly preferred versions.
        // Note that these take precedence over implicitly preferred versions.
        node_core_library_1.MapExtensions.mergeFromMap(allPreferredVersions, allExplicitPreferredVersions);
        return allPreferredVersions;
    }
    /**
     * Returns a map of all direct dependencies that only have a single semantic version specifier.
     * Returns a map: dependency name --> version specifier
     */
    static collectImplicitlyPreferredVersions(rushConfiguration, options = {}) {
        // First, collect all the direct dependencies of all local projects, and their versions:
        // direct dependency name --> set of version specifiers
        const versionsForDependencies = new Map();
        rushConfiguration.projects.forEach((project) => {
            InstallHelpers._collectVersionsForDependencies(rushConfiguration, {
                versionsForDependencies,
                dependencies: project.packageJsonEditor.dependencyList,
                cyclicDependencies: project.cyclicDependencyProjects,
                variant: options.variant
            });
            InstallHelpers._collectVersionsForDependencies(rushConfiguration, {
                versionsForDependencies,
                dependencies: project.packageJsonEditor.devDependencyList,
                cyclicDependencies: project.cyclicDependencyProjects,
                variant: options.variant
            });
        });
        // If any dependency has more than one version, then filter it out (since we don't know which version
        // should be preferred).  What remains will be the list of preferred dependencies.
        // dependency --> version specifier
        const implicitlyPreferred = new Map();
        versionsForDependencies.forEach((versions, dep) => {
            if (versions.size === 1) {
                const version = Array.from(versions)[0];
                implicitlyPreferred.set(dep, version);
            }
        });
        return implicitlyPreferred;
    }
    static generateCommonPackageJson(rushConfiguration, dependencies = new Map()) {
        const commonPackageJson = {
            dependencies: {},
            description: 'Temporary file generated by the Rush tool',
            name: 'rush-common',
            private: true,
            version: '0.0.0'
        };
        // Add any preferred versions to the top of the commonPackageJson
        // do this in alphabetical order for simpler debugging
        for (const dependency of Array.from(dependencies.keys()).sort()) {
            commonPackageJson.dependencies[dependency] = dependencies.get(dependency);
        }
        // Example: "C:\MyRepo\common\temp\package.json"
        const commonPackageJsonFilename = path.join(rushConfiguration.commonTempFolder, "package.json" /* PackageJson */);
        // Don't update the file timestamp unless the content has changed, since "rush install"
        // will consider this timestamp
        node_core_library_1.JsonFile.save(commonPackageJson, commonPackageJsonFilename, { onlyIfChanged: true });
    }
    static getPackageManagerEnvironment(rushConfiguration, options = {}) {
        let configurationEnvironment = undefined;
        if (rushConfiguration.packageManager === 'npm') {
            if (rushConfiguration.npmOptions && rushConfiguration.npmOptions.environmentVariables) {
                configurationEnvironment = rushConfiguration.npmOptions.environmentVariables;
            }
        }
        else if (rushConfiguration.packageManager === 'pnpm') {
            if (rushConfiguration.pnpmOptions && rushConfiguration.pnpmOptions.environmentVariables) {
                configurationEnvironment = rushConfiguration.pnpmOptions.environmentVariables;
            }
        }
        else if (rushConfiguration.packageManager === 'yarn') {
            if (rushConfiguration.yarnOptions && rushConfiguration.yarnOptions.environmentVariables) {
                configurationEnvironment = rushConfiguration.yarnOptions.environmentVariables;
            }
        }
        return InstallHelpers._mergeEnvironmentVariables(process.env, configurationEnvironment, options);
    }
    /**
     * If the "(p)npm-local" symlink hasn't been set up yet, this creates it, installing the
     * specified (P)npm version in the user's home directory if needed.
     */
    static async ensureLocalPackageManager(rushConfiguration, rushGlobalFolder, maxInstallAttempts) {
        // Example: "C:\Users\YourName\.rush"
        const rushUserFolder = rushGlobalFolder.nodeSpecificPath;
        if (!node_core_library_1.FileSystem.exists(rushUserFolder)) {
            console.log('Creating ' + rushUserFolder);
            node_core_library_1.FileSystem.ensureFolder(rushUserFolder);
        }
        const packageManager = rushConfiguration.packageManager;
        const packageManagerVersion = rushConfiguration.packageManagerToolVersion;
        const packageManagerAndVersion = `${packageManager}-${packageManagerVersion}`;
        // Example: "C:\Users\YourName\.rush\pnpm-1.2.3"
        const packageManagerToolFolder = path.join(rushUserFolder, packageManagerAndVersion);
        const packageManagerMarker = new LastInstallFlag_1.LastInstallFlag(packageManagerToolFolder, {
            node: process.versions.node
        });
        console.log(`Trying to acquire lock for ${packageManagerAndVersion}`);
        const lock = await node_core_library_1.LockFile.acquire(rushUserFolder, packageManagerAndVersion);
        console.log(`Acquired lock for ${packageManagerAndVersion}`);
        if (!packageManagerMarker.isValid() || lock.dirtyWhenAcquired) {
            console.log(colors_1.default.bold(`Installing ${packageManager} version ${packageManagerVersion}${os.EOL}`));
            // note that this will remove the last-install flag from the directory
            Utilities_1.Utilities.installPackageInDirectory({
                directory: packageManagerToolFolder,
                packageName: packageManager,
                version: rushConfiguration.packageManagerToolVersion,
                tempPackageTitle: `${packageManager}-local-install`,
                maxInstallAttempts: maxInstallAttempts,
                // This is using a local configuration to install a package in a shared global location.
                // Generally that's a bad practice, but in this case if we can successfully install
                // the package at all, we can reasonably assume it's good for all the repositories.
                // In particular, we'll assume that two different NPM registries cannot have two
                // different implementations of the same version of the same package.
                // This was needed for: https://github.com/microsoft/rushstack/issues/691
                commonRushConfigFolder: rushConfiguration.commonRushConfigFolder
            });
            console.log(`Successfully installed ${packageManager} version ${packageManagerVersion}`);
        }
        else {
            console.log(`Found ${packageManager} version ${packageManagerVersion} in ${packageManagerToolFolder}`);
        }
        packageManagerMarker.create();
        // Example: "C:\MyRepo\common\temp"
        node_core_library_1.FileSystem.ensureFolder(rushConfiguration.commonTempFolder);
        // Example: "C:\MyRepo\common\temp\pnpm-local"
        const localPackageManagerToolFolder = path.join(rushConfiguration.commonTempFolder, `${packageManager}-local`);
        console.log(os.EOL + 'Symlinking "' + localPackageManagerToolFolder + '"');
        console.log('  --> "' + packageManagerToolFolder + '"');
        // We cannot use FileSystem.exists() to test the existence of a symlink, because it will
        // return false for broken symlinks.  There is no way to test without catching an exception.
        try {
            node_core_library_1.FileSystem.deleteFolder(localPackageManagerToolFolder);
        }
        catch (error) {
            if (error.code !== 'ENOENT') {
                throw error;
            }
        }
        node_core_library_1.FileSystem.createSymbolicLinkJunction({
            linkTargetPath: packageManagerToolFolder,
            newLinkPath: localPackageManagerToolFolder
        });
        lock.release();
    }
    // Helper for collectImplicitlyPreferredVersions()
    static _collectVersionsForDependencies(rushConfiguration, options) {
        const { variant, dependencies, versionsForDependencies, cyclicDependencies } = options;
        const commonVersions = rushConfiguration.getCommonVersions(variant);
        const allowedAlternativeVersions = commonVersions.allowedAlternativeVersions;
        for (const dependency of dependencies) {
            const alternativesForThisDependency = allowedAlternativeVersions.get(dependency.name) || [];
            // For each dependency, collectImplicitlyPreferredVersions() is collecting the set of all version specifiers
            // that appear across the repo.  If there is only one version specifier, then that's the "preferred" one.
            // However, there are a few cases where additional version specifiers can be safely ignored.
            let ignoreVersion = false;
            // 1. If the version specifier was listed in "allowedAlternativeVersions", then it's never a candidate.
            //    (Even if it's the only version specifier anywhere in the repo, we still ignore it, because
            //    otherwise the rule would be difficult to explain.)
            if (alternativesForThisDependency.indexOf(dependency.version) > 0) {
                ignoreVersion = true;
            }
            else {
                // Is it a local project?
                const localProject = rushConfiguration.getProjectByName(dependency.name);
                if (localProject) {
                    // 2. If it's a symlinked local project, then it's not a candidate, because the package manager will
                    //    never even see it.
                    // However there are two ways that a local project can NOT be symlinked:
                    // - if the local project doesn't satisfy the referenced semver specifier; OR
                    // - if the local project was specified in "cyclicDependencyProjects" in rush.json
                    if (semver.satisfies(localProject.packageJsonEditor.version, dependency.version) &&
                        !cyclicDependencies.has(dependency.name)) {
                        ignoreVersion = true;
                    }
                }
                if (!ignoreVersion) {
                    InstallHelpers._updateVersionsForDependencies(versionsForDependencies, dependency.name, dependency.version);
                }
            }
        }
    }
    // Helper for collectImplicitlyPreferredVersions()
    static _updateVersionsForDependencies(versionsForDependencies, dependency, version) {
        if (!versionsForDependencies.has(dependency)) {
            versionsForDependencies.set(dependency, new Set());
        }
        versionsForDependencies.get(dependency).add(version);
    }
    // Helper for getPackageManagerEnvironment
    static _mergeEnvironmentVariables(baseEnv, environmentVariables, options = {}) {
        const packageManagerEnv = baseEnv;
        if (environmentVariables) {
            // eslint-disable-next-line guard-for-in
            for (const envVar in environmentVariables) {
                let setEnvironmentVariable = true;
                console.log(`\nProcessing definition for environment variable: ${envVar}`);
                if (baseEnv.hasOwnProperty(envVar)) {
                    setEnvironmentVariable = false;
                    console.log(`Environment variable already defined:`);
                    console.log(`  Name: ${envVar}`);
                    console.log(`  Existing value: ${baseEnv[envVar]}`);
                    console.log(`  Value set in rush.json: ${environmentVariables[envVar].value}`);
                    if (environmentVariables[envVar].override) {
                        setEnvironmentVariable = true;
                        console.log(`Overriding the environment variable with the value set in rush.json.`);
                    }
                    else {
                        console.log(colors_1.default.yellow(`WARNING: Not overriding the value of the environment variable.`));
                    }
                }
                if (setEnvironmentVariable) {
                    if (options.debug) {
                        console.log(`Setting environment variable for package manager.`);
                        console.log(`  Name: ${envVar}`);
                        console.log(`  Value: ${environmentVariables[envVar].value}`);
                    }
                    packageManagerEnv[envVar] = environmentVariables[envVar].value;
                }
            }
        }
        return packageManagerEnv;
    }
}
exports.InstallHelpers = InstallHelpers;
//# sourceMappingURL=InstallHelpers.js.map