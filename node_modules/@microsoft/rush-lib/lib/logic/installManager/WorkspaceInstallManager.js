"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkspaceInstallManager = void 0;
const colors_1 = __importDefault(require("colors"));
const os = __importStar(require("os"));
const path = __importStar(require("path"));
const semver = __importStar(require("semver"));
const node_core_library_1 = require("@rushstack/node-core-library");
const BaseInstallManager_1 = require("../base/BaseInstallManager");
const DependencySpecifier_1 = require("../DependencySpecifier");
const PnpmWorkspaceFile_1 = require("../pnpm/PnpmWorkspaceFile");
const RushConstants_1 = require("../../logic/RushConstants");
const Stopwatch_1 = require("../../utilities/Stopwatch");
const Utilities_1 = require("../../utilities/Utilities");
const InstallHelpers_1 = require("./InstallHelpers");
const PnpmProjectDependencyManifest_1 = require("../pnpm/PnpmProjectDependencyManifest");
const PnpmShrinkwrapFile_1 = require("../pnpm/PnpmShrinkwrapFile");
const LastLinkFlag_1 = require("../../api/LastLinkFlag");
/**
 * This class implements common logic between "rush install" and "rush update".
 */
class WorkspaceInstallManager extends BaseInstallManager_1.BaseInstallManager {
    /**
     * @override
     */
    async doInstall() {
        // TODO: Remove when "rush link" and "rush unlink" are deprecated
        if (this.options.noLink) {
            console.log(colors_1.default.red('The "--no-link" option was provided but is not supported when using workspaces. Run the command again ' +
                'without specifying this argument.'));
            throw new node_core_library_1.AlreadyReportedError();
        }
        await super.doInstall();
    }
    /**
     * Regenerates the common/temp/package.json and related workspace files.
     * If shrinkwrapFile is provided, this function also validates whether it contains
     * everything we need to install and returns true if so; in all other cases,
     * the return value is false.
     *
     * @override
     */
    async prepareCommonTempAsync(shrinkwrapFile) {
        const stopwatch = Stopwatch_1.Stopwatch.start();
        console.log(os.EOL + colors_1.default.bold('Updating workspace files in ' + this.rushConfiguration.commonTempFolder));
        // Shim support for common versions resolution into the pnpmfile. When using workspaces, there are no
        // "hoisted" packages, so we need to apply the correct versions to indirect dependencies through the
        // pnpmfile.
        if (this.rushConfiguration.packageManager === 'pnpm') {
            const tempPnpmFilePath = path.join(this.rushConfiguration.commonTempFolder, RushConstants_1.RushConstants.pnpmfileFilename);
            await this.createShimPnpmfileAsync(tempPnpmFilePath);
        }
        const shrinkwrapWarnings = [];
        // We will start with the assumption that it's valid, and then set it to false if
        // any of the checks fail
        let shrinkwrapIsUpToDate = true;
        if (!shrinkwrapFile) {
            shrinkwrapIsUpToDate = false;
        }
        else {
            if (shrinkwrapFile.getWorkspaceKeys().length === 0 &&
                this.rushConfiguration.projects.length !== 0 &&
                !this.options.fullUpgrade) {
                console.log();
                console.log(colors_1.default.red('The shrinkwrap file has not been updated to support workspaces. Run "rush update --full" to update ' +
                    'the shrinkwrap file.'));
                throw new node_core_library_1.AlreadyReportedError();
            }
        }
        if (shrinkwrapFile) {
            if (this._findOrphanedWorkspaceProjects(shrinkwrapFile)) {
                // If there are any orphaned projects, then install would fail because the shrinkwrap
                // contains references that refer to nonexistent file paths.
                shrinkwrapIsUpToDate = false;
            }
        }
        // If preferred versions have been updated, then we can't be certain of the state of the shrinkwrap
        const repoState = this.rushConfiguration.getRepoState(this.options.variant);
        const commonVersions = this.rushConfiguration.getCommonVersions(this.options.variant);
        if (repoState.preferredVersionsHash !== commonVersions.getPreferredVersionsHash()) {
            shrinkwrapWarnings.push(`Preferred versions from ${RushConstants_1.RushConstants.commonVersionsFilename} have been modified.`);
            shrinkwrapIsUpToDate = false;
        }
        // To generate the workspace file, we will add each project to the file as we loop through and validate
        const workspaceFile = new PnpmWorkspaceFile_1.PnpmWorkspaceFile(path.join(this.rushConfiguration.commonTempFolder, 'pnpm-workspace.yaml'));
        // Loop through the projects and add them to the workspace file. While we're at it, also validate that
        // referenced workspace projects are valid, and check if the shrinkwrap file is already up-to-date.
        for (const rushProject of this.rushConfiguration.projects) {
            const packageJson = rushProject.packageJsonEditor;
            workspaceFile.addPackage(rushProject.projectFolder);
            for (const { name, version, dependencyType } of [
                ...packageJson.dependencyList,
                ...packageJson.devDependencyList
            ]) {
                // Allow the package manager to handle peer dependency resolution, since this is simply a constraint
                // enforced by the package manager. Additionally, peer dependencies are simply a version constraint
                // and do not need to be converted to workspaces protocol.
                if (dependencyType === "peerDependencies" /* Peer */) {
                    continue;
                }
                const dependencySpecifier = new DependencySpecifier_1.DependencySpecifier(name, version);
                // Is there a locally built Rush project that could satisfy this dependency?
                const referencedLocalProject = this.rushConfiguration.getProjectByName(name);
                // Validate that local projects are referenced with workspace notation. If not, and it is not a
                // cyclic dependency, then it needs to be updated to specify `workspace:*` explicitly. Currently only
                // supporting versions and version ranges for specifying a local project.
                if ((dependencySpecifier.specifierType === DependencySpecifier_1.DependencySpecifierType.Version ||
                    dependencySpecifier.specifierType === DependencySpecifier_1.DependencySpecifierType.Range) &&
                    referencedLocalProject &&
                    !rushProject.cyclicDependencyProjects.has(name)) {
                    // Make sure that this version is intended to target a local package. If not, then we will fail since it
                    // is not explicitly specified as a cyclic dependency.
                    if (!semver.satisfies(referencedLocalProject.packageJsonEditor.version, dependencySpecifier.versionSpecifier)) {
                        console.log();
                        console.log(colors_1.default.red(`"${rushProject.packageName}" depends on package "${name}" (${version}) which exists ` +
                            'within the workspace but cannot be fulfilled with the specified version range. Either ' +
                            'specify a valid version range, or add the package as a cyclic dependency.'));
                        throw new node_core_library_1.AlreadyReportedError();
                    }
                    if (!this.options.allowShrinkwrapUpdates) {
                        console.log();
                        console.log(colors_1.default.red(`"${rushProject.packageName}" depends on package "${name}" (${version}) which exists within ` +
                            'the workspace. Run "rush update" to update workspace references for this package.'));
                        throw new node_core_library_1.AlreadyReportedError();
                    }
                    if (this.options.fullUpgrade) {
                        // We will update to `workspace` notation. If the version specified is a range, then use the provided range.
                        // Otherwise, use `workspace:*` to ensure we're always using the workspace package.
                        const workspaceRange = !!semver.validRange(dependencySpecifier.versionSpecifier) &&
                            !semver.valid(dependencySpecifier.versionSpecifier)
                            ? dependencySpecifier.versionSpecifier
                            : '*';
                        packageJson.addOrUpdateDependency(name, `workspace:${workspaceRange}`, dependencyType);
                        shrinkwrapIsUpToDate = false;
                        continue;
                    }
                }
                else if (dependencySpecifier.specifierType === DependencySpecifier_1.DependencySpecifierType.Workspace) {
                    // Already specified as a local project. Allow the package manager to validate this
                    continue;
                }
                // It is not a local dependency, validate that it is compatible
                if (shrinkwrapFile &&
                    !shrinkwrapFile.hasCompatibleWorkspaceDependency(dependencySpecifier, shrinkwrapFile.getWorkspaceKeyByPath(this.rushConfiguration.commonTempFolder, rushProject.projectFolder))) {
                    shrinkwrapWarnings.push(`Missing dependency "${name}" (${version}) required by "${rushProject.packageName}"`);
                    shrinkwrapIsUpToDate = false;
                }
            }
            // Save the package.json if we modified the version references and warn that the package.json was modified
            if (packageJson.saveIfModified()) {
                console.log(colors_1.default.yellow(`"${rushProject.packageName}" depends on one or more workspace packages which did not use "workspace:" ` +
                    'notation. The package.json has been modified and must be committed to source control.'));
            }
        }
        // Write the common package.json
        InstallHelpers_1.InstallHelpers.generateCommonPackageJson(this.rushConfiguration);
        // Save the generated workspace file. Don't update the file timestamp unless the content has changed,
        // since "rush install" will consider this timestamp
        workspaceFile.save(workspaceFile.workspaceFilename, { onlyIfChanged: true });
        stopwatch.stop();
        console.log(`Finished creating workspace (${stopwatch.toString()})`);
        return { shrinkwrapIsUpToDate, shrinkwrapWarnings };
    }
    canSkipInstall(lastModifiedDate) {
        console.log(os.EOL +
            colors_1.default.bold(`Checking ${RushConstants_1.RushConstants.nodeModulesFolderName} in ${this.rushConfiguration.commonTempFolder}`) +
            os.EOL);
        // Based on timestamps, can we skip this install entirely?
        const potentiallyChangedFiles = [];
        // Consider the timestamp on the node_modules folder; if someone tampered with it
        // or deleted it entirely, then we can't skip this install
        potentiallyChangedFiles.push(path.join(this.rushConfiguration.commonTempFolder, RushConstants_1.RushConstants.nodeModulesFolderName));
        // Additionally, if they pulled an updated shrinkwrap file from Git, then we can't skip this install
        potentiallyChangedFiles.push(this.rushConfiguration.getCommittedShrinkwrapFilename(this.options.variant));
        // Add common-versions.json file to the potentially changed files list.
        potentiallyChangedFiles.push(this.rushConfiguration.getCommonVersionsFilePath(this.options.variant));
        if (this.rushConfiguration.packageManager === 'pnpm') {
            // If the repo is using pnpmfile.js, consider that also
            const pnpmFileFilename = this.rushConfiguration.getPnpmfilePath(this.options.variant);
            if (node_core_library_1.FileSystem.exists(pnpmFileFilename)) {
                potentiallyChangedFiles.push(pnpmFileFilename);
            }
            // Add workspace file. This file is only modified when workspace packages change.
            const pnpmWorkspaceFilename = path.join(this.rushConfiguration.commonTempFolder, 'pnpm-workspace.yaml');
            if (node_core_library_1.FileSystem.exists(pnpmWorkspaceFilename)) {
                potentiallyChangedFiles.push();
            }
        }
        // Also consider timestamps for all the project node_modules folders, as well as the package.json
        // files
        // Example: [ "C:\MyRepo\projects\projectA\node_modules", "C:\MyRepo\projects\projectA\package.json" ]
        potentiallyChangedFiles.push(...this.rushConfiguration.projects.map((x) => {
            return path.join(x.projectFolder, RushConstants_1.RushConstants.nodeModulesFolderName);
        }), ...this.rushConfiguration.projects.map((x) => {
            return path.join(x.projectFolder, "package.json" /* PackageJson */);
        }));
        // NOTE: If any of the potentiallyChangedFiles does not exist, then isFileTimestampCurrent()
        // returns false.
        return Utilities_1.Utilities.isFileTimestampCurrent(lastModifiedDate, potentiallyChangedFiles);
    }
    /**
     * Runs "npm install" in the common folder.
     */
    async installAsync(cleanInstall) {
        // Example: "C:\MyRepo\common\temp\npm-local\node_modules\.bin\npm"
        const packageManagerFilename = this.rushConfiguration.packageManagerToolFilename;
        const packageManagerEnv = InstallHelpers_1.InstallHelpers.getPackageManagerEnvironment(this.rushConfiguration, this.options);
        const commonNodeModulesFolder = path.join(this.rushConfiguration.commonTempFolder, RushConstants_1.RushConstants.nodeModulesFolderName);
        // Is there an existing "node_modules" folder to consider?
        if (node_core_library_1.FileSystem.exists(commonNodeModulesFolder)) {
            // Should we delete the entire "node_modules" folder?
            if (cleanInstall) {
                // YES: Delete "node_modules"
                // Explain to the user why we are hosing their node_modules folder
                console.log('Deleting files from ' + commonNodeModulesFolder);
                this.installRecycler.moveFolder(commonNodeModulesFolder);
                Utilities_1.Utilities.createFolderWithRetry(commonNodeModulesFolder);
            }
        }
        // Run "npm install" in the common folder
        const installArgs = ['install'];
        this.pushConfigurationArgs(installArgs, this.options);
        console.log(os.EOL +
            colors_1.default.bold(`Running "${this.rushConfiguration.packageManager} install" in` +
                ` ${this.rushConfiguration.commonTempFolder}`) +
            os.EOL);
        // If any diagnostic options were specified, then show the full command-line
        if (this.options.debug || this.options.collectLogFile || this.options.networkConcurrency) {
            console.log(os.EOL +
                colors_1.default.green('Invoking package manager: ') +
                node_core_library_1.FileSystem.getRealPath(packageManagerFilename) +
                ' ' +
                installArgs.join(' ') +
                os.EOL);
        }
        try {
            Utilities_1.Utilities.executeCommandWithRetry({
                command: packageManagerFilename,
                args: installArgs,
                workingDirectory: this.rushConfiguration.commonTempFolder,
                environment: packageManagerEnv,
                suppressOutput: false
            }, this.options.maxInstallAttempts, () => {
                if (this.rushConfiguration.packageManager === 'pnpm') {
                    console.log(colors_1.default.yellow(`Deleting the "node_modules" folder`));
                    this.installRecycler.moveFolder(commonNodeModulesFolder);
                    // Leave the pnpm-store as is for the retry. This ensures that packages that have already
                    // been downloaded need not be downloaded again, thereby potentially increasing the chances
                    // of a subsequent successful install.
                    Utilities_1.Utilities.createFolderWithRetry(commonNodeModulesFolder);
                }
            });
            // Ensure that node_modules folders exist after install, since the timestamps on these folders are used
            // to determine if the install can be skipped
            const projectNodeModulesFolders = [
                path.join(this.rushConfiguration.commonTempFolder, RushConstants_1.RushConstants.nodeModulesFolderName),
                ...this.rushConfiguration.projects.map((x) => {
                    return path.join(x.projectFolder, RushConstants_1.RushConstants.nodeModulesFolderName);
                })
            ];
            for (const nodeModulesFolder of projectNodeModulesFolders) {
                node_core_library_1.FileSystem.ensureFolder(nodeModulesFolder);
            }
        }
        catch (error) {
            // All the install attempts failed.
            if (this.rushConfiguration.packageManager === 'pnpm' &&
                this.rushConfiguration.pnpmOptions.pnpmStore === 'local') {
                // If the installation has failed even after the retries, then pnpm store may
                // have got into a corrupted, irrecoverable state. Delete the store so that a
                // future install can create the store afresh.
                console.log(colors_1.default.yellow(`Deleting the "pnpm-store" folder`));
                this.installRecycler.moveFolder(this.rushConfiguration.pnpmOptions.pnpmStorePath);
            }
            throw error;
        }
        console.log('');
    }
    async postInstallAsync() {
        // Per-project manifests can only be generated for PNPM currently
        if (this.rushConfiguration.packageManager === 'pnpm' && this.rushConfiguration.pnpmOptions) {
            // Base it off the temp shrinkwrap, as this was the most recently completed install
            const tempShrinkwrapFile = PnpmShrinkwrapFile_1.PnpmShrinkwrapFile.loadFromFile(this.rushConfiguration.tempShrinkwrapFilename, this.rushConfiguration.pnpmOptions);
            await Promise.all(this.rushConfiguration.projects.map((x) => this._createPerProjectManifestAsync(tempShrinkwrapFile, x)));
        }
        // TODO: Remove when "rush link" and "rush unlink" are deprecated
        LastLinkFlag_1.LastLinkFlagFactory.getCommonTempFlag(this.rushConfiguration).create();
    }
    /**
     * Preferred versions are supported using pnpmfile by substituting any dependency version specifier
     * for the preferred version during package resolution. This is only done if the preferred version range
     * is a subset of the dependency version range. Allowed alternate versions are not modified. The pnpmfile
     * shim will subsequently call into the provided pnpmfile, if one exists.
     */
    async createShimPnpmfileAsync(filename) {
        const pnpmfileDir = path.dirname(filename);
        let pnpmfileExists = false;
        try {
            // Attempt to move the existing pnpmfile if there is one
            await node_core_library_1.FileSystem.moveAsync({
                sourcePath: filename,
                destinationPath: path.join(pnpmfileDir, 'clientPnpmfile.js')
            });
            pnpmfileExists = true;
        }
        catch (error) {
            if (!node_core_library_1.FileSystem.isNotExistError(error)) {
                throw error;
            }
        }
        const pnpmfileShimSettings = {
            allPreferredVersions: node_core_library_1.MapExtensions.toObject(InstallHelpers_1.InstallHelpers.collectPreferredVersions(this.rushConfiguration, this.options)),
            allowedAlternativeVersions: node_core_library_1.MapExtensions.toObject(this.rushConfiguration.getCommonVersions(this.options.variant).allowedAlternativeVersions),
            semverPath: require.resolve('semver'),
            useClientPnpmfile: pnpmfileExists
        };
        // Write the settings to be consumed by the pnpmfile
        await node_core_library_1.JsonFile.saveAsync(pnpmfileShimSettings, path.resolve(pnpmfileDir, 'pnpmfileSettings.json'), {
            ensureFolderExists: true
        });
        // Copy the shim pnpmfile to the original path
        await node_core_library_1.FileSystem.copyFileAsync({
            sourcePath: path.resolve(__dirname, '..', 'pnpm', 'PnpmfileShim.js'),
            destinationPath: filename
        });
    }
    /**
     * If the feature is enabled, creates shrinkwrap-deps.json files and places them in <projectFolder>/.rush/temp.
     * These files contain the integrity hash of every dependency as well as dependencies of dependencies. This
     * file can be used to track whether or not the packages consumed by this project changed between installs.
     */
    _createPerProjectManifestAsync(pnpmShrinkwrapFile, project) {
        const pnpmProjectDependencyManifest = new PnpmProjectDependencyManifest_1.PnpmProjectDependencyManifest({
            pnpmShrinkwrapFile,
            project
        });
        // If the feature is not enabled, clean up the manifest and return
        if (this.rushConfiguration.experimentsConfiguration.configuration.legacyIncrementalBuildDependencyDetection) {
            return pnpmProjectDependencyManifest.deleteIfExistsAsync();
        }
        // Obtain the workspace importer from the shrinkwrap, which lists resolved dependencies
        const importerKey = pnpmShrinkwrapFile.getWorkspaceKeyByPath(this.rushConfiguration.commonTempFolder, project.projectFolder);
        const workspaceImporter = pnpmShrinkwrapFile.getWorkspaceImporter(importerKey);
        if (!workspaceImporter) {
            // Filtered installs will not contain all projects in the shrinkwrap, but if one is
            // missing during a full install, something has gone wrong
            if (this.options.toProjects.length === 0) {
                throw new node_core_library_1.InternalError(`Cannot find shrinkwrap entry using importer key for workspace project: ${importerKey}`);
            }
            return pnpmProjectDependencyManifest.deleteIfExistsAsync();
        }
        const localDependencyProjectNames = new Set(project.localDependencyProjects.map((x) => x.packageName));
        // Loop through non-local dependencies. Skip peer dependencies because they're only a constraint
        const dependencies = [
            ...project.packageJsonEditor.dependencyList,
            ...project.packageJsonEditor.devDependencyList
        ].filter((x) => x.dependencyType !== "peerDependencies" /* Peer */ && !localDependencyProjectNames.has(x.name));
        for (const { name, dependencyType } of dependencies) {
            // read the version number from the shrinkwrap entry
            let version;
            if (dependencyType === "dependencies" /* Regular */) {
                version = (workspaceImporter.dependencies || {})[name];
            }
            else if (dependencyType === "devDependencies" /* Dev */) {
                // Dev dependencies are folded into dependencies if there is a duplicate
                // definition, so we should also check there
                version =
                    (workspaceImporter.devDependencies || {})[name] || (workspaceImporter.dependencies || {})[name];
            }
            else if (dependencyType === "optionalDependencies" /* Optional */) {
                version = (workspaceImporter.optionalDependencies || {})[name];
            }
            if (!version) {
                // Optional dependencies by definition may not exist, so avoid throwing on these
                if (dependencyType !== "optionalDependencies" /* Optional */) {
                    throw new node_core_library_1.InternalError(`Cannot find shrinkwrap entry dependency "${name}" for workspace project: ${project.packageName}`);
                }
                continue;
            }
            // Add to the manifest and provide all the parent dependencies
            pnpmProjectDependencyManifest.addDependency(name, version, {
                dependencies: Object.assign(Object.assign({}, workspaceImporter.dependencies), workspaceImporter.devDependencies),
                optionalDependencies: Object.assign({}, workspaceImporter.optionalDependencies),
                peerDependencies: {}
            });
        }
        return pnpmProjectDependencyManifest.saveAsync();
    }
    /**
     * Used when invoking the NPM tool.  Appends the common configuration options
     * to the command-line.
     */
    pushConfigurationArgs(args, options) {
        super.pushConfigurationArgs(args, options);
        // Add workspace-specific args
        if (this.rushConfiguration.packageManager === 'pnpm') {
            args.push('--recursive');
            args.push('--link-workspace-packages', 'false');
            // "<package>..." selects the specified package and all direct and indirect dependencies
            for (const toProject of this.options.toProjects) {
                args.push('--filter', `${toProject.packageName}...`);
            }
        }
    }
    /**
     * Checks for projects that exist in the shrinkwrap file, but don't exist
     * in rush.json.  This might occur, e.g. if a project was recently deleted or renamed.
     *
     * @returns true if orphans were found, or false if everything is okay
     */
    _findOrphanedWorkspaceProjects(shrinkwrapFile) {
        for (const workspaceKey of shrinkwrapFile.getWorkspaceKeys()) {
            // Look for the RushConfigurationProject using the workspace key
            let rushProjectPath;
            if (this.rushConfiguration.packageManager === 'pnpm') {
                // PNPM workspace keys are relative paths from the workspace root, which is the common temp folder
                rushProjectPath = path.resolve(this.rushConfiguration.commonTempFolder, workspaceKey);
            }
            else {
                throw new node_core_library_1.InternalError('Orphaned workspaces cannot be checked for the provided package manager');
            }
            if (!this.rushConfiguration.tryGetProjectForPath(rushProjectPath)) {
                console.log(os.EOL +
                    colors_1.default.yellow(Utilities_1.Utilities.wrapWords(`Your ${this.rushConfiguration.shrinkwrapFilePhrase} references a project at "${rushProjectPath}" ` +
                        'which no longer exists.')) +
                    os.EOL);
                return true; // found one
            }
        }
        return false; // none found
    }
}
exports.WorkspaceInstallManager = WorkspaceInstallManager;
//# sourceMappingURL=WorkspaceInstallManager.js.map