{"version":3,"file":"BaseWorkspaceFile.js","sourceRoot":"","sources":["../../../src/logic/base/BaseWorkspaceFile.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAE3D,oEAA0D;AAgB1D;;GAEG;AACH,MAAsB,iBAAiB;IAAvC;QACY,wBAAmB,GAAgB,IAAI,GAAG,EAAU,CAAC;IA2CjE,CAAC;IAzCC;;OAEG;IACI,IAAI,CAAC,QAAgB,EAAE,OAAkC;QAC9D,iDAAiD;QACjD,IAAI,SAAS,GAAuB,SAAS,CAAC;QAC9C,IAAI,OAAO,CAAC,aAAa,IAAI,8BAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE;YACxD,IAAI;gBACF,SAAS,GAAG,8BAAU,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC;aACnD;YAAC,OAAO,KAAK,EAAE;gBACd,4FAA4F;gBAC5F,iBAAiB;aAClB;SACF;QAED,MAAM,OAAO,GAAW,IAAI,CAAC,SAAS,EAAE,CAAC;QAEzC,MAAM,SAAS,GAAW,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,6BAA6B;QAE7E,IAAI,OAAO,CAAC,aAAa,EAAE;YACzB,wBAAwB;YACxB,IAAI,SAAS,IAAI,MAAM,CAAC,OAAO,CAAC,SAAS,EAAE,SAAS,CAAC,KAAK,CAAC,EAAE;gBAC3D,+CAA+C;gBAC/C,OAAO;aACR;SACF;QAED,8BAAU,CAAC,SAAS,CAAC,QAAQ,EAAE,SAAS,CAAC,QAAQ,EAAE,EAAE;YACnD,kBAAkB,EAAE,OAAO,CAAC,kBAAkB;SAC/C,CAAC,CAAC;IACL,CAAC;CAWF;AA5CD,8CA4CC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport { FileSystem } from '@rushstack/node-core-library';\r\n\r\nexport interface IWorkspaceFileSaveOptions {\r\n  /**\r\n   * If there is an existing file, and the contents have not changed, then\r\n   * don't write anything; this preserves the old timestamp.\r\n   */\r\n  onlyIfChanged?: boolean;\r\n\r\n  /**\r\n   * Creates the folder recursively using FileSystem.ensureFolder()\r\n   * Defaults to false.\r\n   */\r\n  ensureFolderExists?: boolean;\r\n}\r\n\r\n/**\r\n * This class is a parser for pnpm's pnpm-workspace.yaml file format.\r\n */\r\nexport abstract class BaseWorkspaceFile {\r\n  protected _alreadyWarnedSpecs: Set<string> = new Set<string>();\r\n\r\n  /**\r\n   * Serializes and saves the workspace file to specified location\r\n   */\r\n  public save(filePath: string, options: IWorkspaceFileSaveOptions): void {\r\n    // Do we need to read the previous file contents?\r\n    let oldBuffer: Buffer | undefined = undefined;\r\n    if (options.onlyIfChanged && FileSystem.exists(filePath)) {\r\n      try {\r\n        oldBuffer = FileSystem.readFileToBuffer(filePath);\r\n      } catch (error) {\r\n        // Ignore this error, and try writing a new file.  If that fails, then we should report that\r\n        // error instead.\r\n      }\r\n    }\r\n\r\n    const newYaml: string = this.serialize();\r\n\r\n    const newBuffer: Buffer = Buffer.from(newYaml); // utf8 encoding happens here\r\n\r\n    if (options.onlyIfChanged) {\r\n      // Has the file changed?\r\n      if (oldBuffer && Buffer.compare(newBuffer, oldBuffer) === 0) {\r\n        // Nothing has changed, so don't touch the file\r\n        return;\r\n      }\r\n    }\r\n\r\n    FileSystem.writeFile(filePath, newBuffer.toString(), {\r\n      ensureFolderExists: options.ensureFolderExists\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Adds a package path to the workspace file.\r\n   *\r\n   * @virtual\r\n   */\r\n  public abstract addPackage(packagePath: string): void;\r\n\r\n  /** @virtual */\r\n  protected abstract serialize(): string;\r\n}\r\n"]}