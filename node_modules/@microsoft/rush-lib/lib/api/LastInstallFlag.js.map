{"version":3,"file":"LastInstallFlag.js","sourceRoot":"","sources":["../../src/api/LastInstallFlag.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as path from 'path';\r\n\r\nimport { FileSystem, JsonFile, JsonObject, Import } from '@rushstack/node-core-library';\r\n\r\nimport { PackageManagerName } from './packageManager/PackageManager';\r\nimport { RushConfiguration } from './RushConfiguration';\r\n\r\nconst lodash: typeof import('lodash') = Import.lazy('lodash', require);\r\n\r\nexport const LAST_INSTALL_FLAG_FILE_NAME: string = 'last-install.flag';\r\n\r\n/**\r\n * A helper class for managing last-install flags, which are persistent and\r\n * indicate that something installed in the folder was successfully completed.\r\n * It also compares state, so that if something like the Node.js version has changed,\r\n * it can invalidate the last install.\r\n * @internal\r\n */\r\nexport class LastInstallFlag {\r\n  private _path: string;\r\n  private _state: JsonObject;\r\n\r\n  /**\r\n   * Creates a new LastInstall flag\r\n   * @param folderPath - the folder that this flag is managing\r\n   * @param state - optional, the state that should be managed or compared\r\n   */\r\n  public constructor(folderPath: string, state: JsonObject = {}) {\r\n    this._path = path.join(folderPath, this.flagName);\r\n    this._state = state;\r\n  }\r\n\r\n  /**\r\n   * Returns true if the file exists and the contents match the current state.\r\n   */\r\n  public isValid(): boolean {\r\n    return this._isValid(false);\r\n  }\r\n\r\n  /**\r\n   * Same as isValid(), but with an additional check:  If the current state is not equal to the previous\r\n   * state, and an the current state causes an error, then throw an exception with a friendly message.\r\n   *\r\n   * @internal\r\n   */\r\n  public checkValidAndReportStoreIssues(): boolean {\r\n    return this._isValid(true);\r\n  }\r\n\r\n  private _isValid(checkValidAndReportStoreIssues: boolean): boolean {\r\n    let oldState: JsonObject;\r\n    try {\r\n      oldState = JsonFile.load(this._path);\r\n    } catch (err) {\r\n      return false;\r\n    }\r\n\r\n    const newState: JsonObject = this._state;\r\n\r\n    if (!lodash.isEqual(oldState, newState)) {\r\n      if (checkValidAndReportStoreIssues) {\r\n        const pkgManager: PackageManagerName = newState.packageManager;\r\n        if (pkgManager === 'pnpm') {\r\n          if (\r\n            // Only throw an error if the package manager hasn't changed from PNPM\r\n            oldState.packageManager === pkgManager &&\r\n            // Throw if the store path changed\r\n            oldState.storePath !== newState.storePath\r\n          ) {\r\n            const oldStorePath: string = oldState.storePath || '<global>';\r\n            const newStorePath: string = newState.storePath || '<global>';\r\n\r\n            throw new Error(\r\n              'Current PNPM store path does not match the last one used. This may cause inconsistency in your builds.\\n\\n' +\r\n                'If you wish to install with the new store path, please run \"rush update --purge\"\\n\\n' +\r\n                `Old Path: ${oldStorePath}\\n` +\r\n                `New Path: ${newStorePath}`\r\n            );\r\n          }\r\n        }\r\n      }\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Writes the flag file to disk with the current state\r\n   */\r\n  public create(): void {\r\n    JsonFile.save(this._state, this._path, {\r\n      ensureFolderExists: true\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Removes the flag file\r\n   */\r\n  public clear(): void {\r\n    FileSystem.deleteFile(this._path);\r\n  }\r\n\r\n  /**\r\n   * Returns the full path to the flag file\r\n   */\r\n  public get path(): string {\r\n    return this._path;\r\n  }\r\n\r\n  /**\r\n   * Returns the name of the flag file\r\n   */\r\n  protected get flagName(): string {\r\n    return LAST_INSTALL_FLAG_FILE_NAME;\r\n  }\r\n}\r\n\r\n/**\r\n * A helper class for LastInstallFlag\r\n *\r\n * @internal\r\n */\r\nexport class LastInstallFlagFactory {\r\n  /**\r\n   * Gets the LastInstall flag and sets the current state. This state is used to compare\r\n   * against the last-known-good state tracked by the LastInstall flag.\r\n   * @param rushConfiguration - the configuration of the Rush repo to get the install\r\n   * state from\r\n   *\r\n   * @internal\r\n   */\r\n  public static getCommonTempFlag(rushConfiguration: RushConfiguration): LastInstallFlag {\r\n    const currentState: JsonObject = {\r\n      node: process.versions.node,\r\n      packageManager: rushConfiguration.packageManager,\r\n      packageManagerVersion: rushConfiguration.packageManagerToolVersion\r\n    };\r\n\r\n    if (currentState.packageManager === 'pnpm' && rushConfiguration.pnpmOptions) {\r\n      currentState.storePath = rushConfiguration.pnpmOptions.pnpmStorePath;\r\n      if (rushConfiguration.pnpmOptions.useWorkspaces) {\r\n        currentState.workspaces = rushConfiguration.pnpmOptions.useWorkspaces;\r\n      }\r\n    }\r\n\r\n    return new LastInstallFlag(rushConfiguration.commonTempFolder, currentState);\r\n  }\r\n}\r\n"]}