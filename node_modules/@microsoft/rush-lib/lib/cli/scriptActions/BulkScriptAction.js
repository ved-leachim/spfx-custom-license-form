"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BulkScriptAction = void 0;
const os = __importStar(require("os"));
const colors_1 = __importDefault(require("colors"));
const node_core_library_1 = require("@rushstack/node-core-library");
const ts_command_line_1 = require("@rushstack/ts-command-line");
const node_core_library_2 = require("@rushstack/node-core-library");
const index_1 = require("../../index");
const SetupChecks_1 = require("../../logic/SetupChecks");
const TaskSelector_1 = require("../../logic/TaskSelector");
const Stopwatch_1 = require("../../utilities/Stopwatch");
const BaseScriptAction_1 = require("./BaseScriptAction");
const TaskRunner_1 = require("../../logic/taskRunner/TaskRunner");
const Utilities_1 = require("../../utilities/Utilities");
const RushConstants_1 = require("../../logic/RushConstants");
const LastLinkFlag_1 = require("../../api/LastLinkFlag");
const BuildCacheConfiguration_1 = require("../../api/BuildCacheConfiguration");
/**
 * This class implements bulk commands which are run individually for each project in the repo,
 * possibly in parallel.  The action executes a script found in the project's package.json file.
 *
 * @remarks
 * Bulk commands can be defined via common/config/command-line.json.  Rush's predefined "build"
 * and "rebuild" commands are also modeled as bulk commands, because they essentially just
 * execute scripts from package.json in the same as any custom command.
 */
class BulkScriptAction extends BaseScriptAction_1.BaseScriptAction {
    constructor(options) {
        super(options);
        this._enableParallelism = options.enableParallelism;
        this._ignoreMissingScript = options.ignoreMissingScript;
        this._isIncrementalBuildAllowed = options.incremental;
        this._commandToRun = options.commandToRun || options.actionName;
        this._ignoreDependencyOrder = options.ignoreDependencyOrder;
        this._allowWarningsInSuccessfulBuild = options.allowWarningsInSuccessfulBuild;
    }
    async runAsync() {
        // TODO: Replace with last-install.flag when "rush link" and "rush unlink" are deprecated
        const lastLinkFlag = LastLinkFlag_1.LastLinkFlagFactory.getCommonTempFlag(this.rushConfiguration);
        if (!lastLinkFlag.isValid()) {
            const useWorkspaces = this.rushConfiguration.pnpmOptions && this.rushConfiguration.pnpmOptions.useWorkspaces;
            if (useWorkspaces) {
                throw new Error(`Link flag invalid.${os.EOL}Did you run "rush install" or "rush update"?`);
            }
            else {
                throw new Error(`Link flag invalid.${os.EOL}Did you run "rush link"?`);
            }
        }
        this._doBeforeTask();
        const stopwatch = Stopwatch_1.Stopwatch.start();
        const isQuietMode = !this._verboseParameter.value;
        // if this is parallelizable, then use the value from the flag (undefined or a number),
        // if parallelism is not enabled, then restrict to 1 core
        const parallelism = this._enableParallelism ? this._parallelismParameter.value : '1';
        // Collect all custom parameter values
        const customParameterValues = [];
        for (const customParameter of this.customParameters) {
            customParameter.appendToArgList(customParameterValues);
        }
        const changedProjectsOnly = this._isIncrementalBuildAllowed && this._changedProjectsOnly.value;
        const terminal = new node_core_library_1.Terminal(new node_core_library_1.ConsoleTerminalProvider());
        const buildCacheConfiguration = await BuildCacheConfiguration_1.BuildCacheConfiguration.loadFromDefaultPathAsync(terminal, this.rushConfiguration);
        const taskSelector = new TaskSelector_1.TaskSelector({
            rushConfiguration: this.rushConfiguration,
            buildCacheConfiguration,
            toProjects: this.mergeProjectsWithVersionPolicy(this._toFlag, this._toVersionPolicy),
            fromProjects: this.mergeProjectsWithVersionPolicy(this._fromFlag, this._fromVersionPolicy),
            commandToRun: this._commandToRun,
            customParameterValues,
            isQuietMode: isQuietMode,
            isIncrementalBuildAllowed: this._isIncrementalBuildAllowed,
            ignoreMissingScript: this._ignoreMissingScript,
            ignoreDependencyOrder: this._ignoreDependencyOrder,
            packageDepsFilename: Utilities_1.Utilities.getPackageDepsFilenameForCommand(this._commandToRun)
        });
        // Register all tasks with the task collection
        const taskCollection = taskSelector.registerTasks();
        const taskRunner = new TaskRunner_1.TaskRunner(taskCollection.getOrderedTasks(), {
            quietMode: isQuietMode,
            parallelism: parallelism,
            changedProjectsOnly: changedProjectsOnly,
            allowWarningsInSuccessfulBuild: this._allowWarningsInSuccessfulBuild
        });
        try {
            await taskRunner.executeAsync();
            stopwatch.stop();
            console.log(colors_1.default.green(`rush ${this.actionName} (${stopwatch.toString()})`));
            this._doAfterTask(stopwatch, true);
        }
        catch (error) {
            stopwatch.stop();
            if (error instanceof node_core_library_1.AlreadyReportedError) {
                console.log(`rush ${this.actionName} (${stopwatch.toString()})`);
            }
            else {
                if (error && error.message) {
                    if (this.parser.isDebug) {
                        console.log('Error: ' + error.stack);
                    }
                    else {
                        console.log('Error: ' + error.message);
                    }
                }
                console.log(colors_1.default.red(`rush ${this.actionName} - Errors! (${stopwatch.toString()})`));
            }
            this._doAfterTask(stopwatch, false);
            throw new node_core_library_1.AlreadyReportedError();
        }
    }
    onDefineParameters() {
        if (this._enableParallelism) {
            this._parallelismParameter = this.defineStringParameter({
                parameterLongName: '--parallelism',
                parameterShortName: '-p',
                argumentName: 'COUNT',
                environmentVariable: "RUSH_PARALLELISM" /* RUSH_PARALLELISM */,
                description: 'Specifies the maximum number of concurrent processes to launch during a build.' +
                    ' The COUNT should be a positive integer or else the word "max" to specify a count that is equal to' +
                    ' the number of CPU cores. If this parameter is omitted, then the default value depends on the' +
                    ' operating system and number of CPU cores.'
            });
        }
        this._toFlag = this.defineStringListParameter({
            parameterLongName: '--to',
            parameterShortName: '-t',
            argumentName: 'PROJECT1',
            description: 'Run command in the specified project and all of its dependencies. "." can be used as shorthand ' +
                'to specify the project in the current working directory.',
            completions: this._getProjectNames.bind(this)
        });
        this._fromVersionPolicy = this.defineStringListParameter({
            parameterLongName: '--from-version-policy',
            argumentName: 'VERSION_POLICY_NAME',
            description: 'Run command in all projects with the specified version policy ' +
                'and all projects that directly or indirectly depend on projects with the specified version policy'
        });
        this._toVersionPolicy = this.defineStringListParameter({
            parameterLongName: '--to-version-policy',
            argumentName: 'VERSION_POLICY_NAME',
            description: 'Run command in all projects with the specified version policy and all of their dependencies'
        });
        this._fromFlag = this.defineStringListParameter({
            parameterLongName: '--from',
            parameterShortName: '-f',
            argumentName: 'PROJECT2',
            description: 'Run command in the specified project and all projects that directly or indirectly depend on the ' +
                'specified project. "." can be used as shorthand to specify the project in the current working directory.',
            completions: this._getProjectNames.bind(this)
        });
        this._verboseParameter = this.defineFlagParameter({
            parameterLongName: '--verbose',
            parameterShortName: '-v',
            description: 'Display the logs during the build, rather than just displaying the build status summary'
        });
        if (this._isIncrementalBuildAllowed) {
            this._changedProjectsOnly = this.defineFlagParameter({
                parameterLongName: '--changed-projects-only',
                parameterShortName: '-o',
                description: 'If specified, the incremental build will only rebuild projects that have changed, ' +
                    'but not any projects that directly or indirectly depend on the changed package.'
            });
        }
        this._ignoreHooksParameter = this.defineFlagParameter({
            parameterLongName: '--ignore-hooks',
            description: `Skips execution of the "eventHooks" scripts defined in rush.json. Make sure you know what you are skipping.`
        });
        this.defineScriptParameters();
    }
    async _getProjectNames() {
        const unscopedNamesMap = new Map();
        const scopedNames = [];
        const projectJsons = [
            ...this.rushConfiguration.rushConfigurationJson.projects
        ];
        for (const projectJson of projectJsons) {
            scopedNames.push(projectJson.packageName);
            const unscopedName = node_core_library_2.PackageName.getUnscopedName(projectJson.packageName);
            let count = 0;
            if (unscopedNamesMap.has(unscopedName)) {
                count = unscopedNamesMap.get(unscopedName);
            }
            unscopedNamesMap.set(unscopedName, count + 1);
        }
        const unscopedNames = [];
        for (const unscopedName of unscopedNamesMap.keys()) {
            const unscopedNameCount = unscopedNamesMap.get(unscopedName);
            // don't suggest ambiguous unscoped names
            if (unscopedNameCount === 1 && !scopedNames.includes(unscopedName)) {
                unscopedNames.push(unscopedName);
            }
        }
        return unscopedNames.sort().concat(scopedNames.sort());
    }
    _doBeforeTask() {
        if (this.actionName !== RushConstants_1.RushConstants.buildCommandName &&
            this.actionName !== RushConstants_1.RushConstants.rebuildCommandName) {
            // Only collects information for built-in tasks like build or rebuild.
            return;
        }
        SetupChecks_1.SetupChecks.validate(this.rushConfiguration);
        this.eventHooksManager.handle(index_1.Event.preRushBuild, this.parser.isDebug, this._ignoreHooksParameter.value);
    }
    _doAfterTask(stopwatch, success) {
        if (this.actionName !== RushConstants_1.RushConstants.buildCommandName &&
            this.actionName !== RushConstants_1.RushConstants.rebuildCommandName) {
            // Only collects information for built-in tasks like build or rebuild.
            return;
        }
        this._collectTelemetry(stopwatch, success);
        this.parser.flushTelemetry();
        this.eventHooksManager.handle(index_1.Event.postRushBuild, this.parser.isDebug, this._ignoreHooksParameter.value);
    }
    _collectTelemetry(stopwatch, success) {
        const extraData = {
            command_to: (this._toFlag.values.length > 0).toString(),
            command_from: (this._fromFlag.values.length > 0).toString()
        };
        for (const customParameter of this.customParameters) {
            switch (customParameter.kind) {
                case ts_command_line_1.CommandLineParameterKind.Flag:
                case ts_command_line_1.CommandLineParameterKind.Choice:
                case ts_command_line_1.CommandLineParameterKind.String:
                case ts_command_line_1.CommandLineParameterKind.Integer:
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    extraData[customParameter.longName] = JSON.stringify(customParameter.value);
                    break;
                default:
                    extraData[customParameter.longName] = '?';
            }
        }
        if (this.parser.telemetry) {
            this.parser.telemetry.log({
                name: this.actionName,
                duration: stopwatch.duration,
                result: success ? 'Succeeded' : 'Failed',
                extraData
            });
        }
    }
}
exports.BulkScriptAction = BulkScriptAction;
//# sourceMappingURL=BulkScriptAction.js.map