import { loadScriptWithoutEval } from '../../requirejs/loadScriptWithoutEval';
import AddressStore from '../../stores/AddressStore';
import ManifestStore from '../../stores/ManifestStore';
import isCorsEnabled from '../../utilities/isCorsEnabled';
import resolveAddress from '../../utilities/resolveAddress';
import { isAkamaiCrossOriginFlightEnabled } from '../common/flights';
import { normalizeComponentId, normalizeName } from '../common/normalize';
var RequireConfigurator = /** @class */ (function () {
    function RequireConfigurator(_requireJs, _useSecondaryCdn, skipBaseConfig) {
        this._requireJs = _requireJs;
        this._useSecondaryCdn = _useSecondaryCdn;
        this._configuredFailoverPaths = new Set();
        this._duplicateModuleNames = new Map();
        var config = {
            waitSeconds: 90
        };
        if (!skipBaseConfig) {
            config.baseUrl = 'https://relative-path.invalid';
        }
        // <script crossorigin="anonymous"> enables scripts be transparent to service workers
        if (isAkamaiCrossOriginFlightEnabled()) {
            config.onNodeCreated = function (node, c, n, url) {
                if (isCorsEnabled(url)) {
                    node.setAttribute('crossorigin', 'anonymous');
                }
            };
        }
        this._requireJs.config(config);
    }
    RequireConfigurator.prototype.configLoadComponent = function (manifest) {
        var resources = manifest.loaderConfig.scriptResources;
        var config = { paths: {}, map: {}, shim: {} };
        var currentMapConfig = {};
        var resourceNames = Object.keys(resources);
        for (var _i = 0, resourceNames_1 = resourceNames; _i < resourceNames_1.length; _i++) {
            var name_1 = resourceNames_1[_i];
            var resource = resources[name_1];
            if (resource.type === 'component') {
                this._configureComponentResource(name_1, resource, manifest, config, currentMapConfig);
            }
            else {
                this._configurePathResource(name_1, resource, manifest, config, currentMapConfig);
            }
        }
        var normalizedName = normalizeComponentId(manifest.id, manifest.version);
        config.map[normalizedName] = currentMapConfig;
        this._requireJs.config(config);
        // There's a global __spfxPreloadedModules that may host the define arguments for preloaded components.
        // This ensures that RequireJS will automatically load them if they are present.
        if (window.define &&
            window.__spfxPreloadedModules &&
            window.__spfxPreloadedModules.hasOwnProperty(normalizedName)) {
            var args = window.__spfxPreloadedModules[normalizedName];
            window.define(args.id, args.deps, args.f);
            delete window.__spfxPreloadedModules[normalizedName];
        }
    };
    RequireConfigurator.prototype.configLoadScript = function (url, globalExportsName) {
        var _a;
        this._requireJs.config({ shim: (_a = {}, _a[url.replace(/\.js$/, '')] = { exports: globalExportsName }, _a) });
    };
    RequireConfigurator.prototype.getDuplicateModuleName = function (moduleName) {
        return this._duplicateModuleNames.get(moduleName);
    };
    RequireConfigurator.prototype.replaceModuleInConfig = function (existingModuleName, newModuleName, modulePath) {
        var _a, _b;
        // tslint:disable-next-line:no-any
        var requireContext = this._requireJs.s.contexts._;
        this._requireJs.config({
            map: (_a = {}, _a[existingModuleName] = requireContext.config.map[newModuleName], _a),
            paths: (_b = {}, _b[existingModuleName] = modulePath, _b)
        });
        // Remove the definition (including the <script> tag) of any previously load of the same component
        // Otherwise RequireJS can't load the module again
        this._requireJs.undef(newModuleName);
        this._requireJs.undef(existingModuleName);
        // Avoid two path entries going to the same path
        requireContext.config.paths[newModuleName] = "SPFx: Use " + existingModuleName + " instead";
    };
    RequireConfigurator.prototype._configurePathResource = function (name, resource, manifest, config, mapConfig) {
        // Step 1: Set map configuration with the normalized name.
        // The normalized name of the entry point is the name of the component (i.e. <id>_<version>)
        // Other path dependencies have the resource name appended (i.e. <id>_<version>/<name>)
        var normalizedName;
        if (name === manifest.loaderConfig.entryModuleId) {
            // the entry point of the module
            normalizedName = normalizeComponentId(manifest.id, manifest.version);
        }
        else {
            normalizedName = normalizeName(manifest, name);
            mapConfig[name] = normalizedName;
        }
        // Step 2: Set path configuration with the URL of the resource.
        // If the URL for the resource is already used by another manifest, we re-use that normalized name.
        var address = resolveAddressRequire(manifest, name, this._useSecondaryCdn);
        var existingNormalizedNameForAddress = AddressStore.instance.getNormalizedName(address);
        if (existingNormalizedNameForAddress) {
            mapConfig[name] = existingNormalizedNameForAddress;
            this._duplicateModuleNames.set(normalizedName, existingNormalizedNameForAddress);
        }
        else {
            // Start downloading the script without evaluating it.
            // tslint:disable-next-line: no-floating-promises
            loadScriptWithoutEval(address);
            config.paths[normalizedName] = address;
            AddressStore.instance.set(normalizedName, address);
        }
        // Step 3: Set shim configuration with global names and dependencies, if applicable.
        // Only path configurations (not localized path configurations) support it.
        // There are some issues with JQuery and Yammer using RequireJS that we can self-recover.
        // This does nothing if JQuery or Yammer are not dependencies of the component.
        fixKnownIssues(name, manifest.loaderConfig.scriptResources, resource);
        if (resource.globalName) {
            config.shim[normalizedName] = {
                exports: resource.globalName,
                deps: resource.globalDependencies
            };
        }
    };
    RequireConfigurator.prototype._configureComponentResource = function (name, moduleConfiguration, manifest, config, mapConfig) {
        // Map the dependency to the normalized name of the component.
        var resourceManifest = ManifestStore.instance.tryGetManifest(moduleConfiguration.id, moduleConfiguration.version);
        if (resourceManifest) {
            mapConfig[name] = normalizeComponentId(resourceManifest.id, resourceManifest.version);
        }
        if (moduleConfiguration.failoverPath) {
            // Multiple components can have the same dependencies with failover paths. Configure only once.
            if (!this._configuredFailoverPaths.has(name)) {
                this._configuredFailoverPaths.add(name);
                // Store the address both in RequireJS and the AddressStore for the SPFx loader.
                var address = resolveAddressRequire(manifest, name, this._useSecondaryCdn);
                // Start downloading the script without evaluating it.
                // tslint:disable-next-line: no-floating-promises
                loadScriptWithoutEval(address);
                config.paths[name] = address;
                AddressStore.instance.set(name, address);
            }
        }
    };
    return RequireConfigurator;
}());
export { RequireConfigurator };
function resolveAddressRequire(manifest, resourceName, useSecondaryCdn) {
    // Remove the .js extension
    return resolveAddress(manifest, resourceName, useSecondaryCdn).replace(/.js$/, '');
}
function fixKnownIssues(name, resources, resource) {
    // tslint:disable:no-string-literal
    // Fix-up: Some customers declared jQuery dependency without explicitly declaring a global name in the manifest
    // Fix-up: Some customers declared the global as 'jquery' instead of 'jQuery'
    // RequireJS doesn't work properly in either of those cases
    fixWrongGlobalName(name, 'jquery', 'jquery', 'jQuery', resource);
    // Fix-up: Some customers declare JQuery UI without the dependency on JQuery
    if (name.toLowerCase() === 'jqueryui' &&
        (!resource.globalDependencies || resource.globalDependencies.length === 0)) {
        if (resources['jquery']) {
            resource.globalDependencies = ['jquery'];
        }
        else if (resources['jQuery']) {
            resource.globalDependencies = ['jQuery'];
        }
    }
    // Fix-up: Some customers declared yammer dependency without explicitly declaring a global name in the manifest
    // Fix-up: Some customers declared the global as 'yammer' instead of 'yam'
    fixWrongGlobalName(name, 'yammer', 'yammer', 'yam', resource);
    // tslint:enable:no-string-literal
}
function fixWrongGlobalName(name, expectedName, knownBadName, expectedGlobalName, resource) {
    if ((name.toLowerCase() === expectedName && !resource.globalName) || resource.globalName === knownBadName) {
        resource.globalName = expectedGlobalName;
    }
}
//# sourceMappingURL=RequireConfigurator.js.map