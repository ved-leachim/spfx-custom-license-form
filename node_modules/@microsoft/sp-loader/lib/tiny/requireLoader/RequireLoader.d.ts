import { ServiceScope } from '@microsoft/sp-core-library';
import { IClientSideComponentManifest } from '@microsoft/sp-module-interfaces';
import { ILoadScriptOptions } from '../../interfaces/ILoadScriptOptions';
import { IModuleLoader } from '../interfaces/IModuleLoader';
declare global {
    interface Window {
        requirejs: Require | undefined;
        require: Require | undefined;
        define: RequireDefine | undefined;
        /**
         * Global that's defined from the server when loading SPFx on IE. This enables executing the scripts using a mock
         * define() function that stores its parameters.
         * To be used when configuring a component to ensure that RequireJS handles it properly.
         */
        __spfxPreloadedModules?: {
            [id: string]: IPreloadedDefineArgs;
        };
    }
}
interface IPreloadedDefineArgs {
    id: string;
    deps: string[];
    f: Function;
}
/**
 * RequireJS Loader
 */
export declare class RequireLoader implements IModuleLoader {
    private readonly _serviceScope;
    private readonly _useSecondaryCdn;
    private _requireJs;
    private _define;
    private _configurator;
    private _loadComponentExecutor;
    private _systemJsFallbackLoader;
    constructor(_serviceScope: ServiceScope, _useSecondaryCdn: boolean);
    /**
     * {@inheritdoc IModuleLoader.delete}
     *
     * @remarks Calls RequireJS undef() and removes the script tag from the head.
     */
    delete(manifest: IClientSideComponentManifest): void;
    /**
     * {@inheritdoc IModuleLoader.ensure}
     */
    ensure(moduleName: string, module: unknown): void;
    /**
     * {@inheritdoc IModuleLoader.loadComponent}
     */
    loadComponent<T>(manifest: IClientSideComponentManifest): Promise<T>;
    /**
     * {@inheritdoc IModuleLoader.loadEntryPoint}
     */
    loadEntryPoint<T>(manifest: IClientSideComponentManifest, name?: string, globalName?: string): Promise<T>;
    /**
     * {@inheritdoc IModuleLoader.loadScript}
     */
    loadScript<T>(url: string, options?: ILoadScriptOptions): Promise<T>;
    /**
     * {@inheritdoc IModuleLoader.load}
     */
    load<T>(moduleName: string, globalName?: string): Promise<T>;
    private _loadComponent;
    private _ensureFallback;
    /**
     * Looks at the path to see if it is a provider hosted app.  If it is, it modifies the existing
     * module name to match the provider hosted app js module name and then loads the component.  If
     * its not that case it looks at the registry of RequireJS to find another version of the same
     * component as moduleName, if found, it configures RequireJS with the same dependency resolution
     * (that comes from the manifest) and ensuring that the path points only to the found version,
     * and it loads the component.
     */
    private _loadWithDifferentModuleId;
    private _require;
}
export {};
//# sourceMappingURL=RequireLoader.d.ts.map