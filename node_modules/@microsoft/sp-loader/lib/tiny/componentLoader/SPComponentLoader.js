import { _QosMonitor } from '@ms/sp-telemetry';
import { DebugManager } from '../../debug/DebugManager';
import ComponentStore from '../../stores/ComponentStore';
import ManifestStore from '../../stores/ManifestStore';
import { react16Version, reactComponentId, reactDomComponentId } from '../../utilities/componentConstants';
import { loadComponentQosScenarioName } from '../../utilities/telemetryConstants';
import { isDangerouslyEnableDebugKSActivated, isSkipFirstPartyLoaderLogKillswtichActivated, isDisable3PCodeKillswitchActivated, isOptimsticPreloadFilteredToViewPortKillswitchActivated } from '../common/killSwitches';
import { normalizeComponentId } from '../common/normalize';
import { startApplication } from '../common/platformLoader';
/**
 * SPFx component loader.
 *
 * @public
 */
var SPComponentLoader = /** @class */ (function () {
    function SPComponentLoader(loaderArgs) {
        var bundledComponents = loaderArgs.bundledComponents, ctor = loaderArgs.ctor, _a = loaderArgs.debugData, debugLoader = _a.debugLoader, debugManifests = _a.debugManifests, registerAsNonDebug = _a.registerAsNonDebug, preloadedData = loaderArgs.preloadedData, serviceScope = loaderArgs.serviceScope, useSecondaryCdn = loaderArgs.useSecondaryCdn;
        this._serviceScope = serviceScope;
        if (useSecondaryCdn) {
            // _TraceLogger.logError
        }
        // Let's see if we should stop here.  In order to facilitate easier diagnosis of
        // customer issues - and in particular custom code messing with common
        // functionality, we make it possible to disable all 3rd party code by using
        // the query string ?disable3PCode
        if (!isDisable3PCodeKillswitchActivated()) {
            var urlParams = new URLSearchParams(window.location.search);
            this._skipThirdPartyCode = urlParams.has('disable3PCode');
        }
        else {
            this._skipThirdPartyCode = false;
        }
        this._loader = new ctor(this._serviceScope, useSecondaryCdn);
        SPComponentLoader._headElement = document === null || document === void 0 ? void 0 : document.getElementsByTagName('head')[0];
        ManifestStore.instance.registerPreloadedManifests(preloadedData);
        if (debugManifests) {
            if (!registerAsNonDebug && !isDangerouslyEnableDebugKSActivated()) {
                ManifestStore.instance.registerDebugManifests(debugManifests);
            }
            else {
                ManifestStore.instance.registerManifests(debugManifests, registerAsNonDebug);
            }
        }
        var monitor = new _QosMonitor('SPComponentLoader.pinnedManifests');
        var pinnedManifests = [];
        // Pin and store bundled components in the assembly
        for (var _i = 0, _b = Object.keys(bundledComponents); _i < _b.length; _i++) {
            var id = _b[_i];
            var version = id === reactComponentId || id === reactDomComponentId ? react16Version : undefined;
            var shouldPin = !debugLoader && !version;
            // Only pin with the production loader to allow debug manifests to be loaded
            // We don't pin react or react-dom since components can bring in different versions
            if (shouldPin) {
                ManifestStore.instance._pinManifest(id);
            }
            var manifest = ManifestStore.instance.tryGetManifest(id, version);
            if (manifest) {
                var component = bundledComponents[id];
                var cid = normalizeComponentId(manifest.id, manifest.version);
                if (shouldPin) {
                    pinnedManifests.push(cid);
                }
                this._loader.ensure(cid, component);
                ComponentStore.instance.storeLoadedComponent(manifest.id, manifest.version, component);
            }
        }
        monitor.writeSuccess({ pinnedManifests: pinnedManifests });
    }
    /**
     * {@inheritDoc  ISPComponentLoader.loadComponent}
     */
    SPComponentLoader.prototype.loadComponent = function (manifest) {
        var monitor;
        var extraData;
        if (!manifest.isInternal && this._skipThirdPartyCode) {
            // Return an indefinitely pending promise to avoid loading the code and error handling
            return new Promise(function () { }); // tslint:disable-line:no-empty
        }
        if (isSkipFirstPartyLoaderLogKillswtichActivated() || !manifest.isInternal) {
            monitor = new _QosMonitor(loadComponentQosScenarioName);
            extraData = {
                alias: manifest.alias,
                isDebug: manifest._isDebug,
                isInternal: manifest.isInternal,
                manifestId: manifest.id,
                version: manifest.version
            };
        }
        return this._loader
            .loadComponent(manifest)
            .then(function (c) {
            if (monitor) {
                monitor.writeSuccess(extraData);
            }
            return c;
        })
            .catch(function (e) {
            if (monitor) {
                monitor.writeUnexpectedFailure(undefined, undefined, e);
            }
            throw e.systemjsError || e.requirejsError || e;
        });
    };
    /**
     * {@inheritDoc  ISPComponentLoader.loadComponentById}
     *
     * @public
     */
    SPComponentLoader.prototype.loadComponentById = function (id, version) {
        var _this = this;
        var manifest = ManifestStore.instance.tryGetManifest(id, version);
        if (manifest) {
            return this.loadComponent(manifest);
        }
        else {
            return ManifestStore.instance.requestManifest(id, version).then(function (m) { return _this.loadComponent(m); });
        }
    };
    /**
     * {@inheritDoc  ISPComponentLoader.loadCss}
     */
    SPComponentLoader.prototype.loadCss = function (url) {
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = url;
        SPComponentLoader._headElement.appendChild(link);
    };
    /**
     * {@inheritDoc  ISPComponentLoader.loadScript}
     */
    SPComponentLoader.prototype.loadScript = function (url, options) {
        var monitor = new _QosMonitor('TinySPComponentLoader.loadScript');
        return this._loader
            .loadScript(url, options)
            .then(function (m) {
            monitor.writeSuccess();
            return m;
        })
            .catch(function (e) {
            monitor.writeUnexpectedFailure(undefined, e);
            throw e;
        });
    };
    /**
     * {@inheritdoc ISPComponentLoader._loadDebugManifestsForWorkbench}
     *
     * @internal
     */
    SPComponentLoader.prototype._loadDebugManifestsForWorkbench = function (manifestsFileUrl) {
        return DebugManager.loadAndRegisterManifestsFile(this, manifestsFileUrl, true);
    };
    /**
     * {@inheritdoc ISPComponentLoader._startApplication}
     *
     * @internal
     */
    SPComponentLoader.prototype._startApplication = function (preloadedData) {
        return startApplication(preloadedData, this._serviceScope).then(function (app) {
            /*
             * Normally non-SPFx environments locate their SPFx host application via a window variable
             * that our startup code assigns like this:
             *
             *   global.moduleLoaderPromise = global.spModuleLoader.start(spClientSidePageContext, handleFailure)
             *
             * However, in the case of the modern ListView, the "listview-spfx-host" loads after the main scripts,
             * which creates a race condition where window.moduleLoaderPromise sometimes might not be assigned yet
             * when their code tries to read it.  In that situation, they can register a callback like this:
             *
             * if (window['moduleLoaderPromise']) {
             *   window['moduleLoaderPromise'].then((application) => {
             *     doSomething(application);
             *   });
             * } else {
             *   window['_spLoaderCallback'] = function(application) {
             *     doSomething(application);
             *   };
             * }
             */
            /* tslint:disable:no-string-literal */
            if (window['_spLoaderCallback']) {
                var _spLoaderCallback = window['_spLoaderCallback']; // tslint:disable-line:no-any
                _spLoaderCallback(app);
            }
            /* tslint:enable:no-string-literal */
            return app;
        });
    };
    /**
     * {@inheritdoc ISPComponentLoader._preloadComponents}
     *
     * @internal
     */
    SPComponentLoader.prototype._preloadComponents = function () {
        var _this = this;
        if (!isOptimsticPreloadFilteredToViewPortKillswitchActivated() && document && document.head) {
            var attributeName = 'data-sp-componentId';
            var preloadElements = document.head.querySelectorAll("link[rel=preload][" + attributeName + "],script[" + attributeName + "]");
            var preloadedIdSet = new Set();
            for (var i = 0; i < preloadElements.length; i++) {
                var componentId = preloadElements[i].getAttribute(attributeName);
                if (componentId && !preloadedIdSet.has(componentId)) {
                    preloadedIdSet.add(componentId);
                }
            }
            preloadedIdSet.forEach(function (id) {
                var manifest = _this.tryGetManifestById(id);
                if (manifest) {
                    // We don't need to care if these succeed or fail here, and are just focused on starting the load.
                    _this.loadComponent(manifest); // tslint:disable-line:no-floating-promises
                }
            });
        }
        else {
            ManifestStore.instance.getRegisteredManifests(true).forEach(function (manifest) {
                // We don't need to care if these succeed or fail here, and are just focused on starting the load.
                _this.loadComponent(manifest); // tslint:disable-line:no-floating-promises
            });
        }
    };
    /**
     * {@inheritdoc ISPComponentLoader._unloadComponents}
     *
     * @internal
     */
    SPComponentLoader.prototype._unloadComponents = function () {
        for (var _i = 0, _a = ManifestStore.instance.getRegisteredManifests(); _i < _a.length; _i++) {
            var m = _a[_i];
            ComponentStore.instance.deleteComponent(m.id, m.version);
            this._loader.delete(m);
        }
    };
    // #region Candidates for deletion
    SPComponentLoader.prototype.registerManifests = function (manifests) {
        ManifestStore.instance.registerManifests(manifests, false);
    };
    SPComponentLoader.prototype.requestManifest = function (id, version) {
        return ManifestStore.instance.requestManifest(id, version);
    };
    SPComponentLoader.prototype.tryGetLoadedComponent = function (manifest) {
        return ComponentStore.instance.tryGetComponentReference(manifest.id, manifest.version);
    };
    SPComponentLoader.prototype.tryGetManifestById = function (id, version) {
        return ManifestStore.instance.tryGetManifest(id, version);
    };
    Object.defineProperty(SPComponentLoader.prototype, "_manifestReferences", {
        get: function () {
            return ManifestStore.instance.getRegisteredManifests();
        },
        enumerable: false,
        configurable: true
    });
    SPComponentLoader.prototype._initialize = function (preloadedData, bundledComponents, debugData) {
        /* no-op*/
    };
    return SPComponentLoader;
}());
export { SPComponentLoader };
//# sourceMappingURL=SPComponentLoader.js.map