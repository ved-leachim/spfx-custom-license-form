import { ServiceScope } from '@microsoft/sp-core-library';
import { IClientSideComponentManifest } from '@microsoft/sp-module-interfaces';
import { IPreloadedData } from '../../interfaces/IPreloadedData';
import { IManifestStoreEntry } from '../../stores/ManifestStore';
import { ManifestProvider } from './ManifestProvider';
interface IManifestsEntry {
    /**
     * The manifest V2 payload.
     */
    manifest: IClientSideComponentManifest;
    /**
     * Indicates whether the manifests is debug or not
     */
    isDebug?: boolean;
}
interface IStoreEntry {
    /**
     * Map of the manifest entries.
     * Normalized name => manifest entry.
     */
    manifests: Map<string, IManifestsEntry>;
    /**
     * Indicates whether the manifest id is pinned or not. If a manifest
     * is pinned, no other manifest of the same id can be added.
     */
    isPinned?: boolean;
}
/**
 * Manages all the manifests on the current page and provides access to fetching manifests
 * from the server.
 */
export declare class ManifestStore {
    private readonly _provider;
    /**
     * @internalRemarks Do no use this property outside of the shim
     */
    readonly _store: Map<string, IStoreEntry>;
    private _auditLog;
    constructor(_provider: ManifestProvider);
    /**
     * Add a collection of manifests to the store.
     *
     * @param manifests - Array of manifests
     * @param shouldOverwrite - Should the manifest be added if there is an existing manifest
     * @param shouldPin - Should the manifest be pinned
     * @param isDebug - Are the manifests debug
     *
     * @returns A boolean indicating if all the manifests were added or not
     */
    addManifests(manifests: IClientSideComponentManifest[], shouldOverwrite: boolean, shouldPin: boolean, isDebug: boolean): boolean;
    /**
     * Add a manifest to the store.
     *
     * @param manifest - manifest to add
     * @param shouldOverwrite - Should the manifest be added if there is an existing manifest
     * @param shouldPin - Should the manifest be pinned
     * @param isDebug - Is the manifest debug
     *
     * @returns A boolean indicating if the manifest was added or not
     */
    addManifest(manifest: IClientSideComponentManifest, shouldOverwrite: boolean, shouldPin: boolean, isDebug: boolean): boolean;
    /**
     * Delete all non-pinned manifests in the store.
     */
    clearManifests(): void;
    /**
     * Delete a manifest from the store.
     *
     * @param id - Manifest id
     * @param version - Manifest version
     */
    deleteManifest(id: string, version: string): boolean;
    /**
     * Fetch manifests from the server.
     *
     * @param requests - Array of manifest requests
     *
     * @returns A promise resolving to an array of component manifests
     */
    fetchManifests(requests: {
        id: string;
        version?: string;
    }[]): Promise<IClientSideComponentManifest[]>;
    /**
     *
     * @deprecated This is only used in debug scenarios. Needs further refactoring.
     */
    getAllStoreEntries(): IStoreEntry[];
    /**
     * Return all manifests in the store.
     *
     * @param onlyUnloaded -  Only return the set of non-debug manifests where the component has not been loaded.
     *
     * @returns An array of component manifests.
     */
    getAllManifests(onlyUnloaded?: boolean): IClientSideComponentManifest[];
    /**
     * Get one manifest from the store.
     *
     * @param id - Manifest id
     * @param version - Manifest version
     *
     * @remarks If the version is not provided and there is no debug manifest, then if,
     *   and only if, one manifest exists return it. If multiple versions exist and there is
     *   a debug manifest, return it. Otherwise, an error is thrown. If the version is
     *   provided and multiple manifests exist, return the highest compatible version.
     *
     * @returns If the requested manifest exists, return it
     */
    getManifest(id: string, version?: string): IClientSideComponentManifest | undefined;
}
/**
 * Shim between the tiny ManifestStore and the old ManifestStore.
 *
 * To be deleted when isTinyLoaderKSActivated is removed.
 */
export declare class OldManifestStoreShim {
    private readonly _impl;
    constructor(serviceScope: ServiceScope, webAbsoluteUrl: string);
    registerPreloadedManifests(preloadedData: IPreloadedData): void;
    registerDebugManifests(manifests: IClientSideComponentManifest[]): void;
    tryGetManifest(id: string, version?: string, shouldLog?: boolean): IClientSideComponentManifest | undefined;
    getManifest(id: string, version?: string): IClientSideComponentManifest;
    getRegisteredManifests(onlyUnloaded?: boolean): IClientSideComponentManifest[];
    replaceManifests(manifests: IClientSideComponentManifest[]): void;
    _getManifestMap(): Map<string, IManifestStoreEntry>;
    registerManifests(manifests: IClientSideComponentManifest[], overwriteExisting: boolean): void;
    _pinManifest(componentId: string): void;
    requestManifest(id: string, version?: string): Promise<IClientSideComponentManifest>;
    requestManifests(requests: {
        id: string;
        version?: string;
    }[]): Promise<IClientSideComponentManifest[]>;
}
export {};
//# sourceMappingURL=ManifestStore.d.ts.map