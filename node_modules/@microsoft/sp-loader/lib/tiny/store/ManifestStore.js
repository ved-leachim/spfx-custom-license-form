import { Version, _SPFlight } from '@microsoft/sp-core-library';
import { _QosMonitor } from '@ms/sp-telemetry';
import { DebugStatus } from '../../debug/DebugStatus';
import ComponentStore from '../../stores/ComponentStore';
import { react16Version, reactComponentId, reactDomComponentId, reactDomProfilingComponentId } from '../../utilities/componentConstants';
import { isReactProfilerKSActivated, isRequestManifestKillSwitchActivated } from '../common/killSwitches';
import { normalizeComponentId } from '../common/normalize';
import { ManifestProvider } from './ManifestProvider';
/**
 * Manages all the manifests on the current page and provides access to fetching manifests
 * from the server.
 */
var ManifestStore = /** @class */ (function () {
    function ManifestStore(_provider) {
        this._provider = _provider;
        this._store = new Map();
        this._auditLog = [];
    }
    /**
     * Add a collection of manifests to the store.
     *
     * @param manifests - Array of manifests
     * @param shouldOverwrite - Should the manifest be added if there is an existing manifest
     * @param shouldPin - Should the manifest be pinned
     * @param isDebug - Are the manifests debug
     *
     * @returns A boolean indicating if all the manifests were added or not
     */
    ManifestStore.prototype.addManifests = function (manifests, shouldOverwrite, shouldPin, isDebug) {
        var isSuccess = true;
        for (var _i = 0, manifests_1 = manifests; _i < manifests_1.length; _i++) {
            var m = manifests_1[_i];
            var result = this.addManifest(m, shouldOverwrite, shouldPin, isDebug);
            isSuccess = isSuccess && result;
        }
        return isSuccess;
    };
    /**
     * Add a manifest to the store.
     *
     * @param manifest - manifest to add
     * @param shouldOverwrite - Should the manifest be added if there is an existing manifest
     * @param shouldPin - Should the manifest be pinned
     * @param isDebug - Is the manifest debug
     *
     * @returns A boolean indicating if the manifest was added or not
     */
    ManifestStore.prototype.addManifest = function (manifest, shouldOverwrite, shouldPin, isDebug) {
        var id = manifest.id, isInternal = manifest.isInternal, version = manifest.version;
        if (!isReactProfilerKSActivated() && DebugStatus.shouldUseReactDomProfiling) {
            augmentManifestForProfiling(manifest);
        }
        var storeEntry = this._store.get(id);
        if (storeEntry === null || storeEntry === void 0 ? void 0 : storeEntry.isPinned) {
            return false;
        }
        var normalizedId = normalizeComponentId(id, version);
        var existingManifest = storeEntry === null || storeEntry === void 0 ? void 0 : storeEntry.manifests.get(normalizedId);
        if (existingManifest && !shouldOverwrite) {
            return false;
        }
        if (!storeEntry) {
            storeEntry = {
                manifests: new Map()
            };
            this._store.set(id, storeEntry);
        }
        if (shouldPin ||
            (!_SPFlight.isDebugFlightEnabled && isInternal && id !== reactComponentId && id !== reactDomComponentId)) {
            storeEntry.isPinned = true;
        }
        var newEntry = { manifest: manifest };
        if (isDebug) {
            newEntry.isDebug = true;
        }
        storeEntry.manifests.set(normalizedId, newEntry);
        this._auditLog.push("addManifest: " + normalizedId);
        return true;
    };
    /**
     * Delete all non-pinned manifests in the store.
     */
    ManifestStore.prototype.clearManifests = function () {
        var _this = this;
        this._store.forEach(function (sEntry, sKey) {
            if (!sEntry.isPinned && sKey !== reactComponentId && sKey !== reactDomComponentId) {
                sEntry.manifests.forEach(function (mEntry, mKey) {
                    if (!mEntry.isDebug) {
                        // If there is only one manifest delete the whole entry
                        if (sEntry.manifests.size === 1) {
                            _this._store.delete(sKey);
                            _this._auditLog.push("clearManifests: " + sKey);
                        }
                        else {
                            sEntry.manifests.delete(mKey);
                            _this._auditLog.push("clearManiefsts: " + mKey);
                        }
                    }
                });
            }
        });
    };
    /**
     * Delete a manifest from the store.
     *
     * @param id - Manifest id
     * @param version - Manifest version
     */
    ManifestStore.prototype.deleteManifest = function (id, version) {
        var storeEntry = this._store.get(id);
        if (!storeEntry || storeEntry.isPinned) {
            return false;
        }
        if (storeEntry.manifests.size === 1) {
            this._auditLog.push("deleteManifest: " + id);
            return this._store.delete(id);
        }
        else {
            var cid = normalizeComponentId(id, version);
            this._auditLog.push("deleteManifest: " + cid);
            return storeEntry.manifests.delete(cid);
        }
    };
    /**
     * Fetch manifests from the server.
     *
     * @param requests - Array of manifest requests
     *
     * @returns A promise resolving to an array of component manifests
     */
    ManifestStore.prototype.fetchManifests = function (requests) {
        var _this = this;
        return this._provider.fetchManifests(requests).then(function (manifests) {
            _this.addManifests(manifests, false, false, false);
            return manifests;
        });
    };
    /**
     *
     * @deprecated This is only used in debug scenarios. Needs further refactoring.
     */
    ManifestStore.prototype.getAllStoreEntries = function () {
        var entries = [];
        this._store.forEach(function (sEntry) {
            entries.push(sEntry);
        });
        return entries;
    };
    /**
     * Return all manifests in the store.
     *
     * @param onlyUnloaded -  Only return the set of non-debug manifests where the component has not been loaded.
     *
     * @returns An array of component manifests.
     */
    ManifestStore.prototype.getAllManifests = function (onlyUnloaded) {
        var manifests = [];
        this._store.forEach(function (sEntry) {
            sEntry.manifests.forEach(function (mEntry) {
                if (!onlyUnloaded ||
                    !ComponentStore.instance.tryGetComponentReference(mEntry.manifest.id, mEntry.manifest.version)) {
                    if (!onlyUnloaded) {
                        manifests.push(mEntry.manifest);
                    }
                    else if (!mEntry.isDebug) {
                        // If we're only fetching unloaded manifests, then only return non-debug manifests
                        manifests.push(mEntry.manifest);
                    }
                }
            });
        });
        return manifests;
    };
    /**
     * Get one manifest from the store.
     *
     * @param id - Manifest id
     * @param version - Manifest version
     *
     * @remarks If the version is not provided and there is no debug manifest, then if,
     *   and only if, one manifest exists return it. If multiple versions exist and there is
     *   a debug manifest, return it. Otherwise, an error is thrown. If the version is
     *   provided and multiple manifests exist, return the highest compatible version.
     *
     * @returns If the requested manifest exists, return it
     */
    ManifestStore.prototype.getManifest = function (id, version) {
        var storeEntry = this._store.get(id);
        var manifest;
        if (storeEntry) {
            var manifests = storeEntry.manifests;
            if (!version) {
                if (manifests.size > 1) {
                    manifests.forEach(function (mEntry) {
                        // If multiple manifests, then return the debug manifest
                        if (mEntry.isDebug) {
                            manifest = mEntry.manifest;
                        }
                    });
                    // If no debug manifest, then a version must always be requested with multiple manifests
                    if (!manifest) {
                        throw new Error("Multiple versions of " + id);
                    }
                }
                else {
                    // We should only loop once but IE11 lacks support for Array.from and Map.values
                    manifests.forEach(function (mEntry) {
                        manifest = mEntry.manifest;
                    });
                }
            }
            else {
                var reqVersion_1 = Version.parse(version);
                var storeVersions_1 = [];
                manifests.forEach(function (mEntry) {
                    var entryVersion = mEntry.manifest.version;
                    var mVersion = Version.parse(entryVersion);
                    storeVersions_1.push("" + entryVersion);
                    if ((mVersion.greaterThan(reqVersion_1) && mVersion.satisfies(reqVersion_1)) ||
                        mVersion.equals(reqVersion_1)) {
                        reqVersion_1 = mVersion;
                        manifest = mEntry.manifest;
                    }
                });
                if (!manifest) {
                    var monitor = new _QosMonitor('ManifestStore.getManifestFailures');
                    monitor.writeUnexpectedFailure(undefined, new Error("Cannot find manifest for " + id + "_" + version + ". Store had [" + storeVersions_1.join(', ') + "]."), { addedManifestsAuditLog: this._auditLog });
                }
            }
        }
        return manifest;
    };
    return ManifestStore;
}());
export { ManifestStore };
/**
 * Remap things that depend on react-dom to react-dom-profiling if react-dom profiling is enabled
 *
 * @param manifest - the manifest to augment
 */
function augmentManifestForProfiling(manifest) {
    if (manifest.loaderConfig && manifest.loaderConfig.scriptResources) {
        for (var resourceId in manifest.loaderConfig.scriptResources) {
            if (manifest.loaderConfig.scriptResources.hasOwnProperty(resourceId)) {
                var resource = manifest.loaderConfig.scriptResources[resourceId];
                if (resource.type === 'component') {
                    var componentResource = resource;
                    if (componentResource.id === reactDomComponentId && componentResource.version === react16Version) {
                        componentResource.id = reactDomProfilingComponentId;
                    }
                }
            }
        }
    }
}
/**
 * Shim between the tiny ManifestStore and the old ManifestStore.
 *
 * To be deleted when isTinyLoaderKSActivated is removed.
 */
var OldManifestStoreShim = /** @class */ (function () {
    function OldManifestStoreShim(serviceScope, webAbsoluteUrl) {
        this._impl = new ManifestStore(new ManifestProvider(serviceScope, webAbsoluteUrl));
    }
    OldManifestStoreShim.prototype.registerPreloadedManifests = function (preloadedData) {
        var manifests = preloadedData.manifests;
        this._impl.addManifests(manifests, true, false, false);
        // tslint:disable-next-line:no-string-literal
        this._impl.addManifests(window['g_webPartManifests'] || [], true, false, false);
    };
    OldManifestStoreShim.prototype.registerDebugManifests = function (manifests) {
        this._impl.addManifests(manifests, true, false, true);
    };
    OldManifestStoreShim.prototype.tryGetManifest = function (id, version, shouldLog) {
        if (shouldLog === void 0) { shouldLog = true; }
        try {
            return this._impl.getManifest(id, version);
        }
        catch (e) {
            return undefined;
        }
    };
    OldManifestStoreShim.prototype.getManifest = function (id, version) {
        var m = this._impl.getManifest(id, version);
        if (m) {
            return m;
        }
        else {
            throw new Error("Manifest not found " + normalizeComponentId(id, version || ''));
        }
    };
    OldManifestStoreShim.prototype.getRegisteredManifests = function (onlyUnloaded) {
        return this._impl.getAllManifests(onlyUnloaded);
    };
    OldManifestStoreShim.prototype.replaceManifests = function (manifests) {
        this._impl.clearManifests();
        this._impl.addManifests(manifests, false, false, false);
    };
    OldManifestStoreShim.prototype._getManifestMap = function () {
        var retVal = new Map();
        this._impl._store.forEach(function (sEntry) {
            sEntry.manifests.forEach(function (mEntry, mEntryKey) {
                var isDebug = mEntry.isDebug, _a = mEntry.manifest, id = _a.id, version = _a.version;
                var val = { id: id, version: version };
                if (isDebug) {
                    val.debugManifest = mEntry.manifest;
                }
                else {
                    val.manifest = mEntry.manifest;
                }
                retVal.set(mEntryKey, val);
            });
        });
        return retVal;
    };
    OldManifestStoreShim.prototype.registerManifests = function (manifests, overwriteExisting) {
        this._impl.addManifests(manifests, overwriteExisting, false, false);
    };
    OldManifestStoreShim.prototype._pinManifest = function (componentId) {
        var entry = this._impl._store.get(componentId);
        if (entry) {
            entry.isPinned = true;
        }
    };
    OldManifestStoreShim.prototype.requestManifest = function (id, version) {
        var _this = this;
        if (isRequestManifestKillSwitchActivated()) {
            return this._impl.fetchManifests([{ id: id, version: version }]).then(function () {
                return _this._impl.getManifest(id, version);
            });
        }
        else {
            var monitor = new _QosMonitor('ManifestStore.RequestManifest');
            var manifest = this._impl.getManifest(id, version);
            if (manifest) {
                monitor.writeSuccess();
                return Promise.resolve(manifest);
            }
            else {
                monitor.writeUnexpectedFailure(undefined, new Error("Manifest " + id + "_" + version + " not in store"));
                return this._impl.fetchManifests([{ id: id, version: version }]).then(function () {
                    return _this._impl.getManifest(id, version);
                });
            }
        }
    };
    OldManifestStoreShim.prototype.requestManifests = function (requests) {
        return this._impl.fetchManifests(requests);
    };
    return OldManifestStoreShim;
}());
export { OldManifestStoreShim };
//# sourceMappingURL=ManifestStore.js.map