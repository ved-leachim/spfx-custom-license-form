import { _QosMonitor } from '@ms/sp-telemetry';
import ComponentStore from '../../stores/ComponentStore';
import ManifestStore from '../../stores/ManifestStore';
import { isLoadComponentDependenciesKillSwitchActivated } from './killSwitches';
// tslint:disable:export-name
/**
 * Load all the component dependencies of an SPFx component.
 *
 * @param loader - Module loader instance.
 * @param manifest - Manifest of the dependent component.
 * @param depNames - Array of dependency names.
 *
 * @returns An array of Promises resolving to a respective dependency.
 */
export function loadComponentDependencies(loader, manifest, depNames) {
    var deps = [];
    var scriptResources = manifest.loaderConfig.scriptResources;
    var _loop_1 = function (depName) {
        var resource = scriptResources[depName];
        if (!resource.shouldNotPreload && resource.type === 'component') {
            var dep = loadComponentDependency(loader, depName, resource);
            if (dep) {
                if (isLoadComponentDependenciesKillSwitchActivated()) {
                    deps.push(dep);
                }
                else {
                    deps.push(dep.catch(function (originalError) {
                        var monitor = new _QosMonitor('SPLoader.loadComponentDependenciesFailures');
                        var mId = manifest.id, mVersion = manifest.version;
                        var _a = resource, id = _a.id, version = _a.version;
                        monitor.writeUnexpectedFailure(undefined, new Error("Could not load dependency " + id + "_" + version + " for dependent " + mId + "_" + mVersion), { originalError: originalError });
                        throw originalError;
                    }));
                }
            }
        }
    };
    for (var _i = 0, depNames_1 = depNames; _i < depNames_1.length; _i++) {
        var depName = depNames_1[_i];
        _loop_1(depName);
    }
    return deps;
}
/**
 * Load all the path dependencies of an SPFx component.
 *
 * @param loader - Module loader instance.
 * @param manifest - Manifest of the dependent component.
 * @param depNames - Array of dependency names.
 *
 * @returns An array of Promises resolving to a respective dependency.
 */
export function loadPathDependencies(loader, manifest, depNames) {
    var deps = [];
    var loadedPathDeps = new Set();
    var _a = manifest.loaderConfig, entryModuleId = _a.entryModuleId, scriptResources = _a.scriptResources;
    for (var _i = 0, depNames_2 = depNames; _i < depNames_2.length; _i++) {
        var depName = depNames_2[_i];
        var resource = scriptResources[depName];
        if (!resource.shouldNotPreload &&
            (resource.type === 'path' || resource.type === 'localizedPath') &&
            !loadedPathDeps.has(depName) &&
            depName !== entryModuleId) {
            loadedPathDeps.add(depName);
            deps.push(loadPathDependency(loader, manifest, depName, resource, loadedPathDeps));
        }
    }
    return deps;
}
/**
 * Load a component dependency.
 *
 * @param loader - Module loader instance.
 * @param name - Name of the dependency to load.
 * @param resource - Module configuration of the dependency.
 *
 * @returns A promise resolving to the dependency or undefined if the dependency did not need to be loaded.
 */
function loadComponentDependency(loader, name, resource) {
    var dep;
    var depManifest = ManifestStore.instance.tryGetManifest(resource.id, resource.version);
    if (depManifest) {
        // If the dependency has been loaded then skip trying to load it
        var depReference = ComponentStore.instance.tryGetComponentReference(depManifest.id, depManifest.version);
        if (!depReference) {
            dep = loader.loadComponent(depManifest);
        }
    }
    else {
        if (resource.failoverPath) {
            dep = loader.load(name);
        }
        else {
            dep = ManifestStore.instance
                .requestManifest(resource.id, resource.version)
                .then(function (m) { return loader.loadComponent(m); });
        }
    }
    return dep;
}
/**
 * Load a path dependency.
 *
 * @param loader - Module loader instance.
 * @param manifest - Manifest of the dependent component.
 * @param name - Name of the path dependency.
 * @param resource - Configuration of the path dependency.
 * @param loadedPathDependencies - Set of already loaded path dependencies.
 */
function loadPathDependency(loader, manifest, name, resource, loadedPathDependencies) {
    var globalDeps = [];
    if (resource.globalDependencies) {
        for (var _i = 0, _a = resource.globalDependencies; _i < _a.length; _i++) {
            var gDep = _a[_i];
            // If a path dependency is a dependency of another path we should still only load it once
            if (!loadedPathDependencies.has(gDep)) {
                loadedPathDependencies.add(gDep);
                var gResource = manifest.loaderConfig.scriptResources[gDep];
                globalDeps.push(loadPathDependency(loader, manifest, gDep, gResource, loadedPathDependencies));
            }
        }
    }
    return Promise.all(globalDeps).then(function () { return loader.loadEntryPoint(manifest, name, resource.globalName); });
}
//# sourceMappingURL=dependencyLoading.js.map