import { Text, _SPFlight } from '@microsoft/sp-core-library';
import { isReactProfilerKSActivated } from '../tiny/common/killSwitches';
import ManifestStore from './../stores/ManifestStore';
import { DebugStatus } from './DebugStatus';
import showDebugError from './showDebugError';
import * as strings from './DebugManager.resx';
/**
 * Put debug data in a session variable so it gets cleared when the browser or tab is closed.
 */
var SPFX_DEBUG_SESSION_VAR_ID = 'spfx-debug';
/**
 * The ?debugManifestsFile query parameter
 */
var DEBUG_MANIFESTS_FILE_QUERY_PARAM_NAME = 'debugManifestsFile';
/**
 * The ?livereload query parameter. This enabled automatic reloading when using gulp serve
 */
var LIVERELOAD_QUERY_PARAM_NAME = 'livereload';
/**
 * The ?loader query parameter. This is replacing the ?moduleLoader query parameter
 */
var LOADER_QUERY_PARAM_NAME = 'loader';
/**
 * Resets the debug state. Mutually exclusive to all other debug parameters.
 */
var RESET_QUERY_PARAM_NAME = 'reset';
/**
 * If set to "true", use the react-dom profiling bundle.
 */
var REACT_PROFILER = 'react-profiler';
var LOADER_EXPORTS_NAME = 'spModuleLoader';
var EMPTY_DEBUG_LOAD_RESULT = {
    debugLoader: undefined,
    debugManifests: undefined,
    liveReload: false,
    registerAsNonDebug: false
};
/**
 * Provides APIs to manage debug scripts.
 *
 * This is used in order to provide security measures before running arbitrary code, and to provide
 * improved debugging experience when a debug loader is used.
 *
 * @internal
 */
var DebugManager = /** @class */ (function () {
    function DebugManager() {
    }
    /**
     * Checks if debug scripts are requested.
     * This method is the first thing called after flights are initialized in SPStarter.start() and should not be called
     * anywhere else.
     *
     * The following cases are supported (in order):
     *  - If the ?reset query parameter is present, clear the debug data and load the page normally.
     *  - If there is SPFX Debug session data containing the testMode property, load the scripts specified in the
     *      session data and return the debug loader and/or manifests. This case is only used for integration tests. The
     *      session data will get set externally by the test harness.
     *  - If the ?loader and/or the ?debugManifestsFile query parameter is present, prompt for
     *      consent and, if consent is granted, load the scripts, record the URLs in the SPFX Debug session data, and
     *      return the debug loader and/or manifests.
     *  - If there is SPFX Debug session data containing a loader URL and/or a manifests file URL, prompt for consent and,
     *      if consent is granted, load the scripts and return the debug loader and/or debug manifests.
     *  - In all other cases, return with no debug loader or manifests.
     *
     * @param componentLoader - The component loader to use to load debug scripts.
     * @param debugData - If defined, the currently executing loader is already a debug loader and the
     *  specified debug data was loaded by the non-debug loader. If the currently executing loader is already a debug
     *  loader, just set these manifests in the manifest store and return.
     *
     * @returns Promise optionally resolving to a debug loader.
     */
    DebugManager.initialize = function (componentLoader, debugData) {
        var queryParameters = new URL(window.location.href).searchParams;
        if (debugData) {
            if (!isReactProfilerKSActivated()) {
                // Currently we can limit this to debugging and allow it for production if needed.
                DebugStatus.shouldUseReactDomProfiling =
                    (queryParameters.get(REACT_PROFILER) || '').toLowerCase() === 'true';
            }
            DebugStatus.dangerouslyEnableDebug();
            DebugManager._registerManifests(debugData.debugManifests || [], debugData.registerAsNonDebug);
            if (debugData.liveReload) {
                DebugManager._enableLiveReload(componentLoader);
            }
            return Promise.resolve(EMPTY_DEBUG_LOAD_RESULT);
        }
        if (!DebugManager._initializationPromise) {
            var spfxDebugSessionData_1 = {};
            var isSpfxDebugEnabled = _SPFlight.isDebugFlightEnabled;
            try {
                spfxDebugSessionData_1 = JSON.parse(sessionStorage.getItem(SPFX_DEBUG_SESSION_VAR_ID) || '{}');
            }
            catch (e) {
                // Error parsing session data. Assume there is no debug session data.
            }
            DebugManager._initializationPromise = DebugManager._handleDebugParameters(componentLoader, spfxDebugSessionData_1, queryParameters, isSpfxDebugEnabled).then(function (debugLoadResult) {
                if (!isReactProfilerKSActivated()) {
                    // Currently we can limit this to debugging and allow it for production if needed.
                    DebugStatus.shouldUseReactDomProfiling =
                        (queryParameters.get(REACT_PROFILER) || '').toLowerCase() === 'true';
                }
                // Always re-save the session data before continuing
                spfxDebugSessionData_1.liveReload = DebugManager._liveReload;
                spfxDebugSessionData_1.loaderUrl = DebugManager._debugLoaderUrl;
                spfxDebugSessionData_1.manifestsFileUrl = DebugManager._debugManifestsFileUrl;
                try {
                    var serializedDebugSessionData = JSON.stringify(spfxDebugSessionData_1);
                    if (serializedDebugSessionData !== '{}') {
                        sessionStorage.setItem(SPFX_DEBUG_SESSION_VAR_ID, serializedDebugSessionData);
                    }
                    else {
                        sessionStorage.removeItem(SPFX_DEBUG_SESSION_VAR_ID);
                    }
                }
                catch (e) {
                    // If we get an error saving the debug session data, don't interrupt the rest of the initialization flow
                }
                return debugLoadResult;
            });
        }
        return DebugManager._initializationPromise;
    };
    DebugManager.loadAndRegisterManifestsFile = function (componentLoader, manifestsFileUrl, registerAsNonDebug) {
        return componentLoader
            .loadScript(manifestsFileUrl)
            .then(function (manifestScript) {
            var manifests = manifestScript.getManifests();
            DebugManager._registerManifests(manifests, registerAsNonDebug);
            return manifests;
        });
    };
    DebugManager._handleDebugParameters = function (componentLoader, spfxDebugSessionData, queryParameters, isSpfxDebugEnabled) {
        return new Promise(function (resolve) {
            if (queryParameters.get(RESET_QUERY_PARAM_NAME) !== null) {
                // The ?reset query parameter is present, clear the debug data and load the page normally.
                spfxDebugSessionData.testMode = undefined;
                sessionStorage.removeItem(SPFX_DEBUG_SESSION_VAR_ID);
                resolve(EMPTY_DEBUG_LOAD_RESULT);
            }
            else if (isSpfxDebugEnabled && spfxDebugSessionData.testMode) {
                // The test mode session property is set
                DebugStatus.dangerouslyEnableDebug();
                DebugManager._debugManifestsFileUrl = spfxDebugSessionData.manifestsFileUrl;
                DebugManager._debugLoaderUrl = spfxDebugSessionData.loaderUrl;
                DebugManager._getDebugScripts(componentLoader, resolve, /* registerAsNonDebug */ false);
            }
            else {
                // We aren't in test mode, so keep going with the normal debug loader flow
                DebugManager._handleNonTestModeDebugParameters(componentLoader, spfxDebugSessionData, queryParameters, isSpfxDebugEnabled, resolve);
            }
        });
    };
    DebugManager._handleNonTestModeDebugParameters = function (componentLoader, spfxDebugSessionData, queryParameters, isSpfxDebugEnabled, resolve) {
        var debugManifestsFileUrl = queryParameters.get(DEBUG_MANIFESTS_FILE_QUERY_PARAM_NAME) ||
            spfxDebugSessionData.manifestsFileUrl ||
            undefined;
        var debugLoaderUrl = isSpfxDebugEnabled
            ? queryParameters.get(LOADER_QUERY_PARAM_NAME) || spfxDebugSessionData.loaderUrl || undefined
            : undefined;
        var liveReload = isSpfxDebugEnabled
            ? queryParameters.get(LIVERELOAD_QUERY_PARAM_NAME) === 'true' ||
                spfxDebugSessionData.liveReload ||
                false
            : false;
        // Check if the manifests file and/or the loader that we're trying to use have already been
        // allowed and set in the sessionStorage debug data. If they've already been allowed, we don't have to
        // prompt the user again.
        var loaderDebugAlreadyAllowed = debugLoaderUrl === spfxDebugSessionData.loaderUrl;
        var manifestsDebugAlreadyAllowed = debugManifestsFileUrl === spfxDebugSessionData.manifestsFileUrl;
        if (debugLoaderUrl || debugManifestsFileUrl) {
            DebugStatus.confirmDebugAllowed({
                loaderRequested: !!debugLoaderUrl,
                manifestsRequested: !!debugManifestsFileUrl,
                loaderDebugAlreadyAllowed: loaderDebugAlreadyAllowed,
                manifestsDebugAlreadyAllowed: manifestsDebugAlreadyAllowed
            })
                .then(function (allowed) {
                if (allowed) {
                    // Save the debug URLs onto the DebugManager's state so they will be written to the debug
                    // session data
                    DebugManager._liveReload = liveReload;
                    DebugManager._debugLoaderUrl = debugLoaderUrl;
                    DebugManager._debugManifestsFileUrl = debugManifestsFileUrl;
                    DebugManager._getDebugScripts(componentLoader, resolve, /* registerAsNonDebug */ false);
                }
                else {
                    resolve(EMPTY_DEBUG_LOAD_RESULT);
                }
            })
                .catch(console.error);
        }
        else {
            // No debug scripts requested.
            resolve(EMPTY_DEBUG_LOAD_RESULT);
        }
    };
    DebugManager._getDebugScripts = function (componentLoader, resolve, registerAsNonDebug) {
        var loaderUrl = DebugManager._debugLoaderUrl;
        var manifestFileUrl = DebugManager._debugManifestsFileUrl;
        var debugLoaderPromise = loaderUrl
            ? DebugManager._loadLoader(componentLoader, loaderUrl)
            : Promise.resolve(undefined);
        var debugManifestsFilePromise = manifestFileUrl
            ? DebugManager.loadAndRegisterManifestsFile(componentLoader, manifestFileUrl, registerAsNonDebug)
            : Promise.resolve(undefined);
        // Wrap errors so we know where the error came from
        debugLoaderPromise = debugLoaderPromise.catch(function (error) {
            throw { errorSource: 'loader', error: error };
        });
        debugManifestsFilePromise = debugManifestsFilePromise.catch(function (error) {
            throw { errorSource: 'manifestsFile', error: error };
        });
        Promise.all([debugLoaderPromise, debugManifestsFilePromise])
            .then(function (_a) {
            var debugLoader = _a[0], debugManifests = _a[1];
            resolve({ debugLoader: debugLoader, debugManifests: debugManifests, liveReload: DebugManager._liveReload, registerAsNonDebug: registerAsNonDebug });
        })
            .catch(function (error) {
            if (error instanceof Error) {
                showDebugError(error, strings.errorLoadingDebugScriptUnknown, strings.errorLoadingUnknownTitle).catch(console.error);
            }
            else {
                var errorText = strings.errorLoadingDebugScriptUnknown;
                var title = strings.errorLoadingUnknownTitle;
                switch (error.errorSource) {
                    case 'loader':
                        errorText = DebugManager._getUrlErrorText(loaderUrl || '', LOADER_QUERY_PARAM_NAME);
                        title = strings.errorLoadingDebugLoaderTitle;
                        break;
                    case 'manifestsFile':
                        errorText = DebugManager._getUrlErrorText(manifestFileUrl || '', DEBUG_MANIFESTS_FILE_QUERY_PARAM_NAME);
                        title = strings.errorLoadingDebugManifestTitle;
                        break;
                }
                showDebugError(error.error, errorText, title).catch(console.error);
            }
        });
    };
    DebugManager._loadLoader = function (componentLoader, loaderUrl) {
        // This deletes the variable window.spModuleLoader created by the assembly
        delete window[LOADER_EXPORTS_NAME];
        // Delete all existing webpackJsonp globals before loading a new assembly
        for (var _i = 0, _a = Object.keys(window); _i < _a.length; _i++) {
            var globalName = _a[_i];
            if (globalName.match(/^webpackJsonp/i)) {
                delete window[globalName];
            }
        }
        return componentLoader.loadScript(loaderUrl, { globalExportsName: LOADER_EXPORTS_NAME });
    };
    DebugManager._getUrlErrorText = function (url, paramName) {
        var isMalformed = !url.match(/^https?\:\/\//);
        var isHttps = !isMalformed && !!url.match(/^https/);
        return isMalformed
            ? Text.format(strings.errorLoadingDebugScriptMalformed, url)
            : Text.format(isHttps ? strings.errorLoadingDebugScriptHTTPS : strings.errorLoadingDebugScriptHTTP, paramName);
    };
    DebugManager._registerManifests = function (manifests, registerAsNonDebug) {
        if (registerAsNonDebug) {
            ManifestStore.instance.registerManifests(manifests, false);
        }
        else {
            ManifestStore.instance.registerDebugManifests(manifests);
        }
    };
    DebugManager._enableLiveReload = function (componentLoader) {
        try {
            // This is the default port and default location of the livereload script from gulp-connect
            // We don't override these in the sp-client build chain. Once we have proper Hot Module Replacement
            // from react/webpack-dev-server this code will be made redundant.
            componentLoader.loadScript('https://localhost:35729/livereload.js').catch(function () {
                /* no-op */
            });
        }
        catch (_) {
            /* no-op */
        }
    };
    return DebugManager;
}());
export { DebugManager };
//# sourceMappingURL=DebugManager.js.map